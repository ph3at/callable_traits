/* This file was auto-generated */

#include <functional>
#include <string>
#include <type_traits>
#include "../include/callable_traits.hpp"
#include "callable_traits_test_helper.hpp"

void fn_0();
static_assert(std::is_same_v<callable_traits<decltype(fn_0)>::result_type, void>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<decltype(fn_0)>>> == false);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<decltype(fn_0)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<decltype(fn_0)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<decltype(fn_0)>>> == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_0)>>>::arity == 0);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_0)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_0)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_0)>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_0)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_0)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_0)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_0)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_0)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_0)>>>>> == false);
void * fn_1(void *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_1)>>>>::result_type, void *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_1)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_1)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_1)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_1)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_1)>>::arg0_type, void *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_1)>>>::arg_type<0>, void *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_1)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_1)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_1)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_1)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_1)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_1)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_1)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_1)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_1)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_1)>>>>>> == false);
const void * fn_2(const void *);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_2)>>>>::result_type, const void *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_2)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_2)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_2)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_2)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_2)>>>>>::arg0_type, const void *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_2)>>>>>::arg_type<0>, const void *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_2)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_2)>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_2)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_2)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_2)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_2)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_2)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_2)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_2)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_2)>>>>> == false);
volatile void * fn_3(volatile void *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_3)>>>>>::result_type, volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_3)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_3)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_3)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_3)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_3)>>>>>::arg0_type, volatile void *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_3)>>>>>::arg_type<0>, volatile void *>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_3)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_3)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_3)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_3)>>>>>::is_variadic == true);
static_assert(callable_traits<decltype(fn_3)>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<decltype(fn_3)>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_3)>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_3)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_3)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_3)>>>> == false);
const volatile void * fn_4(const volatile void *);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_4)>>>::result_type, const volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_4)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_4)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_4)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_4)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_4)>>>>::arg0_type, const volatile void *>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_4)>>>::arg_type<0>, const volatile void *>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_4)>>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_4)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_4)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_4)>>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_4)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_4)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_4)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_4)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_4)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_4)>>>> == false);
void * & fn_5(void * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_5)>>>::result_type, void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_5)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_5)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_5)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_5)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_5)>>>>::arg0_type, void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_5)>>>>>::arg_type<0>, void * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_5)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_5)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_5)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_5)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_5)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_5)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_5)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_5)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_5)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_5)>>>>>> == false);
const void * & fn_6(const void * &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_6)>>::result_type, const void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_6)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_6)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_6)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_6)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_6)>>>>::arg0_type, const void * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_6)>>>>::arg_type<0>, const void * &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_6)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_6)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_6)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_6)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_6)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_6)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_6)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_6)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_6)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_6)>>>>> == false);
volatile void * & fn_7(volatile void * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_7)>>>>>::result_type, volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_7)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_7)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(fn_7)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<decltype(fn_7)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_7)>>::arg0_type, volatile void * &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_7)>>::arg_type<0>, volatile void * &>);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_7)>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_7)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_7)>>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_7)>>>::is_variadic == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_7)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_7)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_7)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_7)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_7)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_7)>>>>> == false);
const volatile void * & fn_8(const volatile void * &);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_8)>>>>::result_type, const volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_8)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_8)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_8)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_8)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_8)>>>>::arg0_type, const volatile void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_8)>>::arg_type<0>, const volatile void * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_8)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_8)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_8)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_8)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_8)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_8)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_8)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_8)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_8)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_8)>>>>>> == false);
void * const & fn_9(void * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_9)>>>>>::result_type, void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_9)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_9)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_9)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_9)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_9)>>>>::arg0_type, void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_9)>>>>>::arg_type<0>, void * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_9)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_9)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_9)>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_9)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_9)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_9)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_9)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_9)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_9)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_9)>>>>> == false);
const void * const & fn_10(const void * const &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_10)>>>>::result_type, const void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_10)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_10)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_10)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_10)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_10)>>>>>::arg0_type, const void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_10)>>>>>::arg_type<0>, const void * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_10)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_10)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_10)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_10)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_10)>>>>>::is_noexcept == false);
static_assert(callable_traits<decltype(fn_10)>::is_const == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_10)>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_10)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_10)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<decltype(fn_10)>>> == false);
volatile void * const & fn_11(volatile void * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_11)>>>::result_type, volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_11)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_11)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_11)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_11)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_11)>>>>::arg0_type, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_11)>>>>::arg_type<0>, volatile void * const &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_11)>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_11)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_11)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_11)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_11)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_11)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_11)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_11)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_11)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_11)>>>> == false);
const volatile void * const & fn_12(const volatile void * const &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_12)>>>::result_type, const volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_12)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_12)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_12)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_12)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_12)>>>>::arg0_type, const volatile void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_12)>>>>::arg_type<0>, const volatile void * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_12)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_12)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_12)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_12)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_12)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_12)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_12)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_12)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_12)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_12)>>>>>> == false);
void * volatile & fn_13(void * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_13)>>>>>::result_type, void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_13)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_13)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_13)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_13)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_13)>>>::arg0_type, void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_13)>>>>::arg_type<0>, void * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_13)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_13)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_13)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_13)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_13)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_13)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_13)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_13)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_13)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_13)>>>>>> == false);
const void * volatile & fn_14(const void * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_14)>>>>::result_type, const void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_14)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_14)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_14)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(fn_14)>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_14)>>::arg0_type, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_14)>>::arg_type<0>, const void * volatile &>);
static_assert(callable_traits<std::add_cv_t<decltype(fn_14)>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_14)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_14)>>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_14)>>>::is_variadic == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_14)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_14)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_14)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_14)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_14)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_14)>>>> == false);
volatile void * volatile & fn_15(volatile void * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_15)>>>>::result_type, volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_15)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_15)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_15)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_15)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_15)>>>>::arg0_type, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_15)>>>>::arg_type<0>, volatile void * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_15)>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_15)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_15)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_15)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_15)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_15)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_15)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_15)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_15)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_15)>>>>>> == false);
const volatile void * volatile & fn_16(const volatile void * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_16)>>>>>::result_type, const volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_16)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_16)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_16)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_16)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_16)>>>>>::arg0_type, const volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_16)>>>>::arg_type<0>, const volatile void * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_16)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_16)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_16)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_16)>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_16)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_16)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_16)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_16)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_16)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_16)>>>>> == false);
void * const volatile & fn_17(void * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_17)>>>>::result_type, void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_17)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_17)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_17)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_17)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_17)>>>>::arg0_type, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_17)>>>>>::arg_type<0>, void * const volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_17)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_17)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_17)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_17)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_17)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_17)>>>>>::is_const == false);
static_assert(callable_traits<decltype(fn_17)>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_17)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_17)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<decltype(fn_17)>>> == false);
const void * const volatile & fn_18(const void * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_18)>>::result_type, const void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_18)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_18)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_18)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_18)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_18)>>>>::arg0_type, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_18)>>>>::arg_type<0>, const void * const volatile &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_18)>>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_18)>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_18)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_18)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_18)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_18)>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_18)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_18)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_18)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_18)>>> == false);
volatile void * const volatile & fn_19(volatile void * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_19)>>>::result_type, volatile void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_19)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_19)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_19)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_19)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_19)>>>>::arg0_type, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_19)>>>>::arg_type<0>, volatile void * const volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_19)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_19)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_19)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_19)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_19)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_19)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_19)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_19)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_19)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_19)>>>>>> == false);
const volatile void * const volatile & fn_20(const volatile void * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_20)>>>>>::result_type, const volatile void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_20)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_20)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_20)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_20)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_20)>>>::arg0_type, const volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_20)>>>::arg_type<0>, const volatile void * const volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_20)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_20)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_20)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_20)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_20)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_20)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_20)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_20)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_20)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_20)>>>>>> == false);
void * && fn_21(void * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_21)>>>>>::result_type, void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_21)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_21)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_21)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_21)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<decltype(fn_21)>::arg0_type, void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_21)>>::arg_type<0>, void * &&>);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_21)>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<decltype(fn_21)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_21)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_21)>>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_21)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_21)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_21)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_21)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_21)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_21)>>>>> == false);
const void * && fn_22(const void * &&);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_22)>>>::result_type, const void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_22)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_22)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_22)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_22)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_22)>>>>::arg0_type, const void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_22)>>>>::arg_type<0>, const void * &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_22)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_22)>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_22)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_22)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_22)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_22)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_22)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_22)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_22)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_22)>>>>> == false);
volatile void * && fn_23(volatile void * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_23)>>>>>::result_type, volatile void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_23)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_23)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_23)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_23)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_23)>>>>>::arg0_type, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_23)>>>>>::arg_type<0>, volatile void * &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_23)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_23)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_23)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_23)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_23)>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_23)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_23)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_23)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_23)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_23)>>>>> == false);
const volatile void * && fn_24(const volatile void * &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_24)>>>>::result_type, const volatile void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_24)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_24)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_24)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_24)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_24)>>>>>::arg0_type, const volatile void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_24)>>>>::arg_type<0>, const volatile void * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_24)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_24)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_24)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_24)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_24)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_24)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_24)>>>>>::is_volatile == false);
static_assert(callable_traits<decltype(fn_24)>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_24)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<decltype(fn_24)>>> == false);
void * const && fn_25(void * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_25)>>::result_type, void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<decltype(fn_25)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_25)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_25)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_25)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_25)>>>::arg0_type, void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_25)>>>>::arg_type<0>, void * const &&>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_25)>>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_25)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_25)>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_25)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_25)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_25)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_25)>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_25)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_25)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_25)>>>>> == false);
const void * const && fn_26(const void * const &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_26)>>::result_type, const void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_26)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_26)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_26)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_26)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_26)>>>>::arg0_type, const void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_26)>>>>::arg_type<0>, const void * const &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_26)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_26)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_26)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_26)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_26)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_26)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_26)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_26)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_26)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_26)>>>>> == false);
volatile void * const && fn_27(volatile void * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_27)>>>>>::result_type, volatile void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_27)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_27)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_27)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_27)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_27)>>>::arg0_type, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_27)>>>::arg_type<0>, volatile void * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_27)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_27)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_27)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_27)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_27)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_27)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_27)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_27)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_27)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_27)>>>>>> == false);
const volatile void * const && fn_28(const volatile void * const &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_28)>>>>>::result_type, const volatile void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_28)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_28)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_28)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_28)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_28)>>>>>::arg0_type, const volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(fn_28)>::arg_type<0>, const volatile void * const &&>);
static_assert(callable_traits<std::add_const_t<decltype(fn_28)>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_28)>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_28)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_28)>>::is_variadic == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_28)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_28)>>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_28)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_28)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_28)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_28)>>>>> == false);
void * volatile && fn_29(void * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_29)>>>>::result_type, void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_29)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_29)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_29)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_29)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_29)>>>::arg0_type, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_29)>>>>::arg_type<0>, void * volatile &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_29)>>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_29)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_29)>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_29)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_29)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_29)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_29)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_29)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_29)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_29)>>>>> == false);
const void * volatile && fn_30(const void * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_30)>>>>::result_type, const void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_30)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_30)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_30)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_30)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_30)>>>>>::arg0_type, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_30)>>>>>::arg_type<0>, const void * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_30)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_30)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_30)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_30)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_30)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_30)>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_30)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_30)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_30)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_30)>>>> == false);
volatile void * volatile && fn_31(volatile void * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_31)>>>>::result_type, volatile void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_31)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_31)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_31)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_31)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_31)>>>>>::arg0_type, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_31)>>>>>::arg_type<0>, volatile void * volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_31)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_31)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_31)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_31)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_31)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_31)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_31)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_31)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(fn_31)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<decltype(fn_31)>>> == false);
const volatile void * volatile && fn_32(const volatile void * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_32)>>::result_type, const volatile void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<decltype(fn_32)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<decltype(fn_32)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_32)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_32)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_32)>>>::arg0_type, const volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_32)>>>::arg_type<0>, const volatile void * volatile &&>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_32)>>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_32)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_32)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_32)>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_32)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_32)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_32)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_32)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_32)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_32)>>>>> == false);
void * const volatile && fn_33(void * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_33)>>>>::result_type, void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_33)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_33)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_33)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_33)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_33)>>>::arg0_type, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_33)>>>>::arg_type<0>, void * const volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_33)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_33)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_33)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_33)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_33)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_33)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_33)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_33)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_33)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_33)>>>>>> == false);
const void * const volatile && fn_34(const void * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_34)>>>>::result_type, const void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_34)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_34)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_34)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_34)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_34)>>>::arg0_type, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_34)>>>::arg_type<0>, const void * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_34)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_34)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_34)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_34)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_34)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_34)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_34)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_34)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_34)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_34)>>>>> == false);
volatile void * const volatile && fn_35(volatile void * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_35)>>>>>::result_type, volatile void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_35)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_35)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_35)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_35)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_35)>>>>>::arg0_type, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_35)>>>>>::arg_type<0>, volatile void * const volatile &&>);
static_assert(callable_traits<decltype(fn_35)>::arity == 1);
static_assert(callable_traits<std::add_const_t<decltype(fn_35)>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_35)>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_35)>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_35)>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_35)>>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_35)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_35)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_35)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_35)>>>>> == false);
const volatile void * const volatile && fn_36(const volatile void * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_36)>>>>::result_type, const volatile void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_36)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_36)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_36)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_36)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_36)>>>>::arg0_type, const volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_36)>>>::arg_type<0>, const volatile void * const volatile &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_36)>>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_36)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_36)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_36)>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_36)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_36)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_36)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_36)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_36)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_36)>>>>> == false);
bool fn_37(bool, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_37)>>>>::result_type, bool>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_37)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_37)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_37)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_37)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_37)>>>>::arg0_type, bool>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_37)>>>>>::arg_type<0>, bool>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_37)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_37)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_37)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_37)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_37)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_37)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_37)>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_37)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_37)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_37)>>>> == false);
bool * fn_38(bool *);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_38)>>>::result_type, bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_38)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_38)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_38)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_38)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_38)>>>>>::arg0_type, bool *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_38)>>>>>::arg_type<0>, bool *>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_38)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_38)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_38)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_38)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_38)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_38)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_38)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_38)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_38)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(fn_38)>> == false);
const bool * fn_39(const bool *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_39)>>::result_type, const bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<decltype(fn_39)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<decltype(fn_39)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<decltype(fn_39)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_39)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_39)>>>::arg0_type, const bool *>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_39)>>>::arg_type<0>, const bool *>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_39)>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_39)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_39)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_39)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_39)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_39)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_39)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_39)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_39)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_39)>>>>> == false);
volatile bool * fn_40(volatile bool *);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_40)>>>>::result_type, volatile bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_40)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_40)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_40)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_40)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_40)>>>::arg0_type, volatile bool *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_40)>>>::arg_type<0>, volatile bool *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_40)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_40)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_40)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_40)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_40)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_40)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_40)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_40)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_40)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_40)>>>>>> == false);
const volatile bool * fn_41(const volatile bool *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_41)>>>>>::result_type, const volatile bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_41)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_41)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_41)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_41)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_41)>>::arg0_type, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_41)>>>::arg_type<0>, const volatile bool *>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_41)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_41)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_41)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_41)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_41)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_41)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_41)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_41)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_41)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_41)>>>>>> == false);
bool & fn_42(bool &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_42)>>>>::result_type, bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_42)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_42)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_42)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_42)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_42)>>>>>::arg0_type, bool &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_42)>>>>>::arg_type<0>, bool &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_42)>>>>>::arity == 1);
static_assert(callable_traits<decltype(fn_42)>::is_functor == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_42)>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_42)>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_42)>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_42)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_42)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_42)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_42)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_42)>>>> == false);
const bool & fn_43(const bool &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_43)>>>>::result_type, const bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_43)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_43)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_43)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_43)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_43)>>>>::arg0_type, const bool &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_43)>>>>::arg_type<0>, const bool &>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_43)>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_43)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_43)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_43)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_43)>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_43)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_43)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_43)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_43)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_43)>>>>> == false);
volatile bool & fn_44(volatile bool &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_44)>>>>::result_type, volatile bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_44)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_44)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_44)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_44)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_44)>>>>>::arg0_type, volatile bool &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_44)>>>>::arg_type<0>, volatile bool &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_44)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_44)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_44)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_44)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_44)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_44)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_44)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_44)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_44)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_44)>>>> == false);
const volatile bool & fn_45(const volatile bool &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_45)>>>::result_type, const volatile bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_45)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_45)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_45)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_45)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_45)>>>>::arg0_type, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_45)>>>>>::arg_type<0>, const volatile bool &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_45)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_45)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_45)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_45)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_45)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_45)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_45)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_45)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_45)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_45)>>>>>> == false);
bool * & fn_46(bool * &);
static_assert(std::is_same_v<callable_traits<decltype(fn_46)>::result_type, bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<decltype(fn_46)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<decltype(fn_46)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<decltype(fn_46)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<decltype(fn_46)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_46)>>>::arg0_type, bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_46)>>>::arg_type<0>, bool * &>);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_46)>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_46)>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_46)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_46)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_46)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_46)>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_46)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_46)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_46)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_46)>>>> == false);
const bool * & fn_47(const bool * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_47)>>>>::result_type, const bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_47)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_47)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_47)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_47)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_47)>>>::arg0_type, const bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_47)>>>::arg_type<0>, const bool * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_47)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_47)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_47)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_47)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_47)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_47)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_47)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_47)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_47)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_47)>>>>>> == false);
volatile bool * & fn_48(volatile bool * &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_48)>>>>>::result_type, volatile bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_48)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_48)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_48)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_48)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_48)>>>>>::arg0_type, volatile bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_48)>>::arg_type<0>, volatile bool * &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_48)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_48)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_48)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_48)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_48)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_48)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_48)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_48)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_48)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_48)>>>>>> == false);
const volatile bool * & fn_49(const volatile bool * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_49)>>>>>::result_type, const volatile bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_49)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_49)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_49)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_49)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_49)>>>>::arg0_type, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_49)>>>>>::arg_type<0>, const volatile bool * &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_49)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_49)>>>>>::is_functor == false);
static_assert(callable_traits<decltype(fn_49)>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_49)>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_49)>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<decltype(fn_49)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_49)>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_49)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_49)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_49)>>>> == false);
bool * const & fn_50(bool * const &);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_50)>>>::result_type, bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_50)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_50)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_50)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_50)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_50)>>>>::arg0_type, bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_50)>>>>::arg_type<0>, bool * const &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_50)>>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_50)>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_50)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_50)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_50)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_50)>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_50)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_50)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_50)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_50)>>>> == false);
const bool * const & fn_51(const bool * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_51)>>>>::result_type, const bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_51)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_51)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_51)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_51)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_51)>>>>>::arg0_type, const bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_51)>>>>>::arg_type<0>, const bool * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_51)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_51)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_51)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_51)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_51)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_51)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_51)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_51)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_51)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_51)>>>> == false);
volatile bool * const & fn_52(volatile bool * const &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_52)>>>::result_type, volatile bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_52)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_52)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_52)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_52)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_52)>>>>::arg0_type, volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_52)>>>>::arg_type<0>, volatile bool * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_52)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_52)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_52)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_52)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_52)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_52)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_52)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_52)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_52)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_52)>>>>>> == false);
const volatile bool * const & fn_53(const volatile bool * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_53)>>>>>::result_type, const volatile bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(fn_53)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<decltype(fn_53)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<decltype(fn_53)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<decltype(fn_53)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_53)>>::arg0_type, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_53)>>>::arg_type<0>, const volatile bool * const &>);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_53)>>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_53)>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_53)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_53)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_53)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_53)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_53)>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_53)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_53)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_53)>>>>> == false);
bool * volatile & fn_54(bool * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_54)>>>::result_type, bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_54)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_54)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_54)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_54)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_54)>>>::arg0_type, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_54)>>>::arg_type<0>, bool * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_54)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_54)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_54)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_54)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_54)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_54)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_54)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_54)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_54)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_54)>>>>> == false);
const bool * volatile & fn_55(const bool * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_55)>>>>>::result_type, const bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_55)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_55)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_55)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_55)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_55)>>>>>::arg0_type, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_55)>>>>>::arg_type<0>, const bool * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_55)>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_55)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_55)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_55)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_55)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_55)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_55)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_55)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_55)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_55)>>>>>> == false);
volatile bool * volatile & fn_56(volatile bool * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_56)>>>>>::result_type, volatile bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_56)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_56)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_56)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_56)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_56)>>>>>::arg0_type, volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_56)>>>>::arg_type<0>, volatile bool * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_56)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_56)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_56)>>>>>::is_member_function == false);
static_assert(callable_traits<decltype(fn_56)>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_56)>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_56)>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_56)>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_56)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_56)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_56)>>>> == false);
const volatile bool * volatile & fn_57(const volatile bool * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_57)>>>::result_type, const volatile bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_57)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_57)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_57)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_57)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_57)>>>::arg0_type, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_57)>>>>::arg_type<0>, const volatile bool * volatile &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_57)>>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_57)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_57)>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_57)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_57)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_57)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_57)>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_57)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_57)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_57)>>>> == false);
bool * const volatile & fn_58(bool * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_58)>>>::result_type, bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_58)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_58)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_58)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_58)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_58)>>>>>::arg0_type, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_58)>>>>>::arg_type<0>, bool * const volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_58)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_58)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_58)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_58)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_58)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_58)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_58)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_58)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_58)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_58)>>> == false);
const bool * const volatile & fn_59(const bool * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_59)>>>::result_type, const bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_59)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_59)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_59)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_59)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_59)>>>>::arg0_type, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_59)>>>>::arg_type<0>, const bool * const volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_59)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_59)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_59)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_59)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_59)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_59)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_59)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_59)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_59)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_59)>>>>>> == false);
volatile bool * const volatile & fn_60(volatile bool * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_60)>>>>>::result_type, volatile bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_60)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(fn_60)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<decltype(fn_60)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<decltype(fn_60)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_60)>>::arg0_type, volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_60)>>::arg_type<0>, volatile bool * const volatile &>);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_60)>>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_60)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_60)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_60)>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_60)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_60)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_60)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_60)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_60)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_60)>>>>> == false);
const volatile bool * const volatile & fn_61(const volatile bool * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_61)>>>>::result_type, const volatile bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_61)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_61)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_61)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_61)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_61)>>::arg0_type, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_61)>>>::arg_type<0>, const volatile bool * const volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_61)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_61)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_61)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_61)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_61)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_61)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_61)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_61)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_61)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_61)>>>>>> == false);
bool && fn_62(bool &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_62)>>>>::result_type, bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_62)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_62)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_62)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_62)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_62)>>>>>::arg0_type, bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_62)>>>>>::arg_type<0>, bool &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_62)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_62)>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_62)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_62)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_62)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_62)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_62)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_62)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_62)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_62)>>>>> == false);
const bool && fn_63(const bool &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_63)>>>>>::result_type, const bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_63)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_63)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_63)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_63)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_63)>>>>>::arg0_type, const bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_63)>>>>>::arg_type<0>, const bool &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_63)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_63)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_63)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_63)>>>>>::is_variadic == true);
static_assert(callable_traits<decltype(fn_63)>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<decltype(fn_63)>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_63)>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_63)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_63)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_63)>>>> == false);
volatile bool && fn_64(volatile bool &&);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_64)>>>::result_type, volatile bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_64)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_64)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_64)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_64)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_64)>>>>::arg0_type, volatile bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_64)>>>::arg_type<0>, volatile bool &&>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_64)>>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_64)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_64)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_64)>>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_64)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_64)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_64)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_64)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_64)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_64)>>>> == false);
const volatile bool && fn_65(const volatile bool &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_65)>>>::result_type, const volatile bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_65)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_65)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_65)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_65)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_65)>>>>::arg0_type, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_65)>>>>>::arg_type<0>, const volatile bool &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_65)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_65)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_65)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_65)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_65)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_65)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_65)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_65)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_65)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_65)>>>>>> == false);
bool * && fn_66(bool * &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_66)>>::result_type, bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_66)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_66)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_66)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_66)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_66)>>>>::arg0_type, bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_66)>>>>::arg_type<0>, bool * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_66)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_66)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_66)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_66)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_66)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_66)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_66)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_66)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_66)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_66)>>>>> == false);
const bool * && fn_67(const bool * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_67)>>>>>::result_type, const bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_67)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_67)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(fn_67)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<decltype(fn_67)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_67)>>::arg0_type, const bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_67)>>::arg_type<0>, const bool * &&>);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_67)>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_67)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_67)>>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_67)>>>::is_variadic == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_67)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_67)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_67)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_67)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_67)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_67)>>>>> == false);
volatile bool * && fn_68(volatile bool * &&);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_68)>>>>::result_type, volatile bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_68)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_68)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_68)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_68)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_68)>>>>::arg0_type, volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_68)>>::arg_type<0>, volatile bool * &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_68)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_68)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_68)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_68)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_68)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_68)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_68)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_68)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_68)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_68)>>>>>> == false);
const volatile bool * && fn_69(const volatile bool * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_69)>>>>>::result_type, const volatile bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_69)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_69)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_69)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_69)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_69)>>>>::arg0_type, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_69)>>>>>::arg_type<0>, const volatile bool * &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_69)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_69)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_69)>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_69)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_69)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_69)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_69)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_69)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_69)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_69)>>>>> == false);
bool * const && fn_70(bool * const &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_70)>>>>::result_type, bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_70)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_70)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_70)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_70)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_70)>>>>>::arg0_type, bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_70)>>>>>::arg_type<0>, bool * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_70)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_70)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_70)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_70)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_70)>>>>>::is_noexcept == false);
static_assert(callable_traits<decltype(fn_70)>::is_const == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_70)>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_70)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_70)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<decltype(fn_70)>>> == false);
const bool * const && fn_71(const bool * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_71)>>>::result_type, const bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_71)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_71)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_71)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_71)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_71)>>>>::arg0_type, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_71)>>>>::arg_type<0>, const bool * const &&>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_71)>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_71)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_71)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_71)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_71)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_71)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_71)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_71)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_71)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_71)>>>> == false);
volatile bool * const && fn_72(volatile bool * const &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_72)>>>::result_type, volatile bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_72)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_72)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_72)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_72)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_72)>>>>::arg0_type, volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_72)>>>>::arg_type<0>, volatile bool * const &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_72)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_72)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_72)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_72)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_72)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_72)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_72)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_72)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_72)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_72)>>>>>> == false);
const volatile bool * const && fn_73(const volatile bool * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_73)>>>>>::result_type, const volatile bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_73)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_73)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_73)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_73)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_73)>>>::arg0_type, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_73)>>>>::arg_type<0>, const volatile bool * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_73)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_73)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_73)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_73)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_73)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_73)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_73)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_73)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_73)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_73)>>>>>> == false);
bool * volatile && fn_74(bool * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_74)>>>>::result_type, bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_74)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_74)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_74)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(fn_74)>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_74)>>::arg0_type, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_74)>>::arg_type<0>, bool * volatile &&>);
static_assert(callable_traits<std::add_cv_t<decltype(fn_74)>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_74)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_74)>>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_74)>>>::is_variadic == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_74)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_74)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_74)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_74)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_74)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_74)>>>> == false);
const bool * volatile && fn_75(const bool * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_75)>>>>::result_type, const bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_75)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_75)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_75)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_75)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_75)>>>>::arg0_type, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_75)>>>>::arg_type<0>, const bool * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_75)>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_75)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_75)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_75)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_75)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_75)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_75)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_75)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_75)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_75)>>>>>> == false);
volatile bool * volatile && fn_76(volatile bool * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_76)>>>>>::result_type, volatile bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_76)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_76)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_76)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_76)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_76)>>>>>::arg0_type, volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_76)>>>>::arg_type<0>, volatile bool * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_76)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_76)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_76)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_76)>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_76)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_76)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_76)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_76)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_76)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_76)>>>>> == false);
const volatile bool * volatile && fn_77(const volatile bool * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_77)>>>>::result_type, const volatile bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_77)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_77)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_77)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_77)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_77)>>>>::arg0_type, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_77)>>>>>::arg_type<0>, const volatile bool * volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_77)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_77)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_77)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_77)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_77)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_77)>>>>>::is_const == false);
static_assert(callable_traits<decltype(fn_77)>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_77)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_77)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<decltype(fn_77)>>> == false);
bool * const volatile && fn_78(bool * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_78)>>::result_type, bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_78)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_78)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_78)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_78)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_78)>>>>::arg0_type, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_78)>>>>::arg_type<0>, bool * const volatile &&>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_78)>>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_78)>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_78)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_78)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_78)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_78)>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_78)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_78)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_78)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_78)>>> == false);
const bool * const volatile && fn_79(const bool * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_79)>>>::result_type, const bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_79)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_79)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_79)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_79)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_79)>>>>::arg0_type, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_79)>>>>::arg_type<0>, const bool * const volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_79)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_79)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_79)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_79)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_79)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_79)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_79)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_79)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_79)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_79)>>>>>> == false);
volatile bool * const volatile && fn_80(volatile bool * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_80)>>>>>::result_type, volatile bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_80)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_80)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_80)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_80)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_80)>>>::arg0_type, volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_80)>>>::arg_type<0>, volatile bool * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_80)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_80)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_80)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_80)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_80)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_80)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_80)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_80)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_80)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_80)>>>>>> == false);
const volatile bool * const volatile && fn_81(const volatile bool * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_81)>>>>>::result_type, const volatile bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_81)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_81)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_81)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_81)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<decltype(fn_81)>::arg0_type, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_81)>>::arg_type<0>, const volatile bool * const volatile &&>);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_81)>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<decltype(fn_81)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_81)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_81)>>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_81)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_81)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_81)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_81)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_81)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_81)>>>>> == false);
int fn_82(int);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_82)>>>::result_type, int>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_82)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_82)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_82)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_82)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_82)>>>>::arg0_type, int>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_82)>>>>::arg_type<0>, int>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_82)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_82)>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_82)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_82)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_82)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_82)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_82)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_82)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_82)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_82)>>>>> == false);
int * fn_83(int *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_83)>>>>>::result_type, int *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_83)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_83)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_83)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_83)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_83)>>>>>::arg0_type, int *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_83)>>>>>::arg_type<0>, int *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_83)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_83)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_83)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_83)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_83)>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_83)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_83)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_83)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_83)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_83)>>>>> == false);
const int * fn_84(const int *);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_84)>>>>::result_type, const int *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_84)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_84)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_84)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_84)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_84)>>>>>::arg0_type, const int *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_84)>>>>::arg_type<0>, const int *>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_84)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_84)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_84)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_84)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_84)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_84)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_84)>>>>>::is_volatile == false);
static_assert(callable_traits<decltype(fn_84)>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_84)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<decltype(fn_84)>>> == false);
volatile int * fn_85(volatile int *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_85)>>::result_type, volatile int *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<decltype(fn_85)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_85)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_85)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_85)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_85)>>>::arg0_type, volatile int *>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_85)>>>>::arg_type<0>, volatile int *>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_85)>>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_85)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_85)>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_85)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_85)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_85)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_85)>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_85)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_85)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_85)>>>>> == false);
const volatile int * fn_86(const volatile int *);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_86)>>::result_type, const volatile int *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_86)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_86)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_86)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_86)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_86)>>>>::arg0_type, const volatile int *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_86)>>>>::arg_type<0>, const volatile int *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_86)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_86)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_86)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_86)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_86)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_86)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_86)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_86)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_86)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_86)>>>>> == false);
int & fn_87(int &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_87)>>>>>::result_type, int &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_87)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_87)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_87)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_87)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_87)>>>::arg0_type, int &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_87)>>>::arg_type<0>, int &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_87)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_87)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_87)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_87)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_87)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_87)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_87)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_87)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_87)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_87)>>>>>> == false);
const int & fn_88(const int &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_88)>>>>>::result_type, const int &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_88)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_88)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_88)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_88)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_88)>>>>>::arg0_type, const int &>);
static_assert(std::is_same_v<callable_traits<decltype(fn_88)>::arg_type<0>, const int &>);
static_assert(callable_traits<std::add_const_t<decltype(fn_88)>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_88)>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_88)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_88)>>::is_variadic == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_88)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_88)>>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_88)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_88)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_88)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_88)>>>>> == false);
volatile int & fn_89(volatile int &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_89)>>>>::result_type, volatile int &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_89)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_89)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_89)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_89)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_89)>>>::arg0_type, volatile int &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_89)>>>>::arg_type<0>, volatile int &>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_89)>>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_89)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_89)>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_89)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_89)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_89)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_89)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_89)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_89)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_89)>>>>> == false);
const volatile int & fn_90(const volatile int &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_90)>>>>::result_type, const volatile int &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_90)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_90)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_90)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_90)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_90)>>>>>::arg0_type, const volatile int &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_90)>>>>>::arg_type<0>, const volatile int &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_90)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_90)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_90)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_90)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_90)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_90)>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_90)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_90)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_90)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_90)>>>> == false);
int * & fn_91(int * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_91)>>>>::result_type, int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_91)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_91)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_91)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_91)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_91)>>>>>::arg0_type, int * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_91)>>>>>::arg_type<0>, int * &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_91)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_91)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_91)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_91)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_91)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_91)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_91)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_91)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(fn_91)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<decltype(fn_91)>>> == false);
const int * & fn_92(const int * &);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_92)>>::result_type, const int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<decltype(fn_92)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<decltype(fn_92)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_92)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_92)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_92)>>>::arg0_type, const int * &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_92)>>>::arg_type<0>, const int * &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_92)>>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_92)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_92)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_92)>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_92)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_92)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_92)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_92)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_92)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_92)>>>>> == false);
volatile int * & fn_93(volatile int * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_93)>>>>::result_type, volatile int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_93)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_93)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_93)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_93)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_93)>>>::arg0_type, volatile int * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_93)>>>>::arg_type<0>, volatile int * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_93)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_93)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_93)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_93)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_93)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_93)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_93)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_93)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_93)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_93)>>>>>> == false);
const volatile int * & fn_94(const volatile int * &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_94)>>>>::result_type, const volatile int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_94)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_94)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_94)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_94)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_94)>>>::arg0_type, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_94)>>>::arg_type<0>, const volatile int * &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_94)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_94)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_94)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_94)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_94)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_94)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_94)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_94)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_94)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_94)>>>>> == false);
int * const & fn_95(int * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_95)>>>>>::result_type, int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_95)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_95)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_95)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_95)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_95)>>>>>::arg0_type, int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_95)>>>>>::arg_type<0>, int * const &>);
static_assert(callable_traits<decltype(fn_95)>::arity == 1);
static_assert(callable_traits<std::add_const_t<decltype(fn_95)>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_95)>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_95)>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_95)>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_95)>>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_95)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_95)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_95)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_95)>>>>> == false);
const int * const & fn_96(const int * const &);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_96)>>>>::result_type, const int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_96)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_96)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_96)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_96)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_96)>>>>::arg0_type, const int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_96)>>>::arg_type<0>, const int * const &>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_96)>>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_96)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_96)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_96)>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_96)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_96)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_96)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_96)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_96)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_96)>>>>> == false);
volatile int * const & fn_97(volatile int * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_97)>>>>::result_type, volatile int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_97)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_97)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_97)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_97)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_97)>>>>::arg0_type, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_97)>>>>>::arg_type<0>, volatile int * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_97)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_97)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_97)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_97)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_97)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_97)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_97)>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_97)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_97)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_97)>>>> == false);
const volatile int * const & fn_98(const volatile int * const &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_98)>>>::result_type, const volatile int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_98)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_98)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_98)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_98)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_98)>>>>>::arg0_type, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_98)>>>>>::arg_type<0>, const volatile int * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_98)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_98)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_98)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_98)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_98)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_98)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_98)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_98)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_98)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(fn_98)>> == false);
int * volatile & fn_99(int * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_99)>>::result_type, int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<decltype(fn_99)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<decltype(fn_99)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<decltype(fn_99)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_99)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_99)>>>::arg0_type, int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_99)>>>::arg_type<0>, int * volatile &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_99)>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_99)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_99)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_99)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_99)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_99)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_99)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_99)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_99)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_99)>>>>> == false);
const int * volatile & fn_100(const int * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_100)>>>>::result_type, const int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_100)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_100)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_100)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_100)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_100)>>>::arg0_type, const int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_100)>>>::arg_type<0>, const int * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_100)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_100)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_100)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_100)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_100)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_100)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_100)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_100)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_100)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_100)>>>>>> == false);
volatile int * volatile & fn_101(volatile int * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_101)>>>>>::result_type, volatile int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_101)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_101)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_101)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_101)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_101)>>::arg0_type, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_101)>>>::arg_type<0>, volatile int * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_101)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_101)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_101)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_101)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_101)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_101)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_101)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_101)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_101)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_101)>>>>>> == false);
const volatile int * volatile & fn_102(const volatile int * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_102)>>>>::result_type, const volatile int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_102)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_102)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_102)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_102)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_102)>>>>>::arg0_type, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_102)>>>>>::arg_type<0>, const volatile int * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_102)>>>>>::arity == 1);
static_assert(callable_traits<decltype(fn_102)>::is_functor == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_102)>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_102)>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_102)>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_102)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_102)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_102)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_102)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_102)>>>> == false);
int * const volatile & fn_103(int * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_103)>>>>::result_type, int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_103)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_103)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_103)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_103)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_103)>>>>::arg0_type, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_103)>>>>::arg_type<0>, int * const volatile &>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_103)>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_103)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_103)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_103)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_103)>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_103)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_103)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_103)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_103)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_103)>>>>> == false);
const int * const volatile & fn_104(const int * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_104)>>>>::result_type, const int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_104)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_104)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_104)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_104)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_104)>>>>>::arg0_type, const int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_104)>>>>::arg_type<0>, const int * const volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_104)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_104)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_104)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_104)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_104)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_104)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_104)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_104)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_104)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_104)>>>> == false);
volatile int * const volatile & fn_105(volatile int * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_105)>>>::result_type, volatile int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_105)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_105)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_105)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_105)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_105)>>>>::arg0_type, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_105)>>>>>::arg_type<0>, volatile int * const volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_105)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_105)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_105)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_105)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_105)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_105)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_105)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_105)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_105)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_105)>>>>>> == false);
const volatile int * const volatile & fn_106(const volatile int * const volatile &);
static_assert(std::is_same_v<callable_traits<decltype(fn_106)>::result_type, const volatile int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<decltype(fn_106)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<decltype(fn_106)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<decltype(fn_106)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<decltype(fn_106)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_106)>>>::arg0_type, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_106)>>>::arg_type<0>, const volatile int * const volatile &>);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_106)>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_106)>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_106)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_106)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_106)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_106)>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_106)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_106)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_106)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_106)>>>> == false);
int && fn_107(int &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_107)>>>>::result_type, int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_107)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_107)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_107)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_107)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_107)>>>::arg0_type, int &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_107)>>>::arg_type<0>, int &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_107)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_107)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_107)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_107)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_107)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_107)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_107)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_107)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_107)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_107)>>>>>> == false);
const int && fn_108(const int &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_108)>>>>>::result_type, const int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_108)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_108)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_108)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_108)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_108)>>>>>::arg0_type, const int &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_108)>>::arg_type<0>, const int &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_108)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_108)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_108)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_108)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_108)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_108)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_108)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_108)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_108)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_108)>>>>>> == false);
volatile int && fn_109(volatile int &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_109)>>>>>::result_type, volatile int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_109)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_109)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_109)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_109)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_109)>>>>::arg0_type, volatile int &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_109)>>>>>::arg_type<0>, volatile int &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_109)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_109)>>>>>::is_functor == false);
static_assert(callable_traits<decltype(fn_109)>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_109)>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_109)>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<decltype(fn_109)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_109)>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_109)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_109)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_109)>>>> == false);
const volatile int && fn_110(const volatile int &&);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_110)>>>::result_type, const volatile int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_110)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_110)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_110)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_110)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_110)>>>>::arg0_type, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_110)>>>>::arg_type<0>, const volatile int &&>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_110)>>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_110)>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_110)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_110)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_110)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_110)>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_110)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_110)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_110)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_110)>>>> == false);
int * && fn_111(int * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_111)>>>>::result_type, int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_111)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_111)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_111)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_111)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_111)>>>>>::arg0_type, int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_111)>>>>>::arg_type<0>, int * &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_111)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_111)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_111)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_111)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_111)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_111)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_111)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_111)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_111)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_111)>>>> == false);
const int * && fn_112(const int * &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_112)>>>::result_type, const int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_112)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_112)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_112)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_112)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_112)>>>>::arg0_type, const int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_112)>>>>::arg_type<0>, const int * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_112)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_112)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_112)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_112)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_112)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_112)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_112)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_112)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_112)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_112)>>>>>> == false);
volatile int * && fn_113(volatile int * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_113)>>>>>::result_type, volatile int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(fn_113)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<decltype(fn_113)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<decltype(fn_113)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<decltype(fn_113)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_113)>>::arg0_type, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_113)>>>::arg_type<0>, volatile int * &&>);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_113)>>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_113)>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_113)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_113)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_113)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_113)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_113)>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_113)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_113)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_113)>>>>> == false);
const volatile int * && fn_114(const volatile int * &&);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_114)>>>::result_type, const volatile int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_114)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_114)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_114)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_114)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_114)>>>::arg0_type, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_114)>>>::arg_type<0>, const volatile int * &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_114)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_114)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_114)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_114)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_114)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_114)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_114)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_114)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_114)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_114)>>>>> == false);
int * const && fn_115(int * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_115)>>>>>::result_type, int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_115)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_115)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_115)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_115)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_115)>>>>>::arg0_type, int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_115)>>>>>::arg_type<0>, int * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_115)>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_115)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_115)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_115)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_115)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_115)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_115)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_115)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_115)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_115)>>>>>> == false);
const int * const && fn_116(const int * const &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_116)>>>>>::result_type, const int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_116)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_116)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_116)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_116)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_116)>>>>>::arg0_type, const int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_116)>>>>::arg_type<0>, const int * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_116)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_116)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_116)>>>>>::is_member_function == false);
static_assert(callable_traits<decltype(fn_116)>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_116)>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_116)>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_116)>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_116)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_116)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_116)>>>> == false);
volatile int * const && fn_117(volatile int * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_117)>>>::result_type, volatile int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_117)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_117)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_117)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_117)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_117)>>>::arg0_type, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_117)>>>>::arg_type<0>, volatile int * const &&>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_117)>>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_117)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_117)>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_117)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_117)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_117)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_117)>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_117)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_117)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_117)>>>> == false);
const volatile int * const && fn_118(const volatile int * const &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_118)>>>::result_type, const volatile int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_118)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_118)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_118)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_118)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_118)>>>>>::arg0_type, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_118)>>>>>::arg_type<0>, const volatile int * const &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_118)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_118)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_118)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_118)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_118)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_118)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_118)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_118)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_118)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_118)>>> == false);
int * volatile && fn_119(int * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_119)>>>::result_type, int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_119)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_119)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_119)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_119)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_119)>>>>::arg0_type, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_119)>>>>::arg_type<0>, int * volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_119)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_119)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_119)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_119)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_119)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_119)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_119)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_119)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_119)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_119)>>>>>> == false);
const int * volatile && fn_120(const int * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_120)>>>>>::result_type, const int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_120)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(fn_120)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<decltype(fn_120)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<decltype(fn_120)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_120)>>::arg0_type, const int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_120)>>::arg_type<0>, const int * volatile &&>);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_120)>>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_120)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_120)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_120)>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_120)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_120)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_120)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_120)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_120)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_120)>>>>> == false);
volatile int * volatile && fn_121(volatile int * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_121)>>>>::result_type, volatile int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_121)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_121)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_121)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_121)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_121)>>::arg0_type, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_121)>>>::arg_type<0>, volatile int * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_121)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_121)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_121)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_121)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_121)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_121)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_121)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_121)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_121)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_121)>>>>>> == false);
const volatile int * volatile && fn_122(const volatile int * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_122)>>>>::result_type, const volatile int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_122)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_122)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_122)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_122)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_122)>>>>>::arg0_type, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_122)>>>>>::arg_type<0>, const volatile int * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_122)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_122)>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_122)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_122)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_122)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_122)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_122)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_122)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_122)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_122)>>>>> == false);
int * const volatile && fn_123(int * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_123)>>>>>::result_type, int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_123)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_123)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_123)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_123)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_123)>>>>>::arg0_type, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_123)>>>>>::arg_type<0>, int * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_123)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_123)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_123)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_123)>>>>>::is_variadic == true);
static_assert(callable_traits<decltype(fn_123)>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<decltype(fn_123)>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_123)>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_123)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_123)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_123)>>>> == false);
const int * const volatile && fn_124(const int * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_124)>>>::result_type, const int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_124)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_124)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_124)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_124)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_124)>>>>::arg0_type, const int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_124)>>>::arg_type<0>, const int * const volatile &&>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_124)>>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_124)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_124)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_124)>>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_124)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_124)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_124)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_124)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_124)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_124)>>>> == false);
volatile int * const volatile && fn_125(volatile int * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_125)>>>::result_type, volatile int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_125)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_125)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_125)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_125)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_125)>>>>::arg0_type, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_125)>>>>>::arg_type<0>, volatile int * const volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_125)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_125)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_125)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_125)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_125)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_125)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_125)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_125)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_125)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_125)>>>>>> == false);
const volatile int * const volatile && fn_126(const volatile int * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_126)>>::result_type, const volatile int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_126)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_126)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_126)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_126)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_126)>>>>::arg0_type, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_126)>>>>::arg_type<0>, const volatile int * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_126)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_126)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_126)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_126)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_126)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_126)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_126)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_126)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_126)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_126)>>>>> == false);
float fn_127(float, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_127)>>>>>::result_type, float>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_127)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_127)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(fn_127)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<decltype(fn_127)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_127)>>::arg0_type, float>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_127)>>::arg_type<0>, float>);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_127)>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_127)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_127)>>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_127)>>>::is_variadic == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_127)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_127)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_127)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_127)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_127)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_127)>>>>> == false);
float * fn_128(float *);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_128)>>>>::result_type, float *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_128)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_128)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_128)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_128)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_128)>>>>::arg0_type, float *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_128)>>::arg_type<0>, float *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_128)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_128)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_128)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_128)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_128)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_128)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_128)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_128)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_128)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_128)>>>>>> == false);
const float * fn_129(const float *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_129)>>>>>::result_type, const float *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_129)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_129)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_129)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_129)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_129)>>>>::arg0_type, const float *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_129)>>>>>::arg_type<0>, const float *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_129)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_129)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_129)>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_129)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_129)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_129)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_129)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_129)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_129)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_129)>>>>> == false);
volatile float * fn_130(volatile float *);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_130)>>>>::result_type, volatile float *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_130)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_130)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_130)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_130)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_130)>>>>>::arg0_type, volatile float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_130)>>>>>::arg_type<0>, volatile float *>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_130)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_130)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_130)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_130)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_130)>>>>>::is_noexcept == false);
static_assert(callable_traits<decltype(fn_130)>::is_const == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_130)>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_130)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_130)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<decltype(fn_130)>>> == false);
const volatile float * fn_131(const volatile float *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_131)>>>::result_type, const volatile float *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_131)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_131)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_131)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_131)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_131)>>>>::arg0_type, const volatile float *>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_131)>>>>::arg_type<0>, const volatile float *>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_131)>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_131)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_131)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_131)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_131)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_131)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_131)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_131)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_131)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_131)>>>> == false);
float & fn_132(float &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_132)>>>::result_type, float &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_132)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_132)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_132)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_132)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_132)>>>>::arg0_type, float &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_132)>>>>::arg_type<0>, float &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_132)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_132)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_132)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_132)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_132)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_132)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_132)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_132)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_132)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_132)>>>>>> == false);
const float & fn_133(const float &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_133)>>>>>::result_type, const float &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_133)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_133)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_133)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_133)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_133)>>>::arg0_type, const float &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_133)>>>>::arg_type<0>, const float &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_133)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_133)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_133)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_133)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_133)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_133)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_133)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_133)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_133)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_133)>>>>>> == false);
volatile float & fn_134(volatile float &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_134)>>>>::result_type, volatile float &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_134)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_134)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_134)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(fn_134)>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_134)>>::arg0_type, volatile float &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_134)>>::arg_type<0>, volatile float &>);
static_assert(callable_traits<std::add_cv_t<decltype(fn_134)>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_134)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_134)>>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_134)>>>::is_variadic == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_134)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_134)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_134)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_134)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_134)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_134)>>>> == false);
const volatile float & fn_135(const volatile float &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_135)>>>>::result_type, const volatile float &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_135)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_135)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_135)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_135)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_135)>>>>::arg0_type, const volatile float &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_135)>>>>::arg_type<0>, const volatile float &>);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_135)>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_135)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_135)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_135)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_135)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_135)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_135)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_135)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_135)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_135)>>>>>> == false);
float * & fn_136(float * &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_136)>>>>>::result_type, float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_136)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_136)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_136)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_136)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_136)>>>>>::arg0_type, float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_136)>>>>::arg_type<0>, float * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_136)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_136)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_136)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_136)>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_136)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_136)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_136)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_136)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_136)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_136)>>>>> == false);
const float * & fn_137(const float * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_137)>>>>::result_type, const float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_137)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_137)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_137)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_137)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_137)>>>>::arg0_type, const float * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_137)>>>>>::arg_type<0>, const float * &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_137)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_137)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_137)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_137)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_137)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_137)>>>>>::is_const == false);
static_assert(callable_traits<decltype(fn_137)>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_137)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_137)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<decltype(fn_137)>>> == false);
volatile float * & fn_138(volatile float * &);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_138)>>::result_type, volatile float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_138)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_138)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_138)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_138)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_138)>>>>::arg0_type, volatile float * &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_138)>>>>::arg_type<0>, volatile float * &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_138)>>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_138)>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_138)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_138)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_138)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_138)>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_138)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_138)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_138)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_138)>>> == false);
const volatile float * & fn_139(const volatile float * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_139)>>>::result_type, const volatile float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_139)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_139)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_139)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_139)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_139)>>>>::arg0_type, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_139)>>>>::arg_type<0>, const volatile float * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_139)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_139)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_139)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_139)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_139)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_139)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_139)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_139)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_139)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_139)>>>>>> == false);
float * const & fn_140(float * const &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_140)>>>>>::result_type, float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_140)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_140)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_140)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_140)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_140)>>>::arg0_type, float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_140)>>>::arg_type<0>, float * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_140)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_140)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_140)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_140)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_140)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_140)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_140)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_140)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_140)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_140)>>>>>> == false);
const float * const & fn_141(const float * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_141)>>>>>::result_type, const float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_141)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_141)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_141)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_141)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<decltype(fn_141)>::arg0_type, const float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_141)>>::arg_type<0>, const float * const &>);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_141)>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<decltype(fn_141)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_141)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_141)>>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_141)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_141)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_141)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_141)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_141)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_141)>>>>> == false);
volatile float * const & fn_142(volatile float * const &);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_142)>>>::result_type, volatile float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_142)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_142)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_142)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_142)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_142)>>>>::arg0_type, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_142)>>>>::arg_type<0>, volatile float * const &>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_142)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_142)>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_142)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_142)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_142)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_142)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_142)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_142)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_142)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_142)>>>>> == false);
const volatile float * const & fn_143(const volatile float * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_143)>>>>>::result_type, const volatile float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_143)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_143)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_143)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_143)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_143)>>>>>::arg0_type, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_143)>>>>>::arg_type<0>, const volatile float * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_143)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_143)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_143)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_143)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_143)>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_143)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_143)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_143)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_143)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_143)>>>>> == false);
float * volatile & fn_144(float * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_144)>>>>::result_type, float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_144)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_144)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_144)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_144)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_144)>>>>>::arg0_type, float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_144)>>>>::arg_type<0>, float * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_144)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_144)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_144)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_144)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_144)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_144)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_144)>>>>>::is_volatile == false);
static_assert(callable_traits<decltype(fn_144)>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_144)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<decltype(fn_144)>>> == false);
const float * volatile & fn_145(const float * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_145)>>::result_type, const float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<decltype(fn_145)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_145)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_145)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_145)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_145)>>>::arg0_type, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_145)>>>>::arg_type<0>, const float * volatile &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_145)>>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_145)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_145)>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_145)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_145)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_145)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_145)>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_145)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_145)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_145)>>>>> == false);
volatile float * volatile & fn_146(volatile float * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_146)>>::result_type, volatile float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_146)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_146)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_146)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_146)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_146)>>>>::arg0_type, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_146)>>>>::arg_type<0>, volatile float * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_146)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_146)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_146)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_146)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_146)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_146)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_146)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_146)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_146)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_146)>>>>> == false);
const volatile float * volatile & fn_147(const volatile float * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_147)>>>>>::result_type, const volatile float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_147)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_147)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_147)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_147)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_147)>>>::arg0_type, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_147)>>>::arg_type<0>, const volatile float * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_147)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_147)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_147)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_147)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_147)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_147)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_147)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_147)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_147)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_147)>>>>>> == false);
float * const volatile & fn_148(float * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_148)>>>>>::result_type, float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_148)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_148)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_148)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_148)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_148)>>>>>::arg0_type, float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(fn_148)>::arg_type<0>, float * const volatile &>);
static_assert(callable_traits<std::add_const_t<decltype(fn_148)>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_148)>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_148)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_148)>>::is_variadic == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_148)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_148)>>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_148)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_148)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_148)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_148)>>>>> == false);
const float * const volatile & fn_149(const float * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_149)>>>>::result_type, const float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_149)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_149)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_149)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_149)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_149)>>>::arg0_type, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_149)>>>>::arg_type<0>, const float * const volatile &>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_149)>>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_149)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_149)>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_149)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_149)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_149)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_149)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_149)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_149)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_149)>>>>> == false);
volatile float * const volatile & fn_150(volatile float * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_150)>>>>::result_type, volatile float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_150)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_150)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_150)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_150)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_150)>>>>>::arg0_type, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_150)>>>>>::arg_type<0>, volatile float * const volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_150)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_150)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_150)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_150)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_150)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_150)>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_150)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_150)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_150)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_150)>>>> == false);
const volatile float * const volatile & fn_151(const volatile float * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_151)>>>>::result_type, const volatile float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_151)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_151)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_151)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_151)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_151)>>>>>::arg0_type, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_151)>>>>>::arg_type<0>, const volatile float * const volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_151)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_151)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_151)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_151)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_151)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_151)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_151)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_151)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(fn_151)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<decltype(fn_151)>>> == false);
float && fn_152(float &&);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_152)>>::result_type, float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<decltype(fn_152)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<decltype(fn_152)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_152)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_152)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_152)>>>::arg0_type, float &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_152)>>>::arg_type<0>, float &&>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_152)>>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_152)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_152)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_152)>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_152)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_152)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_152)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_152)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_152)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_152)>>>>> == false);
const float && fn_153(const float &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_153)>>>>::result_type, const float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_153)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_153)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_153)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_153)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_153)>>>::arg0_type, const float &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_153)>>>>::arg_type<0>, const float &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_153)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_153)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_153)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_153)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_153)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_153)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_153)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_153)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_153)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_153)>>>>>> == false);
volatile float && fn_154(volatile float &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_154)>>>>::result_type, volatile float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_154)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_154)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_154)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_154)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_154)>>>::arg0_type, volatile float &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_154)>>>::arg_type<0>, volatile float &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_154)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_154)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_154)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_154)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_154)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_154)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_154)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_154)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_154)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_154)>>>>> == false);
const volatile float && fn_155(const volatile float &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_155)>>>>>::result_type, const volatile float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_155)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_155)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_155)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_155)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_155)>>>>>::arg0_type, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_155)>>>>>::arg_type<0>, const volatile float &&>);
static_assert(callable_traits<decltype(fn_155)>::arity == 1);
static_assert(callable_traits<std::add_const_t<decltype(fn_155)>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_155)>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_155)>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_155)>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_155)>>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_155)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_155)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_155)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_155)>>>>> == false);
float * && fn_156(float * &&);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_156)>>>>::result_type, float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_156)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_156)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_156)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_156)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_156)>>>>::arg0_type, float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_156)>>>::arg_type<0>, float * &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_156)>>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_156)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_156)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_156)>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_156)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_156)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_156)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_156)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_156)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_156)>>>>> == false);
const float * && fn_157(const float * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_157)>>>>::result_type, const float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_157)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_157)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_157)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_157)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_157)>>>>::arg0_type, const float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_157)>>>>>::arg_type<0>, const float * &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_157)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_157)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_157)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_157)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_157)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_157)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_157)>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_157)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_157)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_157)>>>> == false);
volatile float * && fn_158(volatile float * &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_158)>>>::result_type, volatile float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_158)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_158)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_158)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_158)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_158)>>>>>::arg0_type, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_158)>>>>>::arg_type<0>, volatile float * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_158)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_158)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_158)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_158)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_158)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_158)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_158)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_158)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_158)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(fn_158)>> == false);
const volatile float * && fn_159(const volatile float * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_159)>>::result_type, const volatile float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<decltype(fn_159)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<decltype(fn_159)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<decltype(fn_159)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_159)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_159)>>>::arg0_type, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_159)>>>::arg_type<0>, const volatile float * &&>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_159)>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_159)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_159)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_159)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_159)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_159)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_159)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_159)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_159)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_159)>>>>> == false);
float * const && fn_160(float * const &&);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_160)>>>>::result_type, float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_160)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_160)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_160)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_160)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_160)>>>::arg0_type, float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_160)>>>::arg_type<0>, float * const &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_160)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_160)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_160)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_160)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_160)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_160)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_160)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_160)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_160)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_160)>>>>>> == false);
const float * const && fn_161(const float * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_161)>>>>>::result_type, const float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_161)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_161)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_161)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_161)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_161)>>::arg0_type, const float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_161)>>>::arg_type<0>, const float * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_161)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_161)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_161)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_161)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_161)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_161)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_161)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_161)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_161)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_161)>>>>>> == false);
volatile float * const && fn_162(volatile float * const &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_162)>>>>::result_type, volatile float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_162)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_162)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_162)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_162)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_162)>>>>>::arg0_type, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_162)>>>>>::arg_type<0>, volatile float * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_162)>>>>>::arity == 1);
static_assert(callable_traits<decltype(fn_162)>::is_functor == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_162)>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_162)>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_162)>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_162)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_162)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_162)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_162)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_162)>>>> == false);
const volatile float * const && fn_163(const volatile float * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_163)>>>>::result_type, const volatile float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_163)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_163)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_163)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_163)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_163)>>>>::arg0_type, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_163)>>>>::arg_type<0>, const volatile float * const &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_163)>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_163)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_163)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_163)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_163)>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_163)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_163)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_163)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_163)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_163)>>>>> == false);
float * volatile && fn_164(float * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_164)>>>>::result_type, float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_164)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_164)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_164)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_164)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_164)>>>>>::arg0_type, float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_164)>>>>::arg_type<0>, float * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_164)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_164)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_164)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_164)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_164)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_164)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_164)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_164)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_164)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_164)>>>> == false);
const float * volatile && fn_165(const float * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_165)>>>::result_type, const float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_165)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_165)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_165)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_165)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_165)>>>>::arg0_type, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_165)>>>>>::arg_type<0>, const float * volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_165)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_165)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_165)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_165)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_165)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_165)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_165)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_165)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_165)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_165)>>>>>> == false);
volatile float * volatile && fn_166(volatile float * volatile &&);
static_assert(std::is_same_v<callable_traits<decltype(fn_166)>::result_type, volatile float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<decltype(fn_166)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<decltype(fn_166)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<decltype(fn_166)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<decltype(fn_166)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_166)>>>::arg0_type, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_166)>>>::arg_type<0>, volatile float * volatile &&>);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_166)>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_166)>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_166)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_166)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_166)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_166)>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_166)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_166)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_166)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_166)>>>> == false);
const volatile float * volatile && fn_167(const volatile float * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_167)>>>>::result_type, const volatile float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_167)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_167)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_167)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_167)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_167)>>>::arg0_type, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_167)>>>::arg_type<0>, const volatile float * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_167)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_167)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_167)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_167)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_167)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_167)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_167)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_167)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_167)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_167)>>>>>> == false);
float * const volatile && fn_168(float * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_168)>>>>>::result_type, float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_168)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_168)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_168)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_168)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_168)>>>>>::arg0_type, float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_168)>>::arg_type<0>, float * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_168)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_168)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_168)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_168)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_168)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_168)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_168)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_168)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_168)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_168)>>>>>> == false);
const float * const volatile && fn_169(const float * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_169)>>>>>::result_type, const float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_169)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_169)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_169)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_169)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_169)>>>>::arg0_type, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_169)>>>>>::arg_type<0>, const float * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_169)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_169)>>>>>::is_functor == false);
static_assert(callable_traits<decltype(fn_169)>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_169)>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_169)>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<decltype(fn_169)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_169)>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_169)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_169)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_169)>>>> == false);
volatile float * const volatile && fn_170(volatile float * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_170)>>>::result_type, volatile float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_170)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_170)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_170)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_170)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_170)>>>>::arg0_type, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_170)>>>>::arg_type<0>, volatile float * const volatile &&>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_170)>>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_170)>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_170)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_170)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_170)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_170)>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_170)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_170)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_170)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_170)>>>> == false);
const volatile float * const volatile && fn_171(const volatile float * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_171)>>>>::result_type, const volatile float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_171)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_171)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_171)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_171)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_171)>>>>>::arg0_type, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_171)>>>>>::arg_type<0>, const volatile float * const volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_171)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_171)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_171)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_171)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_171)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_171)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_171)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_171)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_171)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_171)>>>> == false);
std::string fn_172(std::string);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_172)>>>::result_type, std::string>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_172)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_172)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_172)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_172)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_172)>>>>::arg0_type, std::string>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_172)>>>>::arg_type<0>, std::string>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_172)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_172)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_172)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_172)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_172)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_172)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_172)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_172)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_172)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_172)>>>>>> == false);
std::string * fn_173(std::string *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_173)>>>>>::result_type, std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(fn_173)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<decltype(fn_173)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<decltype(fn_173)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<decltype(fn_173)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_173)>>::arg0_type, std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_173)>>>::arg_type<0>, std::string *>);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_173)>>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_173)>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_173)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_173)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_173)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_173)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_173)>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_173)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_173)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_173)>>>>> == false);
const std::string * fn_174(const std::string *);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_174)>>>::result_type, const std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_174)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_174)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_174)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_174)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_174)>>>::arg0_type, const std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_174)>>>::arg_type<0>, const std::string *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_174)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_174)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_174)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_174)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_174)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_174)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_174)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_174)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_174)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_174)>>>>> == false);
volatile std::string * fn_175(volatile std::string *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_175)>>>>>::result_type, volatile std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_175)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_175)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_175)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_175)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_175)>>>>>::arg0_type, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_175)>>>>>::arg_type<0>, volatile std::string *>);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_175)>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_175)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_175)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_175)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_175)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_175)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_175)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_175)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_175)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_175)>>>>>> == false);
const volatile std::string * fn_176(const volatile std::string *);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_176)>>>>>::result_type, const volatile std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_176)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_176)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_176)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_176)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_176)>>>>>::arg0_type, const volatile std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_176)>>>>::arg_type<0>, const volatile std::string *>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_176)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_176)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_176)>>>>>::is_member_function == false);
static_assert(callable_traits<decltype(fn_176)>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_176)>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_176)>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_176)>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_176)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_176)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_176)>>>> == false);
std::string & fn_177(std::string &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_177)>>>::result_type, std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_177)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_177)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_177)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_177)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_177)>>>::arg0_type, std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_177)>>>>::arg_type<0>, std::string &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_177)>>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_177)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_177)>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_177)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_177)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_177)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_177)>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_177)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_177)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_177)>>>> == false);
const std::string & fn_178(const std::string &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_178)>>>::result_type, const std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_178)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_178)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_178)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_178)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_178)>>>>>::arg0_type, const std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_178)>>>>>::arg_type<0>, const std::string &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_178)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_178)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_178)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_178)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_178)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_178)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_178)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_178)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_178)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_178)>>> == false);
volatile std::string & fn_179(volatile std::string &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_179)>>>::result_type, volatile std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_179)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_179)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_179)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_179)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_179)>>>>::arg0_type, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_179)>>>>::arg_type<0>, volatile std::string &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_179)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_179)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_179)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_179)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_179)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_179)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_179)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_179)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_179)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_179)>>>>>> == false);
const volatile std::string & fn_180(const volatile std::string &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_180)>>>>>::result_type, const volatile std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_180)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(fn_180)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<decltype(fn_180)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<decltype(fn_180)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_180)>>::arg0_type, const volatile std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_180)>>::arg_type<0>, const volatile std::string &>);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_180)>>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_180)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_180)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_180)>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_180)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_180)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_180)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_180)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_180)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_180)>>>>> == false);
std::string * & fn_181(std::string * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_181)>>>>::result_type, std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_181)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_181)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_181)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_181)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_181)>>::arg0_type, std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_181)>>>::arg_type<0>, std::string * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_181)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_181)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_181)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_181)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_181)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_181)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_181)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_181)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_181)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_181)>>>>>> == false);
const std::string * & fn_182(const std::string * &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_182)>>>>::result_type, const std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_182)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_182)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_182)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_182)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_182)>>>>>::arg0_type, const std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_182)>>>>>::arg_type<0>, const std::string * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_182)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_182)>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_182)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_182)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_182)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_182)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_182)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_182)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_182)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_182)>>>>> == false);
volatile std::string * & fn_183(volatile std::string * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_183)>>>>>::result_type, volatile std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_183)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_183)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_183)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_183)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_183)>>>>>::arg0_type, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_183)>>>>>::arg_type<0>, volatile std::string * &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_183)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_183)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_183)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_183)>>>>>::is_variadic == true);
static_assert(callable_traits<decltype(fn_183)>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<decltype(fn_183)>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_183)>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_183)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_183)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_183)>>>> == false);
const volatile std::string * & fn_184(const volatile std::string * &);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_184)>>>::result_type, const volatile std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_184)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_184)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_184)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_184)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_184)>>>>::arg0_type, const volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_184)>>>::arg_type<0>, const volatile std::string * &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_184)>>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_184)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_184)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_184)>>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_184)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_184)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_184)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_184)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_184)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_184)>>>> == false);
std::string * const & fn_185(std::string * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_185)>>>::result_type, std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_185)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_185)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_185)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_185)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_185)>>>>::arg0_type, std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_185)>>>>>::arg_type<0>, std::string * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_185)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_185)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_185)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_185)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_185)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_185)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_185)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_185)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_185)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_185)>>>>>> == false);
const std::string * const & fn_186(const std::string * const &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_186)>>::result_type, const std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_186)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_186)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_186)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_186)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_186)>>>>::arg0_type, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_186)>>>>::arg_type<0>, const std::string * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_186)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_186)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_186)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_186)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_186)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_186)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_186)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_186)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_186)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_186)>>>>> == false);
volatile std::string * const & fn_187(volatile std::string * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_187)>>>>>::result_type, volatile std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_187)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_187)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(fn_187)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<decltype(fn_187)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_187)>>::arg0_type, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_187)>>::arg_type<0>, volatile std::string * const &>);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_187)>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_187)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_187)>>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_187)>>>::is_variadic == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_187)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_187)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_187)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_187)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_187)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_187)>>>>> == false);
const volatile std::string * const & fn_188(const volatile std::string * const &);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_188)>>>>::result_type, const volatile std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_188)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_188)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_188)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_188)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_188)>>>>::arg0_type, const volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_188)>>::arg_type<0>, const volatile std::string * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_188)>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_188)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_188)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_188)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_188)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_188)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_188)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_188)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_188)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_188)>>>>>> == false);
std::string * volatile & fn_189(std::string * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_189)>>>>>::result_type, std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_189)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_189)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_189)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_189)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_189)>>>>::arg0_type, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_189)>>>>>::arg_type<0>, std::string * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_189)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_189)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_189)>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_189)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_189)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_189)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_189)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_189)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_189)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_189)>>>>> == false);
const std::string * volatile & fn_190(const std::string * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_190)>>>>::result_type, const std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_190)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_190)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_190)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_190)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_190)>>>>>::arg0_type, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_190)>>>>>::arg_type<0>, const std::string * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_190)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_190)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_190)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_190)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_190)>>>>>::is_noexcept == false);
static_assert(callable_traits<decltype(fn_190)>::is_const == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_190)>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_190)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_190)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<decltype(fn_190)>>> == false);
volatile std::string * volatile & fn_191(volatile std::string * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_191)>>>::result_type, volatile std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_191)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_191)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_191)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_191)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_191)>>>>::arg0_type, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_191)>>>>::arg_type<0>, volatile std::string * volatile &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_191)>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_191)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_191)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_191)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_191)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_191)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_191)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_191)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_191)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_191)>>>> == false);
const volatile std::string * volatile & fn_192(const volatile std::string * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_192)>>>::result_type, const volatile std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_192)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_192)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_192)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_192)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_192)>>>>::arg0_type, const volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_192)>>>>::arg_type<0>, const volatile std::string * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_192)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_192)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_192)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_192)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_192)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_192)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_192)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_192)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_192)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_192)>>>>>> == false);
std::string * const volatile & fn_193(std::string * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_193)>>>>>::result_type, std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_193)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_193)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_193)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_193)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_193)>>>::arg0_type, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_193)>>>>::arg_type<0>, std::string * const volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_193)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_193)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_193)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_193)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_193)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_193)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_193)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_193)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_193)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_193)>>>>>> == false);
const std::string * const volatile & fn_194(const std::string * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_194)>>>>::result_type, const std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_194)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_194)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_194)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(fn_194)>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_194)>>::arg0_type, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_194)>>::arg_type<0>, const std::string * const volatile &>);
static_assert(callable_traits<std::add_cv_t<decltype(fn_194)>>::arity == 1);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_194)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_194)>>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_194)>>>::is_variadic == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_194)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_194)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_194)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_194)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_194)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_194)>>>> == false);
volatile std::string * const volatile & fn_195(volatile std::string * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_195)>>>>::result_type, volatile std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_195)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_195)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_195)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_195)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_195)>>>>::arg0_type, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_195)>>>>::arg_type<0>, volatile std::string * const volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_195)>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_195)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_195)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_195)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_195)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_195)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_195)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_195)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_195)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_195)>>>>>> == false);
const volatile std::string * const volatile & fn_196(const volatile std::string * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_196)>>>>>::result_type, const volatile std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_196)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_196)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_196)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_196)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_196)>>>>>::arg0_type, const volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_196)>>>>::arg_type<0>, const volatile std::string * const volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_196)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_196)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_196)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_196)>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_196)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_196)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_196)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_196)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_196)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_196)>>>>> == false);
std::string && fn_197(std::string &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_197)>>>>::result_type, std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_197)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_197)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_197)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_197)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_197)>>>>::arg0_type, std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_197)>>>>>::arg_type<0>, std::string &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_197)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_197)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_197)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_197)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_197)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_197)>>>>>::is_const == false);
static_assert(callable_traits<decltype(fn_197)>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_197)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_197)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<decltype(fn_197)>>> == false);
const std::string && fn_198(const std::string &&);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_198)>>::result_type, const std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_198)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_198)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_198)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_198)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_198)>>>>::arg0_type, const std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_198)>>>>::arg_type<0>, const std::string &&>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_198)>>>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_198)>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_198)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_198)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_198)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_198)>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_198)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_198)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_198)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_198)>>> == false);
volatile std::string && fn_199(volatile std::string &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_199)>>>::result_type, volatile std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_199)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_199)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_199)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_199)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_199)>>>>::arg0_type, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_199)>>>>::arg_type<0>, volatile std::string &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_199)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_199)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_199)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_199)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_199)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_199)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_199)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_199)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_199)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_199)>>>>>> == false);
const volatile std::string && fn_200(const volatile std::string &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_200)>>>>>::result_type, const volatile std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_200)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_200)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_200)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_200)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_200)>>>::arg0_type, const volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_200)>>>::arg_type<0>, const volatile std::string &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_200)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_200)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_200)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_200)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_200)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_200)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_200)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_200)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_200)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_200)>>>>>> == false);
std::string * && fn_201(std::string * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_201)>>>>>::result_type, std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_201)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_201)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_201)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_201)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<decltype(fn_201)>::arg0_type, std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_201)>>::arg_type<0>, std::string * &&>);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_201)>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<decltype(fn_201)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_201)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_201)>>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_201)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_201)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_201)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_201)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_201)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_201)>>>>> == false);
const std::string * && fn_202(const std::string * &&);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_202)>>>::result_type, const std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_202)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_202)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_202)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_202)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_202)>>>>::arg0_type, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_202)>>>>::arg_type<0>, const std::string * &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_202)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_202)>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_202)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_202)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_202)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_202)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_202)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_202)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_202)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_202)>>>>> == false);
volatile std::string * && fn_203(volatile std::string * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_203)>>>>>::result_type, volatile std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_203)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_203)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_203)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_203)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_203)>>>>>::arg0_type, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_203)>>>>>::arg_type<0>, volatile std::string * &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_203)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_203)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_203)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_203)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_203)>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_203)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_203)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_203)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_203)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_203)>>>>> == false);
const volatile std::string * && fn_204(const volatile std::string * &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_204)>>>>::result_type, const volatile std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_204)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_204)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_204)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_204)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_204)>>>>>::arg0_type, const volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_204)>>>>::arg_type<0>, const volatile std::string * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_204)>>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_204)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_204)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_204)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_204)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_204)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_204)>>>>>::is_volatile == false);
static_assert(callable_traits<decltype(fn_204)>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_204)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<decltype(fn_204)>>> == false);
std::string * const && fn_205(std::string * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_205)>>::result_type, std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<decltype(fn_205)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_205)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_205)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_205)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_205)>>>::arg0_type, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_205)>>>>::arg_type<0>, std::string * const &&>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_205)>>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_205)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_205)>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_205)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_205)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_205)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_205)>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_205)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_205)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_205)>>>>> == false);
const std::string * const && fn_206(const std::string * const &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_206)>>::result_type, const std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_206)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_206)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_206)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_206)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_206)>>>>::arg0_type, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_206)>>>>::arg_type<0>, const std::string * const &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_206)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_206)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_206)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_206)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_206)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_206)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_206)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_206)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_206)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_206)>>>>> == false);
volatile std::string * const && fn_207(volatile std::string * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_207)>>>>>::result_type, volatile std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_207)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_207)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_207)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_207)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_207)>>>::arg0_type, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_207)>>>::arg_type<0>, volatile std::string * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_207)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_207)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_207)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_207)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_207)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_207)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_207)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_207)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_207)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_207)>>>>>> == false);
const volatile std::string * const && fn_208(const volatile std::string * const &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_208)>>>>>::result_type, const volatile std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_208)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_208)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_208)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_208)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_208)>>>>>::arg0_type, const volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(fn_208)>::arg_type<0>, const volatile std::string * const &&>);
static_assert(callable_traits<std::add_const_t<decltype(fn_208)>>::arity == 1);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_208)>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_208)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_208)>>::is_variadic == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_208)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_208)>>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_208)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_208)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_208)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_208)>>>>> == false);
std::string * volatile && fn_209(std::string * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_209)>>>>::result_type, std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_209)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_209)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_209)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_209)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_209)>>>::arg0_type, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_209)>>>>::arg_type<0>, std::string * volatile &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_209)>>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_209)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_209)>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_209)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_209)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_209)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_209)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_209)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_209)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_209)>>>>> == false);
const std::string * volatile && fn_210(const std::string * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_210)>>>>::result_type, const std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_210)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_210)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_210)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_210)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_210)>>>>>::arg0_type, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_210)>>>>>::arg_type<0>, const std::string * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_210)>>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_210)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_210)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_210)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_210)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_210)>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_210)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_210)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_210)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_210)>>>> == false);
volatile std::string * volatile && fn_211(volatile std::string * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_211)>>>>::result_type, volatile std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_211)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_211)>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_211)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_211)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_211)>>>>>::arg0_type, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_211)>>>>>::arg_type<0>, volatile std::string * volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_211)>>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_211)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_211)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_211)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_211)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_211)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_211)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_211)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(fn_211)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<decltype(fn_211)>>> == false);
const volatile std::string * volatile && fn_212(const volatile std::string * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_212)>>::result_type, const volatile std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<decltype(fn_212)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<decltype(fn_212)>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_212)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_212)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_212)>>>::arg0_type, const volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_212)>>>::arg_type<0>, const volatile std::string * volatile &&>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_212)>>>>::arity == 1);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_212)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_212)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_212)>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_212)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_212)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_212)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_212)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_212)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_212)>>>>> == false);
std::string * const volatile && fn_213(std::string * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_213)>>>>::result_type, std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_213)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_213)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_213)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_213)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_213)>>>::arg0_type, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_213)>>>>::arg_type<0>, std::string * const volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_213)>>>>::arity == 1);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_213)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_213)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_213)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_213)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_213)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_213)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_213)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_213)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_213)>>>>>> == false);
const std::string * const volatile && fn_214(const std::string * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_214)>>>>::result_type, const std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_214)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_214)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_214)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_214)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_214)>>>::arg0_type, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_214)>>>::arg_type<0>, const std::string * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_214)>>>::arity == 1);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_214)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_214)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_214)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_214)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_214)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_214)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_214)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_214)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_214)>>>>> == false);
volatile std::string * const volatile && fn_215(volatile std::string * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_215)>>>>>::result_type, volatile std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_215)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_215)>>>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_215)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_215)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_215)>>>>>::arg0_type, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_215)>>>>>::arg_type<0>, volatile std::string * const volatile &&>);
static_assert(callable_traits<decltype(fn_215)>::arity == 1);
static_assert(callable_traits<std::add_const_t<decltype(fn_215)>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_215)>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_215)>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_215)>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_215)>>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_215)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_215)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_215)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_215)>>>>> == false);
const volatile std::string * const volatile && fn_216(const volatile std::string * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_216)>>>>::result_type, const volatile std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_216)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_216)>>>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_216)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_216)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_216)>>>>::arg0_type, const volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_216)>>>::arg_type<0>, const volatile std::string * const volatile &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_216)>>>>::arity == 1);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_216)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_216)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_216)>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_216)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_216)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_216)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_216)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_216)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_216)>>>>> == false);
void fn_217(void *, const void *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_217)>>>>::result_type, void>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_217)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_217)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_217)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_217)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_217)>>>>::arg0_type, void *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_217)>>>>>::arg_type<0>, void *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_217)>>>>>::arg1_type, const void *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_217)>>>>>::arg_type<1>, const void *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_217)>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_217)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_217)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_217)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_217)>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_217)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_217)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_217)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_217)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_217)>>>>> == false);
void * fn_218(volatile void *, const volatile void *);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_218)>>>>::result_type, void *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_218)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_218)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_218)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_218)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_218)>>>>>::arg0_type, volatile void *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_218)>>>>::arg_type<0>, volatile void *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_218)>>>>>::arg1_type, const volatile void *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_218)>>>>>::arg_type<1>, const volatile void *>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_218)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_218)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_218)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_218)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_218)>>>>>::is_noexcept == false);
static_assert(callable_traits<decltype(fn_218)>::is_const == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_218)>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_218)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_218)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<decltype(fn_218)>>> == false);
const void * fn_219(void * &, const void * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_219)>>>::result_type, const void *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_219)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_219)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_219)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_219)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_219)>>>>::arg0_type, void * &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_219)>>>>::arg_type<0>, void * &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_219)>>>::arg1_type, const void * &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_219)>>>>::arg_type<1>, const void * &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_219)>>>>::arity == 2);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_219)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_219)>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_219)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_219)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_219)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_219)>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_219)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_219)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_219)>>>> == false);
volatile void * fn_220(volatile void * &, const volatile void * &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_220)>>>::result_type, volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_220)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_220)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_220)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_220)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_220)>>>>>::arg0_type, volatile void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_220)>>>>>::arg_type<0>, volatile void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_220)>>>>>::arg1_type, const volatile void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_220)>>>>::arg_type<1>, const volatile void * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_220)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_220)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_220)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_220)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_220)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_220)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_220)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_220)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_220)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_220)>>>> == false);
const volatile void * fn_221(void * const &, const void * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_221)>>>::result_type, const volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_221)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_221)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_221)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_221)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_221)>>>>::arg0_type, void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_221)>>>>>::arg_type<0>, void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_221)>>>>>::arg1_type, const void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_221)>>>>>::arg_type<1>, const void * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_221)>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_221)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_221)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_221)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_221)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_221)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_221)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_221)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(fn_221)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<decltype(fn_221)>>> == false);
void * & fn_222(volatile void * const &, const volatile void * const &);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_222)>>::result_type, void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<decltype(fn_222)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<decltype(fn_222)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_222)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_222)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_222)>>>::arg0_type, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_222)>>>::arg_type<0>, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_222)>>>>::arg1_type, const volatile void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_222)>>>>::arg_type<1>, const volatile void * const &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_222)>>>>::arity == 2);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_222)>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_222)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_222)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_222)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_222)>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_222)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_222)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_222)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_222)>>> == false);
const void * & fn_223(void * volatile &, const void * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_223)>>>::result_type, const void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_223)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_223)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_223)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_223)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_223)>>>>::arg0_type, void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_223)>>>>::arg_type<0>, void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_223)>>>>::arg1_type, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_223)>>>>>::arg_type<1>, const void * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_223)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_223)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_223)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_223)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_223)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_223)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_223)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_223)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_223)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_223)>>>>>> == false);
volatile void * & fn_224(volatile void * volatile &, const volatile void * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_224)>>::result_type, volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_224)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_224)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_224)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_224)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_224)>>>>::arg0_type, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_224)>>>>::arg_type<0>, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_224)>>>>::arg1_type, const volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_224)>>>>::arg_type<1>, const volatile void * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_224)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_224)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_224)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_224)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_224)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_224)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_224)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_224)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_224)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_224)>>>>>> == false);
const volatile void * & fn_225(void * const volatile &, const void * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_225)>>>>>::result_type, const volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(fn_225)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<decltype(fn_225)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<decltype(fn_225)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<decltype(fn_225)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_225)>>::arg0_type, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_225)>>>::arg_type<0>, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_225)>>>::arg1_type, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_225)>>>::arg_type<1>, const void * const volatile &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_225)>>>::arity == 2);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_225)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_225)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_225)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_225)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_225)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_225)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_225)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_225)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_225)>>>>> == false);
void * const & fn_226(volatile void * const volatile &, const volatile void * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_226)>>>>::result_type, void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_226)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_226)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_226)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_226)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_226)>>>::arg0_type, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_226)>>>::arg_type<0>, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_226)>>>>::arg1_type, const volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_226)>>>>::arg_type<1>, const volatile void * const volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_226)>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_226)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_226)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_226)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_226)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_226)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_226)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_226)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_226)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_226)>>>>> == false);
const void * const & fn_227(void * &&, const void * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_227)>>>>>::result_type, const void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_227)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_227)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_227)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_227)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_227)>>>::arg0_type, void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_227)>>>::arg_type<0>, void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_227)>>>::arg1_type, const void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_227)>>>>::arg_type<1>, const void * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_227)>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_227)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_227)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_227)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_227)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_227)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_227)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_227)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_227)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_227)>>>>>> == false);
volatile void * const & fn_228(volatile void * &&, const volatile void * &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_228)>>>>::result_type, volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_228)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_228)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_228)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(fn_228)>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_228)>>::arg0_type, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_228)>>::arg_type<0>, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_228)>>::arg1_type, const volatile void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_228)>>::arg_type<1>, const volatile void * &&>);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_228)>>>::arity == 2);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_228)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_228)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_228)>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_228)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_228)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_228)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_228)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_228)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_228)>>>>> == false);
const volatile void * const & fn_229(void * const &&, const void * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_229)>>>>::result_type, const volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_229)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_229)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_229)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_229)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_229)>>::arg0_type, void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_229)>>>::arg_type<0>, void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_229)>>>::arg1_type, const void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_229)>>>::arg_type<1>, const void * const &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_229)>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_229)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_229)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_229)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_229)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_229)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_229)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_229)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_229)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_229)>>>>>> == false);
void * volatile & fn_230(volatile void * const &&, const volatile void * const &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_230)>>>>>::result_type, void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_230)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_230)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_230)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_230)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_230)>>>>>::arg0_type, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_230)>>::arg_type<0>, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_230)>>>::arg1_type, const volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_230)>>>::arg_type<1>, const volatile void * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_230)>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_230)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_230)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_230)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_230)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_230)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_230)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_230)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_230)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_230)>>>>> == false);
const void * volatile & fn_231(void * volatile &&, const void * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_231)>>>>>::result_type, const void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_231)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_231)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_231)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_231)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_231)>>>>>::arg0_type, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_231)>>>>>::arg_type<0>, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(fn_231)>::arg1_type, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_231)>>::arg_type<1>, const void * volatile &&>);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_231)>>::arity == 2);
static_assert(callable_traits<std::add_cv_t<decltype(fn_231)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_231)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_231)>>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_231)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_231)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_231)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_231)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_231)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_231)>>>>> == false);
volatile void * volatile & fn_232(volatile void * volatile &&, const volatile void * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_232)>>>::result_type, volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_232)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_232)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_232)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_232)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_232)>>>>::arg0_type, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_232)>>>>::arg_type<0>, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_232)>>>>::arg1_type, const volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_232)>>::arg_type<1>, const volatile void * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_232)>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_232)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_232)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_232)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_232)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_232)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_232)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_232)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_232)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_232)>>>>>> == false);
const volatile void * volatile & fn_233(void * const volatile &&, const void * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_233)>>>>>::result_type, const volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_233)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_233)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_233)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_233)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_233)>>>>::arg0_type, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_233)>>>>>::arg_type<0>, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_233)>>>>>::arg1_type, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_233)>>>>>::arg_type<1>, const void * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_233)>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_233)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_233)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_233)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_233)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_233)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_233)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_233)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_233)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_233)>>>>>> == false);
void * const volatile & fn_234(volatile void * const volatile &&, const volatile void * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_234)>>>>>::result_type, void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_234)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_234)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_234)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_234)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_234)>>>>>::arg0_type, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_234)>>>>::arg_type<0>, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_234)>>>>>::arg1_type, const volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_234)>>>>>::arg_type<1>, const volatile void * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_234)>>>>>::arity == 2);
static_assert(callable_traits<decltype(fn_234)>::is_functor == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_234)>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_234)>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_234)>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_234)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_234)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_234)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_234)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_234)>>>> == false);
const void * const volatile & fn_235(bool, bool *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_235)>>>>::result_type, const void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_235)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_235)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_235)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_235)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_235)>>>>::arg0_type, bool>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_235)>>>>::arg_type<0>, bool>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_235)>>>::arg1_type, bool *>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_235)>>>>::arg_type<1>, bool *>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_235)>>>>::arity == 2);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_235)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_235)>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_235)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_235)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_235)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_235)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_235)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_235)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_235)>>>>> == false);
volatile void * const volatile & fn_236(const bool *, volatile bool *);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_236)>>>>::result_type, volatile void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_236)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_236)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_236)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_236)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_236)>>>>>::arg0_type, const bool *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_236)>>>>>::arg_type<0>, const bool *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_236)>>>>>::arg1_type, volatile bool *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_236)>>>>::arg_type<1>, volatile bool *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_236)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_236)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_236)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_236)>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_236)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_236)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_236)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_236)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_236)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_236)>>>>> == false);
const volatile void * const volatile & fn_237(const volatile bool *, bool &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_237)>>>>::result_type, const volatile void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_237)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_237)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_237)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_237)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_237)>>>>::arg0_type, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_237)>>>>>::arg_type<0>, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_237)>>>>>::arg1_type, bool &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_237)>>>>>::arg_type<1>, bool &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_237)>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_237)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_237)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_237)>>>>>::is_variadic == true);
static_assert(callable_traits<decltype(fn_237)>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<decltype(fn_237)>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_237)>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_237)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_237)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_237)>>>> == false);
void * && fn_238(const bool &, volatile bool &);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_238)>>>::result_type, void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_238)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_238)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_238)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_238)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_238)>>>>::arg0_type, const bool &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_238)>>>::arg_type<0>, const bool &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_238)>>>>::arg1_type, volatile bool &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_238)>>>>::arg_type<1>, volatile bool &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_238)>>>>::arity == 2);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_238)>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_238)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_238)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_238)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_238)>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_238)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_238)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_238)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_238)>>>> == false);
const void * && fn_239(const volatile bool &, bool * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_239)>>>>::result_type, const void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_239)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_239)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_239)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_239)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_239)>>>>>::arg0_type, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_239)>>>>>::arg_type<0>, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_239)>>>>::arg1_type, bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_239)>>>>>::arg_type<1>, bool * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_239)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_239)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_239)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_239)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_239)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_239)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_239)>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_239)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_239)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_239)>>>> == false);
volatile void * && fn_240(const bool * &, volatile bool * &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_240)>>>::result_type, volatile void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_240)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_240)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_240)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_240)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_240)>>>>>::arg0_type, const bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_240)>>>>>::arg_type<0>, const bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_240)>>>>>::arg1_type, volatile bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_240)>>>>::arg_type<1>, volatile bool * &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_240)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_240)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_240)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_240)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_240)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_240)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_240)>>>>>::is_volatile == false);
static_assert(callable_traits<decltype(fn_240)>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_240)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<decltype(fn_240)>>> == false);
const volatile void * && fn_241(const volatile bool * &, bool * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_241)>>::result_type, const volatile void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<decltype(fn_241)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_241)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_241)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_241)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_241)>>>::arg0_type, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_241)>>>>::arg_type<0>, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_241)>>>>::arg1_type, bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_241)>>>>::arg_type<1>, bool * const &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_241)>>>::arity == 2);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_241)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_241)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_241)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_241)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_241)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_241)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_241)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_241)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_241)>>>> == false);
void * const && fn_242(const bool * const &, volatile bool * const &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_242)>>>::result_type, void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_242)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_242)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_242)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_242)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_242)>>>>::arg0_type, const bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_242)>>>>::arg_type<0>, const bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_242)>>>>>::arg1_type, volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_242)>>>>>::arg_type<1>, volatile bool * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_242)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_242)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_242)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_242)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_242)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_242)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_242)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_242)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_242)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_242)>>> == false);
const void * const && fn_243(const volatile bool * const &, bool * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_243)>>>::result_type, const void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_243)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_243)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_243)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_243)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_243)>>>>::arg0_type, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_243)>>>>::arg_type<0>, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_243)>>>>::arg1_type, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_243)>>>>>::arg_type<1>, bool * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_243)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_243)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_243)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_243)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_243)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_243)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_243)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_243)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_243)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_243)>>>>>> == false);
volatile void * const && fn_244(const bool * volatile &, volatile bool * volatile &);
static_assert(std::is_same_v<callable_traits<decltype(fn_244)>::result_type, volatile void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<decltype(fn_244)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<decltype(fn_244)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<decltype(fn_244)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<decltype(fn_244)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_244)>>>::arg0_type, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_244)>>>::arg_type<0>, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_244)>>>::arg1_type, volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_244)>>>::arg_type<1>, volatile bool * volatile &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_244)>>>>::arity == 2);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_244)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_244)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_244)>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_244)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_244)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_244)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_244)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_244)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_244)>>>>> == false);
const volatile void * const && fn_245(const volatile bool * volatile &, bool * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_245)>>>>::result_type, const volatile void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_245)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_245)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_245)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_245)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_245)>>>::arg0_type, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_245)>>>>::arg_type<0>, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_245)>>>>::arg1_type, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_245)>>>>::arg_type<1>, bool * const volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_245)>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_245)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_245)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_245)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_245)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_245)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_245)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_245)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_245)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_245)>>>>>> == false);
void * volatile && fn_246(const bool * const volatile &, volatile bool * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_246)>>>>>::result_type, void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_246)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_246)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_246)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_246)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_246)>>>::arg0_type, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_246)>>>::arg_type<0>, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_246)>>>>::arg1_type, volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_246)>>>>::arg_type<1>, volatile bool * const volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_246)>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_246)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_246)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_246)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_246)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_246)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_246)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_246)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_246)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_246)>>>>> == false);
const void * volatile && fn_247(const volatile bool * const volatile &, bool &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_247)>>>>>::result_type, const void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_247)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_247)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(fn_247)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<decltype(fn_247)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_247)>>::arg0_type, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_247)>>::arg_type<0>, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_247)>>::arg1_type, bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_247)>>>::arg_type<1>, bool &&>);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_247)>>>::arity == 2);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_247)>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_247)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_247)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_247)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_247)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_247)>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_247)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_247)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_247)>>>>> == false);
volatile void * volatile && fn_248(const bool &&, volatile bool &&);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_248)>>>::result_type, volatile void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_248)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_248)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_248)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_248)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_248)>>>::arg0_type, const bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_248)>>>::arg_type<0>, const bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_248)>>>::arg1_type, volatile bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_248)>>>::arg_type<1>, volatile bool &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_248)>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_248)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_248)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_248)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_248)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_248)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_248)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_248)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_248)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_248)>>>>>> == false);
const volatile void * volatile && fn_249(const volatile bool &&, bool * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_249)>>>>>::result_type, const volatile void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_249)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_249)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_249)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_249)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_249)>>::arg0_type, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_249)>>>::arg_type<0>, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_249)>>>::arg1_type, bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_249)>>>::arg_type<1>, bool * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_249)>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_249)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_249)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_249)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_249)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_249)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_249)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_249)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_249)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_249)>>>>>> == false);
void * const volatile && fn_250(const bool * &&, volatile bool * &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_250)>>>>>::result_type, void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_250)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_250)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_250)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_250)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_250)>>>>>::arg0_type, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(fn_250)>::arg_type<0>, const bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_250)>>::arg1_type, volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_250)>>::arg_type<1>, volatile bool * &&>);
static_assert(callable_traits<std::add_cv_t<decltype(fn_250)>>::arity == 2);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_250)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_250)>>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_250)>>>::is_variadic == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_250)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_250)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_250)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_250)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_250)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_250)>>>> == false);
const void * const volatile && fn_251(const volatile bool * &&, bool * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_251)>>>>::result_type, const void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_251)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_251)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_251)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_251)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_251)>>>>::arg0_type, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_251)>>>>::arg_type<0>, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_251)>>::arg1_type, bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_251)>>>::arg_type<1>, bool * const &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_251)>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_251)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_251)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_251)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_251)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_251)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_251)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_251)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_251)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_251)>>>>>> == false);
volatile void * const volatile && fn_252(const bool * const &&, volatile bool * const &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_252)>>>>::result_type, volatile void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_252)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_252)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_252)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_252)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_252)>>>>>::arg0_type, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_252)>>>>>::arg_type<0>, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_252)>>>>>::arg1_type, volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_252)>>::arg_type<1>, volatile bool * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_252)>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_252)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_252)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_252)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_252)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_252)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_252)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_252)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_252)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_252)>>>>>> == false);
const volatile void * const volatile && fn_253(const volatile bool * const &&, bool * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_253)>>>>>::result_type, const volatile void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_253)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_253)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_253)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_253)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_253)>>>>::arg0_type, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_253)>>>>>::arg_type<0>, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_253)>>>>>::arg1_type, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_253)>>>>>::arg_type<1>, bool * volatile &&>);
static_assert(callable_traits<decltype(fn_253)>::arity == 2);
static_assert(callable_traits<std::add_const_t<decltype(fn_253)>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_253)>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_253)>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_253)>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_253)>>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_253)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_253)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_253)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_253)>>>>> == false);
bool fn_254(const bool * volatile &&, volatile bool * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_254)>>>>::result_type, bool>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_254)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_254)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_254)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_254)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_254)>>>>::arg0_type, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_254)>>>::arg_type<0>, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_254)>>>>::arg1_type, volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_254)>>>>::arg_type<1>, volatile bool * volatile &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_254)>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_254)>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_254)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_254)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_254)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_254)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_254)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_254)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_254)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_254)>>>>> == false);
bool * fn_255(const volatile bool * volatile &&, bool * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_255)>>>>>::result_type, bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_255)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_255)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_255)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_255)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_255)>>>>>::arg0_type, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_255)>>>>>::arg_type<0>, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_255)>>>>::arg1_type, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_255)>>>>>::arg_type<1>, bool * const volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_255)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_255)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_255)>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_255)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_255)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_255)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_255)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_255)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_255)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_255)>>>>> == false);
const bool * fn_256(const bool * const volatile &&, volatile bool * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_256)>>>>::result_type, const bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_256)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_256)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_256)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_256)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_256)>>>>>::arg0_type, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_256)>>>>>::arg_type<0>, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_256)>>>>>::arg1_type, volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_256)>>>>::arg_type<1>, volatile bool * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_256)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_256)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_256)>>>>>::is_member_function == false);
static_assert(callable_traits<decltype(fn_256)>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_256)>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_256)>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_256)>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_256)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_256)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_256)>>>> == false);
volatile bool * fn_257(const volatile bool * const volatile &&, int, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_257)>>>::result_type, volatile bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_257)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_257)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_257)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_257)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_257)>>>::arg0_type, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_257)>>>>::arg_type<0>, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_257)>>>>::arg1_type, int>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_257)>>>>::arg_type<1>, int>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_257)>>>::arity == 2);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_257)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_257)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_257)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_257)>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_257)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_257)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_257)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_257)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_257)>>>>> == false);
const volatile bool * fn_258(int *, const int *);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_258)>>>>::result_type, const volatile bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_258)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_258)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_258)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_258)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_258)>>>>>::arg0_type, int *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_258)>>>>::arg_type<0>, int *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_258)>>>>>::arg1_type, const int *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_258)>>>>>::arg_type<1>, const int *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_258)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_258)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_258)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_258)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_258)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_258)>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_258)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_258)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_258)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_258)>>>> == false);
bool & fn_259(volatile int *, const volatile int *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_259)>>>>::result_type, bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_259)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_259)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_259)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_259)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_259)>>>>>::arg0_type, volatile int *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_259)>>>>>::arg_type<0>, volatile int *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_259)>>>>::arg1_type, const volatile int *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_259)>>>>>::arg_type<1>, const volatile int *>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_259)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_259)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_259)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_259)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_259)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_259)>>>>>::is_const == false);
static_assert(callable_traits<decltype(fn_259)>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_259)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_259)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<decltype(fn_259)>>> == false);
const bool & fn_260(int &, const int &);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_260)>>::result_type, const bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_260)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_260)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_260)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_260)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_260)>>>>::arg0_type, int &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_260)>>>>::arg_type<0>, int &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_260)>>>>::arg1_type, const int &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_260)>>>::arg_type<1>, const int &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_260)>>>>::arity == 2);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_260)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_260)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_260)>>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_260)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_260)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_260)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_260)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_260)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_260)>>>> == false);
volatile bool & fn_261(volatile int &, const volatile int &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_261)>>>::result_type, volatile bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_261)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_261)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_261)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_261)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_261)>>>>::arg0_type, volatile int &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_261)>>>>>::arg_type<0>, volatile int &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_261)>>>>>::arg1_type, const volatile int &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_261)>>>>>::arg_type<1>, const volatile int &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_261)>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_261)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_261)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_261)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_261)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_261)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_261)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_261)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_261)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_261)>>>> == false);
const volatile bool & fn_262(int * &, const int * &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_262)>>>::result_type, const volatile bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_262)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_262)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_262)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_262)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_262)>>>>::arg0_type, int * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_262)>>>>::arg_type<0>, int * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_262)>>>>>::arg1_type, const int * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_262)>>>>>::arg_type<1>, const int * &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_262)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_262)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_262)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_262)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_262)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_262)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_262)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_262)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_262)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(fn_262)>> == false);
bool * & fn_263(volatile int * &, const volatile int * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_263)>>::result_type, bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<decltype(fn_263)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<decltype(fn_263)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<decltype(fn_263)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_263)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_263)>>>::arg0_type, volatile int * &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_263)>>>::arg_type<0>, volatile int * &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_263)>>>::arg1_type, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_263)>>>>::arg_type<1>, const volatile int * &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_263)>>>>::arity == 2);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_263)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_263)>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_263)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_263)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_263)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_263)>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_263)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_263)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_263)>>>>> == false);
const bool * & fn_264(int * const &, const int * const &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_264)>>::result_type, const bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_264)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_264)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_264)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_264)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_264)>>>>::arg0_type, int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_264)>>>>::arg_type<0>, int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_264)>>>>::arg1_type, const int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_264)>>>>::arg_type<1>, const int * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_264)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_264)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_264)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_264)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_264)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_264)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_264)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_264)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_264)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_264)>>>>>> == false);
volatile bool * & fn_265(volatile int * const &, const volatile int * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_265)>>>>>::result_type, volatile bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_265)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_265)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_265)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_265)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_265)>>>::arg0_type, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_265)>>>>::arg_type<0>, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_265)>>>>::arg1_type, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_265)>>>>::arg_type<1>, const volatile int * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_265)>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_265)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_265)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_265)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_265)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_265)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_265)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_265)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_265)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_265)>>>>>> == false);
const volatile bool * & fn_266(int * volatile &, const int * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_266)>>>>>::result_type, const volatile bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_266)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(fn_266)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<decltype(fn_266)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<decltype(fn_266)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_266)>>::arg0_type, int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_266)>>::arg_type<0>, int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_266)>>>::arg1_type, const int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_266)>>>::arg_type<1>, const int * volatile &>);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_266)>>>::arity == 2);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_266)>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_266)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_266)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_266)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_266)>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_266)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_266)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_266)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_266)>>>> == false);
bool * const & fn_267(volatile int * volatile &, const volatile int * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_267)>>>>::result_type, bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_267)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_267)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_267)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_267)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_267)>>>::arg0_type, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_267)>>>::arg_type<0>, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_267)>>>::arg1_type, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_267)>>>>::arg_type<1>, const volatile int * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_267)>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_267)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_267)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_267)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_267)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_267)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_267)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_267)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_267)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_267)>>>>>> == false);
const bool * const & fn_268(int * const volatile &, const int * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_268)>>>>::result_type, const bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_268)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_268)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_268)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_268)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_268)>>>::arg0_type, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_268)>>>::arg_type<0>, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_268)>>>::arg1_type, const int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_268)>>>::arg_type<1>, const int * const volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_268)>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_268)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_268)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_268)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_268)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_268)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_268)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_268)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_268)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_268)>>>>>> == false);
volatile bool * const & fn_269(volatile int * const volatile &, const volatile int * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_269)>>>>>::result_type, volatile bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_269)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_269)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_269)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_269)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<decltype(fn_269)>::arg0_type, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_269)>>::arg_type<0>, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_269)>>::arg1_type, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_269)>>::arg_type<1>, const volatile int * const volatile &>);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_269)>>::arity == 2);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_269)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_269)>>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_269)>>>::is_variadic == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_269)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_269)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_269)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_269)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_269)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_269)>>>>> == false);
const volatile bool * const & fn_270(int &&, const int &&);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_270)>>>>::result_type, const volatile bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_270)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_270)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_270)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_270)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_270)>>>>::arg0_type, int &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_270)>>::arg_type<0>, int &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_270)>>>::arg1_type, const int &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_270)>>>::arg_type<1>, const int &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_270)>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_270)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_270)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_270)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_270)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_270)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_270)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_270)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_270)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_270)>>>>> == false);
bool * volatile & fn_271(volatile int &&, const volatile int &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_271)>>>>>::result_type, bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_271)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_271)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_271)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_271)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_271)>>>>>::arg0_type, volatile int &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_271)>>>>>::arg_type<0>, volatile int &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_271)>>::arg1_type, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_271)>>>::arg_type<1>, const volatile int &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_271)>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_271)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_271)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_271)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_271)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_271)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_271)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_271)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_271)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_271)>>>>>> == false);
const bool * volatile & fn_272(int * &&, const int * &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_272)>>>>::result_type, const bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_272)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_272)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_272)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_272)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_272)>>>>>::arg0_type, int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_272)>>>>>::arg_type<0>, int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_272)>>>>>::arg1_type, const int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(fn_272)>::arg_type<1>, const int * &&>);
static_assert(callable_traits<std::add_const_t<decltype(fn_272)>>::arity == 2);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_272)>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_272)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_272)>>::is_variadic == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_272)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_272)>>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_272)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_272)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_272)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_272)>>>>> == false);
volatile bool * volatile & fn_273(volatile int * &&, const volatile int * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_273)>>>>::result_type, volatile bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_273)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_273)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_273)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_273)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_273)>>>::arg0_type, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_273)>>>>::arg_type<0>, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_273)>>>>::arg1_type, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_273)>>>>::arg_type<1>, const volatile int * &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_273)>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_273)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_273)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_273)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_273)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_273)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_273)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_273)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_273)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_273)>>>>>> == false);
const volatile bool * volatile & fn_274(int * const &&, const int * const &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_274)>>>>>::result_type, const volatile bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_274)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_274)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_274)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_274)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_274)>>>>>::arg0_type, int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_274)>>>>::arg_type<0>, int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_274)>>>>>::arg1_type, const int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_274)>>>>>::arg_type<1>, const int * const &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_274)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_274)>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_274)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_274)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_274)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_274)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_274)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_274)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_274)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_274)>>>>> == false);
bool * const volatile & fn_275(volatile int * const &&, const volatile int * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_275)>>>>>::result_type, bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_275)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_275)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_275)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_275)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_275)>>>>>::arg0_type, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_275)>>>>>::arg_type<0>, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_275)>>>>::arg1_type, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_275)>>>>>::arg_type<1>, const volatile int * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_275)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_275)>>>>>::is_functor == false);
static_assert(callable_traits<decltype(fn_275)>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_275)>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_275)>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<decltype(fn_275)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_275)>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_275)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_275)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_275)>>>> == false);
const bool * const volatile & fn_276(int * volatile &&, const int * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_276)>>>::result_type, const bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_276)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_276)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_276)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_276)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_276)>>>>::arg0_type, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_276)>>>>::arg_type<0>, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_276)>>>>::arg1_type, const int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_276)>>>::arg_type<1>, const int * volatile &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_276)>>>>::arity == 2);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_276)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_276)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_276)>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_276)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_276)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_276)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_276)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_276)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_276)>>>>> == false);
volatile bool * const volatile & fn_277(volatile int * volatile &&, const volatile int * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_277)>>>>::result_type, volatile bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_277)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_277)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_277)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_277)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_277)>>>>::arg0_type, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_277)>>>>>::arg_type<0>, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_277)>>>>>::arg1_type, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_277)>>>>>::arg_type<1>, const volatile int * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_277)>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_277)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_277)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_277)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_277)>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_277)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_277)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_277)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_277)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_277)>>>>> == false);
const volatile bool * const volatile & fn_278(int * const volatile &&, const int * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_278)>>>>::result_type, const volatile bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_278)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_278)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_278)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_278)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_278)>>>>>::arg0_type, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_278)>>>>::arg_type<0>, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_278)>>>>>::arg1_type, const int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_278)>>>>>::arg_type<1>, const int * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_278)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_278)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_278)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_278)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_278)>>>>>::is_noexcept == false);
static_assert(callable_traits<decltype(fn_278)>::is_const == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_278)>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_278)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_278)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<decltype(fn_278)>>> == false);
bool && fn_279(volatile int * const volatile &&, const volatile int * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_279)>>>::result_type, bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_279)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_279)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_279)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_279)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_279)>>>>::arg0_type, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_279)>>>>::arg_type<0>, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_279)>>>::arg1_type, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_279)>>>>::arg_type<1>, const volatile int * const volatile &&>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_279)>>>>::arity == 2);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_279)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_279)>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_279)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_279)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_279)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_279)>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_279)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_279)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_279)>>>> == false);
const bool && fn_280(float, float *);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_280)>>>::result_type, const bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_280)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_280)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_280)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_280)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_280)>>>>>::arg0_type, float>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_280)>>>>>::arg_type<0>, float>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_280)>>>>>::arg1_type, float *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_280)>>>>::arg_type<1>, float *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_280)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_280)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_280)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_280)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_280)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_280)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_280)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_280)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_280)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_280)>>>> == false);
volatile bool && fn_281(const float *, volatile float *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_281)>>>::result_type, volatile bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_281)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_281)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_281)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_281)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_281)>>>>::arg0_type, const float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_281)>>>>>::arg_type<0>, const float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_281)>>>>>::arg1_type, volatile float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_281)>>>>>::arg_type<1>, volatile float *>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_281)>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_281)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_281)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_281)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_281)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_281)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_281)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_281)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(fn_281)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<decltype(fn_281)>>> == false);
const volatile bool && fn_282(const volatile float *, float &);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_282)>>::result_type, const volatile bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<decltype(fn_282)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<decltype(fn_282)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_282)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_282)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_282)>>>::arg0_type, const volatile float *>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_282)>>>::arg_type<0>, const volatile float *>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_282)>>>>::arg1_type, float &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_282)>>>>::arg_type<1>, float &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_282)>>>>::arity == 2);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_282)>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_282)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_282)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_282)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_282)>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_282)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_282)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_282)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_282)>>> == false);
bool * && fn_283(const float &, volatile float &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_283)>>>::result_type, bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_283)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_283)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_283)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_283)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_283)>>>>::arg0_type, const float &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_283)>>>>::arg_type<0>, const float &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_283)>>>>::arg1_type, volatile float &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_283)>>>>>::arg_type<1>, volatile float &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_283)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_283)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_283)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_283)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_283)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_283)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_283)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_283)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_283)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_283)>>>>>> == false);
const bool * && fn_284(const volatile float &, float * &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_284)>>::result_type, const bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_284)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_284)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_284)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_284)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_284)>>>>::arg0_type, const volatile float &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_284)>>>>::arg_type<0>, const volatile float &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_284)>>>>::arg1_type, float * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_284)>>>>::arg_type<1>, float * &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_284)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_284)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_284)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_284)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_284)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_284)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_284)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_284)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_284)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_284)>>>>>> == false);
volatile bool * && fn_285(const float * &, volatile float * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_285)>>>>>::result_type, volatile bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(fn_285)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<decltype(fn_285)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<decltype(fn_285)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<decltype(fn_285)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_285)>>::arg0_type, const float * &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_285)>>>::arg_type<0>, const float * &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_285)>>>::arg1_type, volatile float * &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_285)>>>::arg_type<1>, volatile float * &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_285)>>>::arity == 2);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_285)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_285)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_285)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_285)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_285)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_285)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_285)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_285)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_285)>>>>> == false);
const volatile bool * && fn_286(const volatile float * &, float * const &);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_286)>>>>::result_type, const volatile bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_286)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_286)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_286)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_286)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_286)>>>::arg0_type, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_286)>>>::arg_type<0>, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_286)>>>>::arg1_type, float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_286)>>>>::arg_type<1>, float * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_286)>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_286)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_286)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_286)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_286)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_286)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_286)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_286)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_286)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_286)>>>>> == false);
bool * const && fn_287(const float * const &, volatile float * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_287)>>>>>::result_type, bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_287)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_287)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_287)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_287)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_287)>>>::arg0_type, const float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_287)>>>::arg_type<0>, const float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_287)>>>::arg1_type, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_287)>>>>::arg_type<1>, volatile float * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_287)>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_287)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_287)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_287)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_287)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_287)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_287)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_287)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_287)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_287)>>>>>> == false);
const bool * const && fn_288(const volatile float * const &, float * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_288)>>>>::result_type, const bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_288)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_288)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_288)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(fn_288)>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_288)>>::arg0_type, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_288)>>::arg_type<0>, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_288)>>::arg1_type, float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_288)>>::arg_type<1>, float * volatile &>);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_288)>>>::arity == 2);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_288)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_288)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_288)>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_288)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_288)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_288)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_288)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_288)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_288)>>>>> == false);
volatile bool * const && fn_289(const float * volatile &, volatile float * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_289)>>>>::result_type, volatile bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_289)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_289)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_289)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_289)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_289)>>::arg0_type, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_289)>>>::arg_type<0>, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_289)>>>::arg1_type, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_289)>>>::arg_type<1>, volatile float * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_289)>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_289)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_289)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_289)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_289)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_289)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_289)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_289)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_289)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_289)>>>>>> == false);
const volatile bool * const && fn_290(const volatile float * volatile &, float * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_290)>>>>>::result_type, const volatile bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_290)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_290)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_290)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_290)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_290)>>>>>::arg0_type, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_290)>>::arg_type<0>, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_290)>>>::arg1_type, float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_290)>>>::arg_type<1>, float * const volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_290)>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_290)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_290)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_290)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_290)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_290)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_290)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_290)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_290)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_290)>>>>> == false);
bool * volatile && fn_291(const float * const volatile &, volatile float * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_291)>>>>>::result_type, bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_291)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_291)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_291)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_291)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_291)>>>>>::arg0_type, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_291)>>>>>::arg_type<0>, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(fn_291)>::arg1_type, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_291)>>::arg_type<1>, volatile float * const volatile &>);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_291)>>::arity == 2);
static_assert(callable_traits<std::add_cv_t<decltype(fn_291)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_291)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_291)>>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_291)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_291)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_291)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_291)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_291)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_291)>>>>> == false);
const bool * volatile && fn_292(const volatile float * const volatile &, float &&);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_292)>>>::result_type, const bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_292)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_292)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_292)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_292)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_292)>>>>::arg0_type, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_292)>>>>::arg_type<0>, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_292)>>>>::arg1_type, float &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_292)>>::arg_type<1>, float &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_292)>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_292)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_292)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_292)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_292)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_292)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_292)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_292)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_292)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_292)>>>>>> == false);
volatile bool * volatile && fn_293(const float &&, volatile float &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_293)>>>>>::result_type, volatile bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_293)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_293)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_293)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_293)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_293)>>>>::arg0_type, const float &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_293)>>>>>::arg_type<0>, const float &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_293)>>>>>::arg1_type, volatile float &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_293)>>>>>::arg_type<1>, volatile float &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_293)>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_293)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_293)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_293)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_293)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_293)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_293)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_293)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_293)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_293)>>>>>> == false);
const volatile bool * volatile && fn_294(const volatile float &&, float * &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_294)>>>>>::result_type, const volatile bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_294)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_294)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_294)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_294)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_294)>>>>>::arg0_type, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_294)>>>>::arg_type<0>, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_294)>>>>>::arg1_type, float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_294)>>>>>::arg_type<1>, float * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_294)>>>>>::arity == 2);
static_assert(callable_traits<decltype(fn_294)>::is_functor == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_294)>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_294)>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_294)>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_294)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_294)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_294)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_294)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_294)>>>> == false);
bool * const volatile && fn_295(const float * &&, volatile float * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_295)>>>>::result_type, bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_295)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_295)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_295)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_295)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_295)>>>>::arg0_type, const float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_295)>>>>::arg_type<0>, const float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_295)>>>::arg1_type, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_295)>>>>::arg_type<1>, volatile float * &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_295)>>>>::arity == 2);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_295)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_295)>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_295)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_295)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_295)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_295)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_295)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_295)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_295)>>>>> == false);
const bool * const volatile && fn_296(const volatile float * &&, float * const &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_296)>>>>::result_type, const bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_296)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_296)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_296)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_296)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_296)>>>>>::arg0_type, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_296)>>>>>::arg_type<0>, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_296)>>>>>::arg1_type, float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_296)>>>>::arg_type<1>, float * const &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_296)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_296)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_296)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_296)>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_296)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_296)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_296)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_296)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_296)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_296)>>>>> == false);
volatile bool * const volatile && fn_297(const float * const &&, volatile float * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_297)>>>>::result_type, volatile bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_297)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_297)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_297)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_297)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_297)>>>>::arg0_type, const float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_297)>>>>>::arg_type<0>, const float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_297)>>>>>::arg1_type, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_297)>>>>>::arg_type<1>, volatile float * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_297)>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_297)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_297)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_297)>>>>>::is_variadic == true);
static_assert(callable_traits<decltype(fn_297)>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<decltype(fn_297)>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_297)>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_297)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_297)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_297)>>>> == false);
const volatile bool * const volatile && fn_298(const volatile float * const &&, float * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_298)>>>::result_type, const volatile bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_298)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_298)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_298)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_298)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_298)>>>>::arg0_type, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_298)>>>::arg_type<0>, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_298)>>>>::arg1_type, float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_298)>>>>::arg_type<1>, float * volatile &&>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_298)>>>>::arity == 2);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_298)>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_298)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_298)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_298)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_298)>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_298)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_298)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_298)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_298)>>>> == false);
int fn_299(const float * volatile &&, volatile float * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_299)>>>>::result_type, int>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_299)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_299)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_299)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_299)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_299)>>>>>::arg0_type, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_299)>>>>>::arg_type<0>, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_299)>>>>::arg1_type, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_299)>>>>>::arg_type<1>, volatile float * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_299)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_299)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_299)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_299)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_299)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_299)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_299)>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_299)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_299)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_299)>>>> == false);
int * fn_300(const volatile float * volatile &&, float * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_300)>>>::result_type, int *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_300)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_300)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_300)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_300)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_300)>>>>>::arg0_type, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_300)>>>>>::arg_type<0>, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_300)>>>>>::arg1_type, float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_300)>>>>::arg_type<1>, float * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_300)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_300)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_300)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_300)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_300)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_300)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_300)>>>>>::is_volatile == false);
static_assert(callable_traits<decltype(fn_300)>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_300)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<decltype(fn_300)>>> == false);
const int * fn_301(const float * const volatile &&, volatile float * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_301)>>::result_type, const int *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<decltype(fn_301)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_301)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_301)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_301)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_301)>>>::arg0_type, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_301)>>>>::arg_type<0>, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_301)>>>>::arg1_type, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_301)>>>>::arg_type<1>, volatile float * const volatile &&>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_301)>>>::arity == 2);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_301)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_301)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_301)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_301)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_301)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_301)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_301)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_301)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_301)>>>> == false);
volatile int * fn_302(const volatile float * const volatile &&, std::string);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_302)>>>::result_type, volatile int *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_302)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_302)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_302)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_302)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_302)>>>>::arg0_type, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_302)>>>>::arg_type<0>, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_302)>>>>>::arg1_type, std::string>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_302)>>>>>::arg_type<1>, std::string>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_302)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_302)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_302)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_302)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_302)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_302)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_302)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_302)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_302)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_302)>>> == false);
const volatile int * fn_303(std::string *, const std::string *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_303)>>>::result_type, const volatile int *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_303)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_303)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_303)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_303)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_303)>>>>::arg0_type, std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_303)>>>>::arg_type<0>, std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_303)>>>>::arg1_type, const std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_303)>>>>>::arg_type<1>, const std::string *>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_303)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_303)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_303)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_303)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_303)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_303)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_303)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_303)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_303)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_303)>>>>>> == false);
int & fn_304(volatile std::string *, const volatile std::string *);
static_assert(std::is_same_v<callable_traits<decltype(fn_304)>::result_type, int &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<decltype(fn_304)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<decltype(fn_304)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<decltype(fn_304)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<decltype(fn_304)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_304)>>>::arg0_type, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_304)>>>::arg_type<0>, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_304)>>>::arg1_type, const volatile std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_304)>>>::arg_type<1>, const volatile std::string *>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_304)>>>>::arity == 2);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_304)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_304)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_304)>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_304)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_304)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_304)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_304)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_304)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_304)>>>>> == false);
const int & fn_305(std::string &, const std::string &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_305)>>>>::result_type, const int &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_305)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_305)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_305)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_305)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_305)>>>::arg0_type, std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_305)>>>>::arg_type<0>, std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_305)>>>>::arg1_type, const std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_305)>>>>::arg_type<1>, const std::string &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_305)>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_305)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_305)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_305)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_305)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_305)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_305)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_305)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_305)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_305)>>>>>> == false);
volatile int & fn_306(volatile std::string &, const volatile std::string &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_306)>>>>>::result_type, volatile int &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_306)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_306)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_306)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_306)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_306)>>>::arg0_type, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_306)>>>::arg_type<0>, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_306)>>>>::arg1_type, const volatile std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_306)>>>>::arg_type<1>, const volatile std::string &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_306)>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_306)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_306)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_306)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_306)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_306)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_306)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_306)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_306)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_306)>>>>> == false);
const volatile int & fn_307(std::string * &, const std::string * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_307)>>>>>::result_type, const volatile int &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_307)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_307)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(fn_307)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<decltype(fn_307)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_307)>>::arg0_type, std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_307)>>::arg_type<0>, std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_307)>>::arg1_type, const std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_307)>>>::arg_type<1>, const std::string * &>);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_307)>>>::arity == 2);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_307)>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_307)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_307)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_307)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_307)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_307)>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_307)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_307)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_307)>>>>> == false);
int * & fn_308(volatile std::string * &, const volatile std::string * &);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_308)>>>::result_type, int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_308)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_308)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_308)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_308)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_308)>>>::arg0_type, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_308)>>>::arg_type<0>, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_308)>>>::arg1_type, const volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_308)>>>::arg_type<1>, const volatile std::string * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_308)>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_308)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_308)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_308)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_308)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_308)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_308)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_308)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_308)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_308)>>>>>> == false);
const int * & fn_309(std::string * const &, const std::string * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_309)>>>>>::result_type, const int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_309)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_309)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_309)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_309)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_309)>>::arg0_type, std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_309)>>>::arg_type<0>, std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_309)>>>::arg1_type, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_309)>>>::arg_type<1>, const std::string * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_309)>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_309)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_309)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_309)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_309)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_309)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_309)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_309)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_309)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_309)>>>>>> == false);
volatile int * & fn_310(volatile std::string * const &, const volatile std::string * const &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_310)>>>>>::result_type, volatile int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_310)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_310)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_310)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_310)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_310)>>>>>::arg0_type, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(fn_310)>::arg_type<0>, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_310)>>::arg1_type, const volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_310)>>::arg_type<1>, const volatile std::string * const &>);
static_assert(callable_traits<std::add_cv_t<decltype(fn_310)>>::arity == 2);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_310)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_310)>>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_310)>>>::is_variadic == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_310)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_310)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_310)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_310)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_310)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_310)>>>> == false);
const volatile int * & fn_311(std::string * volatile &, const std::string * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_311)>>>>::result_type, const volatile int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_311)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_311)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_311)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_311)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_311)>>>>::arg0_type, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_311)>>>>::arg_type<0>, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_311)>>::arg1_type, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_311)>>>::arg_type<1>, const std::string * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_311)>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_311)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_311)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_311)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_311)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_311)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_311)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_311)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_311)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_311)>>>>>> == false);
int * const & fn_312(volatile std::string * volatile &, const volatile std::string * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_312)>>>>::result_type, int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_312)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_312)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_312)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_312)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_312)>>>>>::arg0_type, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_312)>>>>>::arg_type<0>, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_312)>>>>>::arg1_type, const volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_312)>>::arg_type<1>, const volatile std::string * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_312)>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_312)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_312)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_312)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_312)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_312)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_312)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_312)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_312)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_312)>>>>>> == false);
const int * const & fn_313(std::string * const volatile &, const std::string * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_313)>>>>>::result_type, const int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_313)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_313)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_313)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_313)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_313)>>>>::arg0_type, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_313)>>>>>::arg_type<0>, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_313)>>>>>::arg1_type, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_313)>>>>>::arg_type<1>, const std::string * const volatile &>);
static_assert(callable_traits<decltype(fn_313)>::arity == 2);
static_assert(callable_traits<std::add_const_t<decltype(fn_313)>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_313)>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_313)>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_313)>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_313)>>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_313)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_313)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_313)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_313)>>>>> == false);
volatile int * const & fn_314(volatile std::string * const volatile &, const volatile std::string * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_314)>>>>::result_type, volatile int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_314)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_314)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_314)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_314)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_314)>>>>::arg0_type, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_314)>>>::arg_type<0>, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_314)>>>>::arg1_type, const volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_314)>>>>::arg_type<1>, const volatile std::string * const volatile &>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_314)>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_314)>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_314)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_314)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_314)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_314)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_314)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_314)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_314)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_314)>>>>> == false);
const volatile int * const & fn_315(std::string &&, const std::string &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_315)>>>>>::result_type, const volatile int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_315)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_315)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_315)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_315)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_315)>>>>>::arg0_type, std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_315)>>>>>::arg_type<0>, std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_315)>>>>::arg1_type, const std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_315)>>>>>::arg_type<1>, const std::string &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_315)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_315)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_315)>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_315)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_315)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_315)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_315)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_315)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_315)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_315)>>>>> == false);
int * volatile & fn_316(volatile std::string &&, const volatile std::string &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_316)>>>>::result_type, int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_316)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_316)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_316)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_316)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_316)>>>>>::arg0_type, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_316)>>>>>::arg_type<0>, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_316)>>>>>::arg1_type, const volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_316)>>>>::arg_type<1>, const volatile std::string &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_316)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_316)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_316)>>>>>::is_member_function == false);
static_assert(callable_traits<decltype(fn_316)>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_316)>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_316)>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_316)>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_316)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_316)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_316)>>>> == false);
const int * volatile & fn_317(std::string * &&, const std::string * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_317)>>>::result_type, const int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_317)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_317)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_317)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_317)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_317)>>>::arg0_type, std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_317)>>>>::arg_type<0>, std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_317)>>>>::arg1_type, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_317)>>>>::arg_type<1>, const std::string * &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_317)>>>::arity == 2);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_317)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_317)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_317)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_317)>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_317)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_317)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_317)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_317)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_317)>>>>> == false);
volatile int * volatile & fn_318(volatile std::string * &&, const volatile std::string * &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_318)>>>>::result_type, volatile int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_318)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_318)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_318)>>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_318)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_318)>>>>>::arg0_type, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_318)>>>>::arg_type<0>, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_318)>>>>>::arg1_type, const volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_318)>>>>>::arg_type<1>, const volatile std::string * &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_318)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_318)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_318)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_318)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_318)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_318)>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_318)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_318)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_318)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_318)>>>> == false);
const volatile int * volatile & fn_319(std::string * const &&, const std::string * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_319)>>>>::result_type, const volatile int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_319)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_319)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_319)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_319)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_319)>>>>>::arg0_type, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_319)>>>>>::arg_type<0>, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_319)>>>>::arg1_type, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_319)>>>>>::arg_type<1>, const std::string * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_319)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_319)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_319)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_319)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_319)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_319)>>>>>::is_const == false);
static_assert(callable_traits<decltype(fn_319)>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_319)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_319)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<decltype(fn_319)>>> == false);
int * const volatile & fn_320(volatile std::string * const &&, const volatile std::string * const &&);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_320)>>::result_type, int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_320)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_320)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_320)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_320)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_320)>>>>::arg0_type, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_320)>>>>::arg_type<0>, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_320)>>>>::arg1_type, const volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_320)>>>::arg_type<1>, const volatile std::string * const &&>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_320)>>>>::arity == 2);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_320)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_320)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_320)>>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_320)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_320)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_320)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_320)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_320)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_320)>>>> == false);
const int * const volatile & fn_321(std::string * volatile &&, const std::string * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_321)>>>::result_type, const int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_321)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_321)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_321)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_321)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_321)>>>>::arg0_type, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_321)>>>>>::arg_type<0>, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_321)>>>>>::arg1_type, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_321)>>>>>::arg_type<1>, const std::string * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_321)>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_321)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_321)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_321)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_321)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_321)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_321)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_321)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_321)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_321)>>>> == false);
volatile int * const volatile & fn_322(volatile std::string * volatile &&, const volatile std::string * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_322)>>>::result_type, volatile int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_322)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_322)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_322)>>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_322)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_322)>>>>::arg0_type, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_322)>>>>::arg_type<0>, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_322)>>>>>::arg1_type, const volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_322)>>>>>::arg_type<1>, const volatile std::string * volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_322)>>>>>::arity == 2);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_322)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_322)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_322)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_322)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_322)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_322)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_322)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_322)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(fn_322)>> == false);
const volatile int * const volatile & fn_323(std::string * const volatile &&, const std::string * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_323)>>::result_type, const volatile int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<decltype(fn_323)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<decltype(fn_323)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<decltype(fn_323)>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_323)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_323)>>>::arg0_type, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_323)>>>::arg_type<0>, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_323)>>>::arg1_type, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_323)>>>>::arg_type<1>, const std::string * const volatile &&>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_323)>>>>::arity == 2);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_323)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_323)>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_323)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_323)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_323)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_323)>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_323)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_323)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_323)>>>>> == false);
int && fn_324(volatile std::string * const volatile &&, const volatile std::string * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_324)>>::result_type, int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_324)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_324)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_324)>>>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_324)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_324)>>>>::arg0_type, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_324)>>>>::arg_type<0>, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_324)>>>>::arg1_type, const volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_324)>>>>::arg_type<1>, const volatile std::string * const volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_324)>>>>>::arity == 2);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_324)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_324)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_324)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_324)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_324)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_324)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_324)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_324)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_324)>>>>>> == false);
const int && fn_325(void *, const void *, volatile void *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_325)>>>>>::result_type, const int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_325)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_325)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_325)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_325)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_325)>>>::arg0_type, void *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_325)>>>>::arg_type<0>, void *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_325)>>>>::arg1_type, const void *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_325)>>>>::arg_type<1>, const void *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_325)>>>>::arg2_type, volatile void *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_325)>>>>>::arg_type<2>, volatile void *>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_325)>>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_325)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_325)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_325)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_325)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_325)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_325)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_325)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_325)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_325)>>>>>> == false);
volatile int && fn_326(const volatile void *, void * &, const void * &);
static_assert(std::is_same_v<callable_traits<decltype(fn_326)>::result_type, volatile int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<decltype(fn_326)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<decltype(fn_326)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<decltype(fn_326)>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<decltype(fn_326)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_326)>>>::arg0_type, const volatile void *>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_326)>>>::arg_type<0>, const volatile void *>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_326)>>>::arg1_type, void * &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_326)>>>::arg_type<1>, void * &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_326)>>>>::arg2_type, const void * &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_326)>>>>::arg_type<2>, const void * &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_326)>>>>::arity == 3);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_326)>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_326)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_326)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_326)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_326)>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_326)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_326)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_326)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_326)>>> == false);
const volatile int && fn_327(volatile void * &, const volatile void * &, void * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_327)>>>::result_type, const volatile int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_327)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_327)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_327)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_327)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_327)>>>>::arg0_type, volatile void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_327)>>>>::arg_type<0>, volatile void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_327)>>>>::arg1_type, const volatile void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_327)>>>>>::arg_type<1>, const volatile void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_327)>>>>>::arg2_type, void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_327)>>>>>::arg_type<2>, void * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_327)>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_327)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_327)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_327)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_327)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_327)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_327)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_327)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_327)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_327)>>>> == false);
int * && fn_328(const void * const &, volatile void * const &, const volatile void * const &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_328)>>>::result_type, int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_328)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_328)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_328)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_328)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_328)>>>>::arg0_type, const void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_328)>>>>::arg_type<0>, const void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_328)>>>>>::arg1_type, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_328)>>>>>::arg_type<1>, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_328)>>>>>::arg2_type, const volatile void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_328)>>>>::arg_type<2>, const volatile void * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_328)>>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_328)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_328)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_328)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_328)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_328)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_328)>>>>>::is_volatile == false);
static_assert(callable_traits<decltype(fn_328)>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_328)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<decltype(fn_328)>>> == false);
const int * && fn_329(void * volatile &, const void * volatile &, volatile void * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_329)>>::result_type, const int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<decltype(fn_329)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_329)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_329)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_329)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_329)>>>::arg0_type, void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_329)>>>>::arg_type<0>, void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_329)>>>>::arg1_type, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_329)>>>>::arg_type<1>, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_329)>>>::arg2_type, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_329)>>>>::arg_type<2>, volatile void * volatile &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_329)>>>>::arity == 3);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_329)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_329)>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_329)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_329)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_329)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_329)>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_329)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_329)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_329)>>>> == false);
volatile int * && fn_330(const volatile void * volatile &, void * const volatile &, const void * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_330)>>>::result_type, volatile int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_330)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_330)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_330)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_330)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_330)>>>>>::arg0_type, const volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_330)>>>>>::arg_type<0>, const volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_330)>>>>>::arg1_type, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_330)>>>>::arg_type<1>, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_330)>>>>>::arg2_type, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_330)>>>>>::arg_type<2>, const void * const volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_330)>>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_330)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_330)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_330)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_330)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_330)>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_330)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_330)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_330)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_330)>>>> == false);
const volatile int * && fn_331(volatile void * const volatile &, const volatile void * const volatile &, void * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_331)>>>>::result_type, const volatile int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_331)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_331)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_331)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_331)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_331)>>>>>::arg0_type, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_331)>>>>>::arg_type<0>, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_331)>>>>::arg1_type, const volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_331)>>>>>::arg_type<1>, const volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_331)>>>>>::arg2_type, void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_331)>>>>>::arg_type<2>, void * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_331)>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_331)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_331)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_331)>>>>>::is_variadic == true);
static_assert(callable_traits<decltype(fn_331)>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<decltype(fn_331)>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_331)>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_331)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_331)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_331)>>>> == false);
int * const && fn_332(const void * &&, volatile void * &&, const volatile void * &&);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_332)>>>::result_type, int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_332)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_332)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_332)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_332)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_332)>>>>::arg0_type, const void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_332)>>>::arg_type<0>, const void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_332)>>>>::arg1_type, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_332)>>>>::arg_type<1>, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_332)>>>>::arg2_type, const volatile void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_332)>>>::arg_type<2>, const volatile void * &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_332)>>>>::arity == 3);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_332)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_332)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_332)>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_332)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_332)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_332)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_332)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_332)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_332)>>>>> == false);
const int * const && fn_333(void * const &&, const void * const &&, volatile void * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_333)>>>>::result_type, const int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_333)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_333)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_333)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_333)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_333)>>>>::arg0_type, void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_333)>>>>>::arg_type<0>, void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_333)>>>>>::arg1_type, const void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_333)>>>>>::arg_type<1>, const void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_333)>>>>::arg2_type, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_333)>>>>>::arg_type<2>, volatile void * const &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_333)>>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_333)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_333)>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_333)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_333)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_333)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_333)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_333)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_333)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_333)>>>>> == false);
volatile int * const && fn_334(const volatile void * const &&, void * volatile &&, const void * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_334)>>>>::result_type, volatile int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_334)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_334)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_334)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_334)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_334)>>>>>::arg0_type, const volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_334)>>>>>::arg_type<0>, const volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_334)>>>>>::arg1_type, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_334)>>>>::arg_type<1>, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_334)>>>>>::arg2_type, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_334)>>>>>::arg_type<2>, const void * volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_334)>>>>>::arity == 3);
static_assert(callable_traits<decltype(fn_334)>::is_functor == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_334)>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_334)>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_334)>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_334)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_334)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_334)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_334)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_334)>>>> == false);
const volatile int * const && fn_335(volatile void * volatile &&, const volatile void * volatile &&, void * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_335)>>>>::result_type, const volatile int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_335)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_335)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_335)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_335)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_335)>>>>::arg0_type, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_335)>>>>::arg_type<0>, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_335)>>>::arg1_type, const volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_335)>>>>::arg_type<1>, const volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_335)>>>>::arg2_type, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_335)>>>>::arg_type<2>, void * const volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_335)>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_335)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_335)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_335)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_335)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_335)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_335)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_335)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_335)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_335)>>>>>> == false);
int * volatile && fn_336(const void * const volatile &&, volatile void * const volatile &&, const volatile void * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_336)>>>>>::result_type, int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_336)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_336)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_336)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_336)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_336)>>>>>::arg0_type, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_336)>>>>::arg_type<0>, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_336)>>>>>::arg1_type, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_336)>>>>>::arg_type<1>, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_336)>>>>>::arg2_type, const volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_336)>>::arg_type<2>, const volatile void * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_336)>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_336)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_336)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_336)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_336)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_336)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_336)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_336)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_336)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_336)>>>>>> == false);
const int * volatile && fn_337(bool, bool *, const bool *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_337)>>>>>::result_type, const int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_337)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_337)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_337)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_337)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_337)>>>>::arg0_type, bool>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_337)>>>>>::arg_type<0>, bool>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_337)>>>>>::arg1_type, bool *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_337)>>>>>::arg_type<1>, bool *>);
static_assert(std::is_same_v<callable_traits<decltype(fn_337)>::arg2_type, const bool *>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_337)>>::arg_type<2>, const bool *>);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_337)>>::arity == 3);
static_assert(callable_traits<std::add_cv_t<decltype(fn_337)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_337)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_337)>>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_337)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_337)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_337)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_337)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_337)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_337)>>>>> == false);
volatile int * volatile && fn_338(volatile bool *, const volatile bool *, bool &);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_338)>>>::result_type, volatile int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_338)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_338)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_338)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_338)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_338)>>>>::arg0_type, volatile bool *>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_338)>>>>::arg_type<0>, volatile bool *>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_338)>>>>::arg1_type, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_338)>>::arg_type<1>, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_338)>>>::arg2_type, bool &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_338)>>>::arg_type<2>, bool &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_338)>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_338)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_338)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_338)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_338)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_338)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_338)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_338)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_338)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_338)>>>>> == false);
const volatile int * volatile && fn_339(const bool &, volatile bool &, const volatile bool &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_339)>>>>>::result_type, const volatile int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_339)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_339)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_339)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_339)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_339)>>>>>::arg0_type, const bool &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_339)>>>>>::arg_type<0>, const bool &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_339)>>::arg1_type, volatile bool &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_339)>>>::arg_type<1>, volatile bool &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_339)>>>::arg2_type, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_339)>>>::arg_type<2>, const volatile bool &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_339)>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_339)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_339)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_339)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_339)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_339)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_339)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_339)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_339)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_339)>>>>>> == false);
int * const volatile && fn_340(bool * &, const bool * &, volatile bool * &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_340)>>>>>::result_type, int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_340)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_340)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_340)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_340)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_340)>>>>>::arg0_type, bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(fn_340)>::arg_type<0>, bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_340)>>::arg1_type, const bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_340)>>::arg_type<1>, const bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_340)>>::arg2_type, volatile bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_340)>>::arg_type<2>, volatile bool * &>);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_340)>>>::arity == 3);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_340)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_340)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_340)>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_340)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_340)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_340)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_340)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_340)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_340)>>>>> == false);
const int * const volatile && fn_341(const volatile bool * &, bool * const &, const bool * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_341)>>>>::result_type, const int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_341)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_341)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_341)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_341)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_341)>>::arg0_type, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_341)>>>::arg_type<0>, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_341)>>>::arg1_type, bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_341)>>>::arg_type<1>, bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_341)>>>::arg2_type, const bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_341)>>>>::arg_type<2>, const bool * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_341)>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_341)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_341)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_341)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_341)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_341)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_341)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_341)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_341)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_341)>>>>>> == false);
volatile int * const volatile && fn_342(volatile bool * const &, const volatile bool * const &, bool * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_342)>>>>::result_type, volatile int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_342)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_342)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_342)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_342)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_342)>>>::arg0_type, volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_342)>>>::arg_type<0>, volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_342)>>>::arg1_type, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_342)>>>::arg_type<1>, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_342)>>>>::arg2_type, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_342)>>>>::arg_type<2>, bool * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_342)>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_342)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_342)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_342)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_342)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_342)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_342)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_342)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_342)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_342)>>>>> == false);
const volatile int * const volatile && fn_343(const bool * volatile &, volatile bool * volatile &, const volatile bool * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_343)>>>>>::result_type, const volatile int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_343)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_343)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(fn_343)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<decltype(fn_343)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_343)>>::arg0_type, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_343)>>::arg_type<0>, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_343)>>::arg1_type, volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_343)>>>::arg_type<1>, volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_343)>>>::arg2_type, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_343)>>>::arg_type<2>, const volatile bool * volatile &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_343)>>>::arity == 3);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_343)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_343)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_343)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_343)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_343)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_343)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_343)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_343)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_343)>>>>> == false);
float fn_344(bool * const volatile &, const bool * const volatile &, volatile bool * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_344)>>>>::result_type, float>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_344)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_344)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_344)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_344)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_344)>>>::arg0_type, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_344)>>>::arg_type<0>, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_344)>>>>::arg1_type, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_344)>>>>::arg_type<1>, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_344)>>>>::arg2_type, volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_344)>>>>::arg_type<2>, volatile bool * const volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_344)>>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_344)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_344)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_344)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_344)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_344)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_344)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_344)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_344)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_344)>>>>>> == false);
float * fn_345(const volatile bool * const volatile &, bool &&, const bool &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_345)>>>>>::result_type, float *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_345)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_345)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_345)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_345)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_345)>>>::arg0_type, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_345)>>>>::arg_type<0>, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_345)>>>>::arg1_type, bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_345)>>>>::arg_type<1>, bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_345)>>>>::arg2_type, const bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_345)>>>>>::arg_type<2>, const bool &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_345)>>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_345)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_345)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_345)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_345)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_345)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_345)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_345)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_345)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_345)>>>>>> == false);
const float * fn_346(volatile bool &&, const volatile bool &&, bool * &&);
static_assert(std::is_same_v<callable_traits<decltype(fn_346)>::result_type, const float *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<decltype(fn_346)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<decltype(fn_346)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<decltype(fn_346)>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<decltype(fn_346)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_346)>>>::arg0_type, volatile bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_346)>>>::arg_type<0>, volatile bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_346)>>>::arg1_type, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_346)>>>::arg_type<1>, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_346)>>>>::arg2_type, bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_346)>>>>::arg_type<2>, bool * &&>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_346)>>>>::arity == 3);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_346)>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_346)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_346)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_346)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_346)>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_346)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_346)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_346)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_346)>>> == false);
volatile float * fn_347(const bool * &&, volatile bool * &&, const volatile bool * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_347)>>>::result_type, volatile float *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_347)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_347)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_347)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_347)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_347)>>>>::arg0_type, const bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_347)>>>>::arg_type<0>, const bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_347)>>>>::arg1_type, volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_347)>>>>>::arg_type<1>, volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_347)>>>>>::arg2_type, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_347)>>>>>::arg_type<2>, const volatile bool * &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_347)>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_347)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_347)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_347)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_347)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_347)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_347)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_347)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_347)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_347)>>>> == false);
const volatile float * fn_348(bool * const &&, const bool * const &&, volatile bool * const &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_348)>>>::result_type, const volatile float *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_348)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_348)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_348)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_348)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_348)>>>>::arg0_type, bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_348)>>>>::arg_type<0>, bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_348)>>>>>::arg1_type, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_348)>>>>>::arg_type<1>, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_348)>>>>>::arg2_type, volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_348)>>>>::arg_type<2>, volatile bool * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_348)>>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_348)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_348)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_348)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_348)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_348)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_348)>>>>>::is_volatile == false);
static_assert(callable_traits<decltype(fn_348)>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_348)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<decltype(fn_348)>>> == false);
float & fn_349(const volatile bool * const &&, bool * volatile &&, const bool * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_349)>>::result_type, float &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<decltype(fn_349)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_349)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_349)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_349)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_349)>>>::arg0_type, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_349)>>>>::arg_type<0>, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_349)>>>>::arg1_type, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_349)>>>>::arg_type<1>, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_349)>>>::arg2_type, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_349)>>>>::arg_type<2>, const bool * volatile &&>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_349)>>>>::arity == 3);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_349)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_349)>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_349)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_349)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_349)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_349)>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_349)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_349)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_349)>>>> == false);
const float & fn_350(volatile bool * volatile &&, const volatile bool * volatile &&, bool * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_350)>>>::result_type, const float &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_350)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_350)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_350)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_350)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_350)>>>>>::arg0_type, volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_350)>>>>>::arg_type<0>, volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_350)>>>>>::arg1_type, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_350)>>>>::arg_type<1>, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_350)>>>>>::arg2_type, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_350)>>>>>::arg_type<2>, bool * const volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_350)>>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_350)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_350)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_350)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_350)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_350)>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_350)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_350)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_350)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_350)>>>> == false);
volatile float & fn_351(const bool * const volatile &&, volatile bool * const volatile &&, const volatile bool * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_351)>>>>::result_type, volatile float &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_351)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_351)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_351)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_351)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_351)>>>>>::arg0_type, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_351)>>>>>::arg_type<0>, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_351)>>>>::arg1_type, volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_351)>>>>>::arg_type<1>, volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_351)>>>>>::arg2_type, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_351)>>>>>::arg_type<2>, const volatile bool * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_351)>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_351)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_351)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_351)>>>>>::is_variadic == true);
static_assert(callable_traits<decltype(fn_351)>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<decltype(fn_351)>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_351)>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_351)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_351)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_351)>>>> == false);
const volatile float & fn_352(int, int *, const int *);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_352)>>>::result_type, const volatile float &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_352)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_352)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_352)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_352)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_352)>>>>::arg0_type, int>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_352)>>>::arg_type<0>, int>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_352)>>>>::arg1_type, int *>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_352)>>>>::arg_type<1>, int *>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_352)>>>>::arg2_type, const int *>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_352)>>>::arg_type<2>, const int *>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_352)>>>>::arity == 3);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_352)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_352)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_352)>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_352)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_352)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_352)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_352)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_352)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_352)>>>>> == false);
float * & fn_353(volatile int *, const volatile int *, int &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_353)>>>>::result_type, float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_353)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_353)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_353)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_353)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_353)>>>>::arg0_type, volatile int *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_353)>>>>>::arg_type<0>, volatile int *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_353)>>>>>::arg1_type, const volatile int *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_353)>>>>>::arg_type<1>, const volatile int *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_353)>>>>::arg2_type, int &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_353)>>>>>::arg_type<2>, int &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_353)>>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_353)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_353)>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_353)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_353)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_353)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_353)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_353)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_353)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_353)>>>>> == false);
const float * & fn_354(const int &, volatile int &, const volatile int &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_354)>>>>::result_type, const float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_354)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_354)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_354)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_354)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_354)>>>>>::arg0_type, const int &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_354)>>>>>::arg_type<0>, const int &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_354)>>>>>::arg1_type, volatile int &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_354)>>>>::arg_type<1>, volatile int &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_354)>>>>>::arg2_type, const volatile int &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_354)>>>>>::arg_type<2>, const volatile int &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_354)>>>>>::arity == 3);
static_assert(callable_traits<decltype(fn_354)>::is_functor == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_354)>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_354)>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_354)>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_354)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_354)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_354)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_354)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_354)>>>> == false);
volatile float * & fn_355(int * &, const int * &, volatile int * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_355)>>>>::result_type, volatile float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_355)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_355)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_355)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_355)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_355)>>>>::arg0_type, int * &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_355)>>>>::arg_type<0>, int * &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_355)>>>::arg1_type, const int * &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_355)>>>>::arg_type<1>, const int * &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_355)>>>>::arg2_type, volatile int * &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_355)>>>>::arg_type<2>, volatile int * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_355)>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_355)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_355)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_355)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_355)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_355)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_355)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_355)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_355)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_355)>>>>>> == false);
const volatile float * & fn_356(const volatile int * &, int * const &, const int * const &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_356)>>>>>::result_type, const volatile float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_356)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_356)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_356)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_356)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_356)>>>>>::arg0_type, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_356)>>>>::arg_type<0>, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_356)>>>>>::arg1_type, int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_356)>>>>>::arg_type<1>, int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_356)>>>>>::arg2_type, const int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_356)>>::arg_type<2>, const int * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_356)>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_356)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_356)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_356)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_356)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_356)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_356)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_356)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_356)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_356)>>>>>> == false);
float * const & fn_357(volatile int * const &, const volatile int * const &, int * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_357)>>>>>::result_type, float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_357)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_357)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_357)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_357)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_357)>>>>::arg0_type, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_357)>>>>>::arg_type<0>, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_357)>>>>>::arg1_type, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_357)>>>>>::arg_type<1>, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(fn_357)>::arg2_type, int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_357)>>::arg_type<2>, int * volatile &>);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_357)>>::arity == 3);
static_assert(callable_traits<std::add_cv_t<decltype(fn_357)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_357)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_357)>>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_357)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_357)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_357)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_357)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_357)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_357)>>>>> == false);
const float * const & fn_358(const int * volatile &, volatile int * volatile &, const volatile int * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_358)>>>::result_type, const float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_358)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_358)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_358)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_358)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_358)>>>>::arg0_type, const int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_358)>>>>::arg_type<0>, const int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_358)>>>>::arg1_type, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_358)>>::arg_type<1>, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_358)>>>::arg2_type, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_358)>>>::arg_type<2>, const volatile int * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_358)>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_358)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_358)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_358)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_358)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_358)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_358)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_358)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_358)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_358)>>>>> == false);
volatile float * const & fn_359(int * const volatile &, const int * const volatile &, volatile int * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_359)>>>>>::result_type, volatile float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_359)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_359)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_359)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_359)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_359)>>>>>::arg0_type, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_359)>>>>>::arg_type<0>, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_359)>>::arg1_type, const int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_359)>>>::arg_type<1>, const int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_359)>>>::arg2_type, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_359)>>>::arg_type<2>, volatile int * const volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_359)>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_359)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_359)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_359)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_359)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_359)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_359)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_359)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_359)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_359)>>>>>> == false);
const volatile float * const & fn_360(const volatile int * const volatile &, int &&, const int &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_360)>>>>>::result_type, const volatile float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_360)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_360)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_360)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_360)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_360)>>>>>::arg0_type, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(fn_360)>::arg_type<0>, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_360)>>::arg1_type, int &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_360)>>::arg_type<1>, int &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_360)>>::arg2_type, const int &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_360)>>::arg_type<2>, const int &&>);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_360)>>>::arity == 3);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_360)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_360)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_360)>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_360)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_360)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_360)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_360)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_360)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_360)>>>>> == false);
float * volatile & fn_361(volatile int &&, const volatile int &&, int * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_361)>>>>::result_type, float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_361)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_361)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_361)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_361)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_361)>>::arg0_type, volatile int &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_361)>>>::arg_type<0>, volatile int &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_361)>>>::arg1_type, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_361)>>>::arg_type<1>, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_361)>>>::arg2_type, int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_361)>>>>::arg_type<2>, int * &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_361)>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_361)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_361)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_361)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_361)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_361)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_361)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_361)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_361)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_361)>>>>>> == false);
const float * volatile & fn_362(const int * &&, volatile int * &&, const volatile int * &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_362)>>>>::result_type, const float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_362)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_362)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_362)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_362)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_362)>>>::arg0_type, const int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_362)>>>::arg_type<0>, const int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_362)>>>::arg1_type, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_362)>>>::arg_type<1>, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_362)>>>>::arg2_type, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_362)>>>>::arg_type<2>, const volatile int * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_362)>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_362)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_362)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_362)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_362)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_362)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_362)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_362)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_362)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_362)>>>>> == false);
volatile float * volatile & fn_363(int * const &&, const int * const &&, volatile int * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_363)>>>>>::result_type, volatile float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_363)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_363)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(fn_363)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<decltype(fn_363)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_363)>>::arg0_type, int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_363)>>::arg_type<0>, int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_363)>>::arg1_type, const int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_363)>>>::arg_type<1>, const int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_363)>>>::arg2_type, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_363)>>>::arg_type<2>, volatile int * const &&>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_363)>>>::arity == 3);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_363)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_363)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_363)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_363)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_363)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_363)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_363)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_363)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_363)>>>>> == false);
const volatile float * volatile & fn_364(const volatile int * const &&, int * volatile &&, const int * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_364)>>>>::result_type, const volatile float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_364)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_364)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_364)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_364)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_364)>>>::arg0_type, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_364)>>>::arg_type<0>, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_364)>>>>::arg1_type, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_364)>>>>::arg_type<1>, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_364)>>>>::arg2_type, const int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_364)>>>>::arg_type<2>, const int * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_364)>>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_364)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_364)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_364)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_364)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_364)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_364)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_364)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_364)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_364)>>>>>> == false);
float * const volatile & fn_365(volatile int * volatile &&, const volatile int * volatile &&, int * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_365)>>>>>::result_type, float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_365)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_365)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_365)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_365)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_365)>>>::arg0_type, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_365)>>>>::arg_type<0>, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_365)>>>>::arg1_type, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_365)>>>>::arg_type<1>, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_365)>>>>::arg2_type, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_365)>>>>>::arg_type<2>, int * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_365)>>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_365)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_365)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_365)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_365)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_365)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_365)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_365)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_365)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_365)>>>>>> == false);
const float * const volatile & fn_366(const int * const volatile &&, volatile int * const volatile &&, const volatile int * const volatile &&);
static_assert(std::is_same_v<callable_traits<decltype(fn_366)>::result_type, const float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<decltype(fn_366)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<decltype(fn_366)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<decltype(fn_366)>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<decltype(fn_366)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_366)>>>::arg0_type, const int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_366)>>>::arg_type<0>, const int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_366)>>>::arg1_type, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_366)>>>::arg_type<1>, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_366)>>>>::arg2_type, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_366)>>>>::arg_type<2>, const volatile int * const volatile &&>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_366)>>>>::arity == 3);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_366)>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_366)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_366)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_366)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_366)>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_366)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_366)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_366)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_366)>>> == false);
volatile float * const volatile & fn_367(float, float *, const float *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_367)>>>::result_type, volatile float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_367)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_367)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_367)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_367)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_367)>>>>::arg0_type, float>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_367)>>>>::arg_type<0>, float>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_367)>>>>::arg1_type, float *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_367)>>>>>::arg_type<1>, float *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_367)>>>>>::arg2_type, const float *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_367)>>>>>::arg_type<2>, const float *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_367)>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_367)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_367)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_367)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_367)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_367)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_367)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_367)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_367)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_367)>>>> == false);
const volatile float * const volatile & fn_368(volatile float *, const volatile float *, float &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_368)>>>::result_type, const volatile float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_368)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_368)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_368)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_368)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_368)>>>>::arg0_type, volatile float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_368)>>>>::arg_type<0>, volatile float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_368)>>>>>::arg1_type, const volatile float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_368)>>>>>::arg_type<1>, const volatile float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_368)>>>>>::arg2_type, float &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_368)>>>>::arg_type<2>, float &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_368)>>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_368)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_368)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_368)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_368)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_368)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_368)>>>>>::is_volatile == false);
static_assert(callable_traits<decltype(fn_368)>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_368)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<decltype(fn_368)>>> == false);
float && fn_369(const float &, volatile float &, const volatile float &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_369)>>::result_type, float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<decltype(fn_369)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_369)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_369)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_369)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_369)>>>::arg0_type, const float &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_369)>>>>::arg_type<0>, const float &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_369)>>>>::arg1_type, volatile float &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_369)>>>>::arg_type<1>, volatile float &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_369)>>>::arg2_type, const volatile float &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_369)>>>>::arg_type<2>, const volatile float &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_369)>>>>::arity == 3);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_369)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_369)>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_369)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_369)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_369)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_369)>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_369)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_369)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_369)>>>> == false);
const float && fn_370(float * &, const float * &, volatile float * &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_370)>>>::result_type, const float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_370)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_370)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_370)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_370)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_370)>>>>>::arg0_type, float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_370)>>>>>::arg_type<0>, float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_370)>>>>>::arg1_type, const float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_370)>>>>::arg_type<1>, const float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_370)>>>>>::arg2_type, volatile float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_370)>>>>>::arg_type<2>, volatile float * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_370)>>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_370)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_370)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_370)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_370)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_370)>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_370)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_370)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_370)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_370)>>>> == false);
volatile float && fn_371(const volatile float * &, float * const &, const float * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_371)>>>>::result_type, volatile float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_371)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_371)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_371)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_371)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_371)>>>>>::arg0_type, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_371)>>>>>::arg_type<0>, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_371)>>>>::arg1_type, float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_371)>>>>>::arg_type<1>, float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_371)>>>>>::arg2_type, const float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_371)>>>>>::arg_type<2>, const float * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_371)>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_371)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_371)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_371)>>>>>::is_variadic == true);
static_assert(callable_traits<decltype(fn_371)>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<decltype(fn_371)>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_371)>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_371)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_371)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_371)>>>> == false);
const volatile float && fn_372(volatile float * const &, const volatile float * const &, float * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_372)>>>::result_type, const volatile float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_372)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_372)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_372)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_372)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_372)>>>>::arg0_type, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_372)>>>::arg_type<0>, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_372)>>>>::arg1_type, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_372)>>>>::arg_type<1>, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_372)>>>>::arg2_type, float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_372)>>>::arg_type<2>, float * volatile &>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_372)>>>>::arity == 3);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_372)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_372)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_372)>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_372)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_372)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_372)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_372)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_372)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_372)>>>>> == false);
float * && fn_373(const float * volatile &, volatile float * volatile &, const volatile float * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_373)>>>>::result_type, float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_373)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_373)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_373)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_373)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_373)>>>>::arg0_type, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_373)>>>>>::arg_type<0>, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_373)>>>>>::arg1_type, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_373)>>>>>::arg_type<1>, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_373)>>>>::arg2_type, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_373)>>>>>::arg_type<2>, const volatile float * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_373)>>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_373)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_373)>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_373)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_373)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_373)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_373)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_373)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_373)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_373)>>>>> == false);
const float * && fn_374(float * const volatile &, const float * const volatile &, volatile float * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_374)>>>>::result_type, const float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_374)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_374)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_374)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_374)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_374)>>>>>::arg0_type, float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_374)>>>>>::arg_type<0>, float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_374)>>>>>::arg1_type, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_374)>>>>::arg_type<1>, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_374)>>>>>::arg2_type, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_374)>>>>>::arg_type<2>, volatile float * const volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_374)>>>>>::arity == 3);
static_assert(callable_traits<decltype(fn_374)>::is_functor == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_374)>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_374)>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_374)>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_374)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_374)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_374)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_374)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_374)>>>> == false);
volatile float * && fn_375(const volatile float * const volatile &, float &&, const float &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_375)>>>>::result_type, volatile float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_375)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_375)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_375)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_375)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_375)>>>>::arg0_type, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_375)>>>>::arg_type<0>, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_375)>>>::arg1_type, float &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_375)>>>>::arg_type<1>, float &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_375)>>>>::arg2_type, const float &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_375)>>>>::arg_type<2>, const float &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_375)>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_375)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_375)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_375)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_375)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_375)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_375)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_375)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_375)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_375)>>>>>> == false);
const volatile float * && fn_376(volatile float &&, const volatile float &&, float * &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_376)>>>>>::result_type, const volatile float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_376)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_376)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_376)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_376)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_376)>>>>>::arg0_type, volatile float &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_376)>>>>::arg_type<0>, volatile float &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_376)>>>>>::arg1_type, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_376)>>>>>::arg_type<1>, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_376)>>>>>::arg2_type, float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_376)>>::arg_type<2>, float * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_376)>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_376)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_376)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_376)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_376)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_376)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_376)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_376)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_376)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_376)>>>>>> == false);
float * const && fn_377(const float * &&, volatile float * &&, const volatile float * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_377)>>>>>::result_type, float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_377)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_377)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_377)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_377)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_377)>>>>::arg0_type, const float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_377)>>>>>::arg_type<0>, const float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_377)>>>>>::arg1_type, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_377)>>>>>::arg_type<1>, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(fn_377)>::arg2_type, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_377)>>::arg_type<2>, const volatile float * &&>);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_377)>>::arity == 3);
static_assert(callable_traits<std::add_cv_t<decltype(fn_377)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_377)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_377)>>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_377)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_377)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_377)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_377)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_377)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_377)>>>>> == false);
const float * const && fn_378(float * const &&, const float * const &&, volatile float * const &&);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_378)>>>::result_type, const float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_378)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_378)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_378)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_378)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_378)>>>>::arg0_type, float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_378)>>>>::arg_type<0>, float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_378)>>>>::arg1_type, const float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_378)>>::arg_type<1>, const float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_378)>>>::arg2_type, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_378)>>>::arg_type<2>, volatile float * const &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_378)>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_378)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_378)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_378)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_378)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_378)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_378)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_378)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_378)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_378)>>>>> == false);
volatile float * const && fn_379(const volatile float * const &&, float * volatile &&, const float * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_379)>>>>>::result_type, volatile float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_379)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_379)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_379)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_379)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_379)>>>>>::arg0_type, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_379)>>>>>::arg_type<0>, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_379)>>::arg1_type, float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_379)>>>::arg_type<1>, float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_379)>>>::arg2_type, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_379)>>>::arg_type<2>, const float * volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_379)>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_379)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_379)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_379)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_379)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_379)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_379)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_379)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_379)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_379)>>>>>> == false);
const volatile float * const && fn_380(volatile float * volatile &&, const volatile float * volatile &&, float * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_380)>>>>>::result_type, const volatile float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_380)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_380)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_380)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_380)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_380)>>>>>::arg0_type, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(fn_380)>::arg_type<0>, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_380)>>::arg1_type, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_380)>>::arg_type<1>, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_380)>>::arg2_type, float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_380)>>::arg_type<2>, float * const volatile &&>);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_380)>>>::arity == 3);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_380)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_380)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_380)>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_380)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_380)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_380)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_380)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_380)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_380)>>>>> == false);
float * volatile && fn_381(const float * const volatile &&, volatile float * const volatile &&, const volatile float * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_381)>>>>::result_type, float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_381)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_381)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_381)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_381)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_381)>>::arg0_type, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_381)>>>::arg_type<0>, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_381)>>>::arg1_type, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_381)>>>::arg_type<1>, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_381)>>>::arg2_type, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_381)>>>>::arg_type<2>, const volatile float * const volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_381)>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_381)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_381)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_381)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_381)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_381)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_381)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_381)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_381)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_381)>>>>>> == false);
const float * volatile && fn_382(std::string, std::string *, const std::string *);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_382)>>>>::result_type, const float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_382)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_382)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_382)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_382)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_382)>>>::arg0_type, std::string>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_382)>>>::arg_type<0>, std::string>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_382)>>>::arg1_type, std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_382)>>>::arg_type<1>, std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_382)>>>>::arg2_type, const std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_382)>>>>::arg_type<2>, const std::string *>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_382)>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_382)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_382)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_382)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_382)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_382)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_382)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_382)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_382)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_382)>>>>> == false);
volatile float * volatile && fn_383(volatile std::string *, const volatile std::string *, std::string &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_383)>>>>>::result_type, volatile float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_383)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_383)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(fn_383)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<decltype(fn_383)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_383)>>::arg0_type, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_383)>>::arg_type<0>, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_383)>>::arg1_type, const volatile std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_383)>>>::arg_type<1>, const volatile std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_383)>>>::arg2_type, std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_383)>>>::arg_type<2>, std::string &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_383)>>>::arity == 3);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_383)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_383)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_383)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_383)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_383)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_383)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_383)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_383)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_383)>>>>> == false);
const volatile float * volatile && fn_384(const std::string &, volatile std::string &, const volatile std::string &);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_384)>>>>::result_type, const volatile float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_384)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_384)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_384)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_384)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_384)>>>::arg0_type, const std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_384)>>>::arg_type<0>, const std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_384)>>>>::arg1_type, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_384)>>>>::arg_type<1>, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_384)>>>>::arg2_type, const volatile std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_384)>>>>::arg_type<2>, const volatile std::string &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_384)>>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_384)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_384)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_384)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_384)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_384)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_384)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_384)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_384)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_384)>>>>>> == false);
float * const volatile && fn_385(std::string * &, const std::string * &, volatile std::string * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_385)>>>>>::result_type, float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_385)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_385)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_385)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_385)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_385)>>>::arg0_type, std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_385)>>>>::arg_type<0>, std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_385)>>>>::arg1_type, const std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_385)>>>>::arg_type<1>, const std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_385)>>>>::arg2_type, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_385)>>>>>::arg_type<2>, volatile std::string * &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_385)>>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_385)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_385)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_385)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_385)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_385)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_385)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_385)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_385)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_385)>>>>>> == false);
const float * const volatile && fn_386(const volatile std::string * &, std::string * const &, const std::string * const &);
static_assert(std::is_same_v<callable_traits<decltype(fn_386)>::result_type, const float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<decltype(fn_386)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<decltype(fn_386)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<decltype(fn_386)>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<decltype(fn_386)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_386)>>>::arg0_type, const volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_386)>>>::arg_type<0>, const volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_386)>>>::arg1_type, std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_386)>>>::arg_type<1>, std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_386)>>>>::arg2_type, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_386)>>>>::arg_type<2>, const std::string * const &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_386)>>>>::arity == 3);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_386)>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_386)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_386)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_386)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_386)>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_386)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_386)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_386)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_386)>>> == false);
volatile float * const volatile && fn_387(volatile std::string * const &, const volatile std::string * const &, std::string * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_387)>>>::result_type, volatile float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_387)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_387)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_387)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_387)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_387)>>>>::arg0_type, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_387)>>>>::arg_type<0>, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_387)>>>>::arg1_type, const volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_387)>>>>>::arg_type<1>, const volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_387)>>>>>::arg2_type, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_387)>>>>>::arg_type<2>, std::string * volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_387)>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_387)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_387)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_387)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_387)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_387)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_387)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_387)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_387)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_387)>>>> == false);
const volatile float * const volatile && fn_388(const std::string * volatile &, volatile std::string * volatile &, const volatile std::string * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_388)>>>::result_type, const volatile float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_388)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_388)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_388)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_388)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_388)>>>>::arg0_type, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_388)>>>>::arg_type<0>, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_388)>>>>>::arg1_type, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_388)>>>>>::arg_type<1>, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_388)>>>>>::arg2_type, const volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_388)>>>>::arg_type<2>, const volatile std::string * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_388)>>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_388)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_388)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_388)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_388)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_388)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_388)>>>>>::is_volatile == false);
static_assert(callable_traits<decltype(fn_388)>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_388)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<decltype(fn_388)>>> == false);
std::string fn_389(std::string * const volatile &, const std::string * const volatile &, volatile std::string * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_389)>>::result_type, std::string>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<decltype(fn_389)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_389)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_389)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_389)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_389)>>>::arg0_type, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_389)>>>>::arg_type<0>, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_389)>>>>::arg1_type, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_389)>>>>::arg_type<1>, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_389)>>>::arg2_type, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_389)>>>>::arg_type<2>, volatile std::string * const volatile &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_389)>>>>::arity == 3);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_389)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_389)>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_389)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_389)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_389)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_389)>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_389)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_389)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_389)>>>> == false);
std::string * fn_390(const volatile std::string * const volatile &, std::string &&, const std::string &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_390)>>>::result_type, std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_390)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_390)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_390)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_390)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_390)>>>>>::arg0_type, const volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_390)>>>>>::arg_type<0>, const volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_390)>>>>>::arg1_type, std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_390)>>>>::arg_type<1>, std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_390)>>>>>::arg2_type, const std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_390)>>>>>::arg_type<2>, const std::string &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_390)>>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_390)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_390)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_390)>>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_390)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_390)>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_390)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_390)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_390)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_390)>>>> == false);
const std::string * fn_391(volatile std::string &&, const volatile std::string &&, std::string * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_391)>>>>::result_type, const std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_391)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_391)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_391)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_391)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_391)>>>>>::arg0_type, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_391)>>>>>::arg_type<0>, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_391)>>>>::arg1_type, const volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_391)>>>>>::arg_type<1>, const volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_391)>>>>>::arg2_type, std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_391)>>>>>::arg_type<2>, std::string * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_391)>>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_391)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_391)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_391)>>>>>::is_variadic == true);
static_assert(callable_traits<decltype(fn_391)>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<decltype(fn_391)>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_391)>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_391)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_391)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_391)>>>> == false);
volatile std::string * fn_392(const std::string * &&, volatile std::string * &&, const volatile std::string * &&);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_392)>>>::result_type, volatile std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_392)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_392)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_392)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_392)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_392)>>>>::arg0_type, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_392)>>>::arg_type<0>, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_392)>>>>::arg1_type, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_392)>>>>::arg_type<1>, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_392)>>>>::arg2_type, const volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_392)>>>::arg_type<2>, const volatile std::string * &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_392)>>>>::arity == 3);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_392)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_392)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_392)>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_392)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_392)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_392)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_392)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_392)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_392)>>>>> == false);
const volatile std::string * fn_393(std::string * const &&, const std::string * const &&, volatile std::string * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_393)>>>>::result_type, const volatile std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_393)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_393)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_393)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_393)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_393)>>>>::arg0_type, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_393)>>>>>::arg_type<0>, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_393)>>>>>::arg1_type, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_393)>>>>>::arg_type<1>, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_393)>>>>::arg2_type, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_393)>>>>>::arg_type<2>, volatile std::string * const &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_393)>>>>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_393)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_393)>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_393)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_393)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_393)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_393)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_393)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_393)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_393)>>>>> == false);
std::string & fn_394(const volatile std::string * const &&, std::string * volatile &&, const std::string * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_394)>>>>::result_type, std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_394)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_394)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_394)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_394)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_394)>>>>>::arg0_type, const volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_394)>>>>>::arg_type<0>, const volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_394)>>>>>::arg1_type, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_394)>>>>::arg_type<1>, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_394)>>>>>::arg2_type, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_394)>>>>>::arg_type<2>, const std::string * volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_394)>>>>>::arity == 3);
static_assert(callable_traits<decltype(fn_394)>::is_functor == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_394)>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_394)>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_394)>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_394)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_394)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_394)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_394)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_394)>>>> == false);
const std::string & fn_395(volatile std::string * volatile &&, const volatile std::string * volatile &&, std::string * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_395)>>>>::result_type, const std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_395)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_395)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_395)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_395)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_395)>>>>::arg0_type, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_395)>>>>::arg_type<0>, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_395)>>>::arg1_type, const volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_395)>>>>::arg_type<1>, const volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_395)>>>>::arg2_type, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_395)>>>>::arg_type<2>, std::string * const volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_395)>>::arity == 3);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_395)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_395)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_395)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_395)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_395)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_395)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_395)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_395)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_395)>>>>>> == false);
volatile std::string & fn_396(const std::string * const volatile &&, volatile std::string * const volatile &&, const volatile std::string * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_396)>>>>>::result_type, volatile std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_396)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_396)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_396)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_396)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_396)>>>>>::arg0_type, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_396)>>>>::arg_type<0>, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_396)>>>>>::arg1_type, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_396)>>>>>::arg_type<1>, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_396)>>>>>::arg2_type, const volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_396)>>::arg_type<2>, const volatile std::string * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_396)>>>::arity == 3);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_396)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_396)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_396)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_396)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_396)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_396)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_396)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_396)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_396)>>>>>> == false);
const volatile std::string & fn_397(void *, const void *, volatile void *, const volatile void *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_397)>>>>>::result_type, const volatile std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_397)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_397)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_397)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_397)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_397)>>>>::arg0_type, void *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_397)>>>>>::arg_type<0>, void *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_397)>>>>>::arg1_type, const void *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_397)>>>>>::arg_type<1>, const void *>);
static_assert(std::is_same_v<callable_traits<decltype(fn_397)>::arg2_type, volatile void *>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_397)>>::arg_type<2>, volatile void *>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_397)>>::arg_type<3>, const volatile void *>);
static_assert(callable_traits<std::add_cv_t<decltype(fn_397)>>::arity == 4);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_397)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_397)>>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_397)>>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_397)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_397)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_397)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_397)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_397)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_397)>>>> == false);
std::string * & fn_398(void * &, const void * &, volatile void * &, const volatile void * &);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_398)>>>>::result_type, std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_398)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_398)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_398)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_398)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_398)>>>>::arg0_type, void * &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_398)>>>>::arg_type<0>, void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_398)>>::arg1_type, const void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_398)>>>::arg_type<1>, const void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_398)>>>::arg2_type, volatile void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_398)>>>::arg_type<2>, volatile void * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_398)>>>::arg_type<3>, const volatile void * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_398)>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_398)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_398)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_398)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_398)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_398)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_398)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_398)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_398)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_398)>>>>>> == false);
const std::string * & fn_399(void * const &, const void * const &, volatile void * const &, const volatile void * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_399)>>>>>::result_type, const std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_399)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_399)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_399)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_399)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_399)>>::arg0_type, void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_399)>>>::arg_type<0>, void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_399)>>>::arg1_type, const void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_399)>>>::arg_type<1>, const void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_399)>>>::arg2_type, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_399)>>>>::arg_type<2>, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_399)>>>>::arg_type<3>, const volatile void * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_399)>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_399)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_399)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_399)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_399)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_399)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_399)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_399)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_399)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_399)>>>>> == false);
volatile std::string * & fn_400(void * volatile &, const void * volatile &, volatile void * volatile &, const volatile void * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_400)>>>>>::result_type, volatile std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_400)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_400)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(fn_400)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<decltype(fn_400)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_400)>>::arg0_type, void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_400)>>::arg_type<0>, void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_400)>>::arg1_type, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_400)>>>::arg_type<1>, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_400)>>>::arg2_type, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_400)>>>::arg_type<2>, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_400)>>>::arg_type<3>, const volatile void * volatile &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_400)>>>>::arity == 4);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_400)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_400)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_400)>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_400)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_400)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_400)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_400)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_400)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_400)>>>>> == false);
const volatile std::string * & fn_401(void * const volatile &, const void * const volatile &, volatile void * const volatile &, const volatile void * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_401)>>>>::result_type, const volatile std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_401)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_401)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_401)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_401)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_401)>>>::arg0_type, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_401)>>>>::arg_type<0>, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_401)>>>>::arg1_type, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_401)>>>>::arg_type<1>, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_401)>>>>::arg2_type, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_401)>>>>>::arg_type<2>, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_401)>>>>>::arg_type<3>, const volatile void * const volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_401)>>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_401)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_401)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_401)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_401)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_401)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_401)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_401)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_401)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_401)>>> == false);
std::string * const & fn_402(void * &&, const void * &&, volatile void * &&, const volatile void * &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_402)>>>::result_type, std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_402)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_402)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_402)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_402)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_402)>>>>::arg0_type, void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_402)>>>>::arg_type<0>, void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_402)>>>>::arg1_type, const void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_402)>>>>>::arg_type<1>, const void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_402)>>>>>::arg2_type, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_402)>>>>>::arg_type<2>, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_402)>>>>::arg_type<3>, const volatile void * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_402)>>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_402)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_402)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_402)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_402)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_402)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_402)>>>>>::is_volatile == false);
static_assert(callable_traits<decltype(fn_402)>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_402)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<decltype(fn_402)>>> == false);
const std::string * const & fn_403(void * const &&, const void * const &&, volatile void * const &&, const volatile void * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_403)>>::result_type, const std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<decltype(fn_403)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_403)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_403)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_403)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_403)>>>::arg0_type, void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_403)>>>>::arg_type<0>, void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_403)>>>>::arg1_type, const void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_403)>>>>::arg_type<1>, const void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_403)>>>::arg2_type, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_403)>>>>::arg_type<2>, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_403)>>>>::arg_type<3>, const volatile void * const &&>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_403)>>>>::arity == 4);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_403)>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_403)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_403)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_403)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_403)>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_403)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_403)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_403)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_403)>>>> == false);
volatile std::string * const & fn_404(void * volatile &&, const void * volatile &&, volatile void * volatile &&, const volatile void * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_404)>>>>::result_type, volatile std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_404)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_404)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_404)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_404)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_404)>>>>>::arg0_type, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_404)>>>>>::arg_type<0>, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_404)>>>>::arg1_type, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_404)>>>>>::arg_type<1>, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_404)>>>>>::arg2_type, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_404)>>>>>::arg_type<2>, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_404)>>>>::arg_type<3>, const volatile void * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_404)>>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_404)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_404)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_404)>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_404)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_404)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_404)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_404)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_404)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_404)>>>>> == false);
const volatile std::string * const & fn_405(void * const volatile &&, const void * const volatile &&, volatile void * const volatile &&, const volatile void * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_405)>>>>::result_type, const volatile std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_405)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_405)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_405)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_405)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_405)>>>>::arg0_type, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_405)>>>>>::arg_type<0>, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_405)>>>>>::arg1_type, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_405)>>>>>::arg_type<1>, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_405)>>>>::arg2_type, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_405)>>>>>::arg_type<2>, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_405)>>>>>::arg_type<3>, const volatile void * const volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_405)>>>>>::arity == 4);
static_assert(callable_traits<decltype(fn_405)>::is_functor == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_405)>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_405)>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<decltype(fn_405)>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_405)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_405)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_405)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_405)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_405)>>>> == false);
std::string * volatile & fn_406(bool, bool *, const bool *, volatile bool *);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_406)>>>>::result_type, std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_406)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_406)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_406)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_406)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_406)>>>>::arg0_type, bool>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_406)>>>>::arg_type<0>, bool>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_406)>>>::arg1_type, bool *>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_406)>>>>::arg_type<1>, bool *>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_406)>>>>::arg2_type, const bool *>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_406)>>>>::arg_type<2>, const bool *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_406)>>::arg_type<3>, volatile bool *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_406)>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_406)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_406)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_406)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_406)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_406)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_406)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_406)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_406)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_406)>>>>>> == false);
const std::string * volatile & fn_407(const volatile bool *, bool &, const bool &, volatile bool &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_407)>>>>>::result_type, const std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_407)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_407)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_407)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_407)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_407)>>>>::arg0_type, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_407)>>>>>::arg_type<0>, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_407)>>>>>::arg1_type, bool &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_407)>>>>>::arg_type<1>, bool &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_407)>>::arg2_type, const bool &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_407)>>>::arg_type<2>, const bool &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_407)>>>::arg_type<3>, volatile bool &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_407)>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_407)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_407)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_407)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_407)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_407)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_407)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_407)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_407)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_407)>>>>> == false);
volatile std::string * volatile & fn_408(const volatile bool &, bool * &, const bool * &, volatile bool * &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_408)>>>>>::result_type, volatile std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_408)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_408)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_408)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_408)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_408)>>>>>::arg0_type, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_408)>>>>>::arg_type<0>, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(fn_408)>::arg1_type, bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_408)>>::arg_type<1>, bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_408)>>::arg2_type, const bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_408)>>::arg_type<2>, const bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_408)>>::arg_type<3>, volatile bool * &>);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_408)>>>::arity == 4);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_408)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_408)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_408)>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_408)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_408)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_408)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_408)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_408)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_408)>>>>> == false);
const volatile std::string * volatile & fn_409(const volatile bool * &, bool * const &, const bool * const &, volatile bool * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_409)>>>>::result_type, const volatile std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_409)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_409)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_409)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_409)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_409)>>::arg0_type, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_409)>>>::arg_type<0>, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_409)>>>::arg1_type, bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_409)>>>::arg_type<1>, bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_409)>>>::arg2_type, const bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_409)>>>>::arg_type<2>, const bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_409)>>>>::arg_type<3>, volatile bool * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_409)>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_409)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_409)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_409)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_409)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_409)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_409)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_409)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_409)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_409)>>>>> == false);
std::string * const volatile & fn_410(const volatile bool * const &, bool * volatile &, const bool * volatile &, volatile bool * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_410)>>>>>::result_type, std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_410)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_410)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_410)>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_410)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_410)>>>::arg0_type, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_410)>>>::arg_type<0>, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_410)>>>::arg1_type, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_410)>>>>::arg_type<1>, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_410)>>>>::arg2_type, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_410)>>>>::arg_type<2>, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_410)>>>>::arg_type<3>, volatile bool * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_410)>>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_410)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_410)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_410)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_410)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_410)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_410)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_410)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_410)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_410)>>>>>> == false);
const std::string * const volatile & fn_411(const volatile bool * volatile &, bool * const volatile &, const bool * const volatile &, volatile bool * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_411)>>>>>::result_type, const std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(fn_411)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<decltype(fn_411)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<decltype(fn_411)>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<decltype(fn_411)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_411)>>::arg0_type, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_411)>>>::arg_type<0>, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_411)>>>::arg1_type, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_411)>>>::arg_type<1>, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_411)>>>::arg2_type, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_411)>>>>::arg_type<2>, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_411)>>>>::arg_type<3>, volatile bool * const volatile &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_411)>>>>::arity == 4);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_411)>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_411)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_411)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_411)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_411)>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_411)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_411)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_411)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_411)>>> == false);
volatile std::string * const volatile & fn_412(const volatile bool * const volatile &, bool &&, const bool &&, volatile bool &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_412)>>>::result_type, volatile std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_412)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_412)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_412)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_412)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_412)>>>>::arg0_type, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_412)>>>>::arg_type<0>, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_412)>>>>::arg1_type, bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_412)>>>>>::arg_type<1>, bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_412)>>>>>::arg2_type, const bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_412)>>>>>::arg_type<2>, const bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_412)>>>>::arg_type<3>, volatile bool &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_412)>>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_412)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_412)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_412)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_412)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_412)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_412)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_412)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_412)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_412)>>>> == false);
const volatile std::string * const volatile & fn_413(const volatile bool &&, bool * &&, const bool * &&, volatile bool * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_413)>>>::result_type, const volatile std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_413)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_413)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_413)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_413)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_413)>>>>::arg0_type, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_413)>>>>>::arg_type<0>, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_413)>>>>>::arg1_type, bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_413)>>>>>::arg_type<1>, bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_413)>>>>::arg2_type, const bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_413)>>>>>::arg_type<2>, const bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_413)>>>>>::arg_type<3>, volatile bool * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_413)>>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_413)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_413)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_413)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_413)>>>>>::is_noexcept == true);
static_assert(callable_traits<decltype(fn_413)>::is_const == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_413)>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_413)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_413)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<decltype(fn_413)>>> == false);
std::string && fn_414(const volatile bool * &&, bool * const &&, const bool * const &&, volatile bool * const &&);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_414)>>>::result_type, std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_414)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_414)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_414)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_414)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_414)>>>>::arg0_type, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_414)>>>>::arg_type<0>, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_414)>>>::arg1_type, bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_414)>>>>::arg_type<1>, bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_414)>>>>::arg2_type, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_414)>>>>::arg_type<2>, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_414)>>>::arg_type<3>, volatile bool * const &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_414)>>>>::arity == 4);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_414)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_414)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_414)>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_414)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_414)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_414)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_414)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_414)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_414)>>>>> == false);
const std::string && fn_415(const volatile bool * const &&, bool * volatile &&, const bool * volatile &&, volatile bool * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_415)>>>>::result_type, const std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_415)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_415)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_415)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_415)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_415)>>>>::arg0_type, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_415)>>>>>::arg_type<0>, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_415)>>>>>::arg1_type, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_415)>>>>>::arg_type<1>, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_415)>>>>::arg2_type, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_415)>>>>>::arg_type<2>, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_415)>>>>>::arg_type<3>, volatile bool * volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_415)>>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_415)>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_415)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_415)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_415)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_415)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_415)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_415)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_415)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_415)>>>>> == false);
volatile std::string && fn_416(const volatile bool * volatile &&, bool * const volatile &&, const bool * const volatile &&, volatile bool * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_416)>>>>>::result_type, volatile std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_416)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_416)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_416)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_416)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_416)>>>>>::arg0_type, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_416)>>>>>::arg_type<0>, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_416)>>>>::arg1_type, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_416)>>>>>::arg_type<1>, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_416)>>>>>::arg2_type, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_416)>>>>>::arg_type<2>, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(fn_416)>::arg_type<3>, volatile bool * const volatile &&>);
static_assert(callable_traits<std::add_const_t<decltype(fn_416)>>::arity == 4);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_416)>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_416)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_416)>>::is_variadic == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_416)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_416)>>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_416)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_416)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_416)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_416)>>>>> == false);
const volatile std::string && fn_417(const volatile bool * const volatile &&, int, int *, const int *, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_417)>>>>::result_type, const volatile std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_417)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_417)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_417)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_417)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_417)>>>::arg0_type, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_417)>>>>::arg_type<0>, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_417)>>>>::arg1_type, int>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_417)>>>>::arg_type<1>, int>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_417)>>::arg2_type, int *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_417)>>>::arg_type<2>, int *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_417)>>>::arg_type<3>, const int *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_417)>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_417)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_417)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_417)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_417)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_417)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_417)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_417)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_417)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_417)>>>>> == false);
std::string * && fn_418(volatile int *, const volatile int *, int &, const int &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_418)>>>>>::result_type, std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_418)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_418)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_418)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_418)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_418)>>>>>::arg0_type, volatile int *>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_418)>>>>>::arg_type<0>, volatile int *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_418)>>::arg1_type, const volatile int *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_418)>>>::arg_type<1>, const volatile int *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_418)>>>::arg2_type, int &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_418)>>>::arg_type<2>, int &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_418)>>>::arg_type<3>, const int &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_418)>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_418)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_418)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_418)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_418)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_418)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_418)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_418)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_418)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_418)>>>>>> == false);
const std::string * && fn_419(volatile int &, const volatile int &, int * &, const int * &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_419)>>>>>::result_type, const std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_419)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_419)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_419)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_419)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<decltype(fn_419)>::arg0_type, volatile int &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_419)>>::arg_type<0>, volatile int &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_419)>>::arg1_type, const volatile int &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_419)>>::arg_type<1>, const volatile int &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_419)>>::arg2_type, int * &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_419)>>>::arg_type<2>, int * &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_419)>>>::arg_type<3>, const int * &>);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_419)>>>::arity == 4);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_419)>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_419)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_419)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_419)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_419)>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_419)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_419)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_419)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_419)>>>> == false);
volatile std::string * && fn_420(volatile int * &, const volatile int * &, int * const &, const int * const &);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_420)>>>>::result_type, volatile std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_420)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_420)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_420)>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_420)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_420)>>>::arg0_type, volatile int * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_420)>>>::arg_type<0>, volatile int * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_420)>>>::arg1_type, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_420)>>>>::arg_type<1>, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_420)>>>>::arg2_type, int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_420)>>>>::arg_type<2>, int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_420)>>>>::arg_type<3>, const int * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_420)>>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_420)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_420)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_420)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_420)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_420)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_420)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_420)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_420)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_420)>>>>>> == false);
const volatile std::string * && fn_421(volatile int * const &, const volatile int * const &, int * volatile &, const int * volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_421)>>>>>::result_type, const volatile std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_421)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_421)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_421)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_421)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_421)>>>::arg0_type, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_421)>>>>::arg_type<0>, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_421)>>>>::arg1_type, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_421)>>>>::arg_type<1>, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_421)>>>>::arg2_type, int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_421)>>>>>::arg_type<2>, int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_421)>>>>>::arg_type<3>, const int * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_421)>>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_421)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_421)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_421)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_421)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_421)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_421)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_421)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_421)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(fn_421)>> == false);
std::string * const && fn_422(volatile int * volatile &, const volatile int * volatile &, int * const volatile &, const int * const volatile &);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_422)>>::result_type, std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<decltype(fn_422)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<decltype(fn_422)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<decltype(fn_422)>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_422)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_422)>>>::arg0_type, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_422)>>>::arg_type<0>, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_422)>>>::arg1_type, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_422)>>>>::arg_type<1>, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_422)>>>>::arg2_type, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_422)>>>>::arg_type<2>, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_422)>>>::arg_type<3>, const int * const volatile &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_422)>>>>::arity == 4);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_422)>>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_422)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_422)>>>::is_variadic == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_422)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_422)>>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_422)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_422)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_422)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_422)>>>> == false);
const std::string * const && fn_423(volatile int * const volatile &, const volatile int * const volatile &, int &&, const int &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_423)>>>::result_type, const std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_423)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_423)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_423)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_423)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_423)>>>>::arg0_type, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_423)>>>>>::arg_type<0>, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_423)>>>>>::arg1_type, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_423)>>>>>::arg_type<1>, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_423)>>>>::arg2_type, int &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_423)>>>>>::arg_type<2>, int &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_423)>>>>>::arg_type<3>, const int &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_423)>>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_423)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_423)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_423)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_423)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_423)>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_423)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_423)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_423)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_423)>>>> == false);
volatile std::string * const && fn_424(volatile int &&, const volatile int &&, int * &&, const int * &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_424)>>>>::result_type, volatile std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_424)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_424)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_424)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_424)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_424)>>>>>::arg0_type, volatile int &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_424)>>>>>::arg_type<0>, volatile int &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_424)>>>>::arg1_type, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_424)>>>>>::arg_type<1>, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_424)>>>>>::arg2_type, int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_424)>>>>>::arg_type<2>, int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_424)>>>>::arg_type<3>, const int * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_424)>>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_424)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_424)>>>>>::is_member_function == false);
static_assert(callable_traits<decltype(fn_424)>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_424)>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_424)>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_424)>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_424)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_424)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_424)>>>> == false);
const volatile std::string * const && fn_425(volatile int * &&, const volatile int * &&, int * const &&, const int * const &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_425)>>>::result_type, const volatile std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_425)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_425)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_425)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_425)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_425)>>>::arg0_type, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_425)>>>>::arg_type<0>, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_425)>>>>::arg1_type, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_425)>>>>::arg_type<1>, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_425)>>>::arg2_type, int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_425)>>>>::arg_type<2>, int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_425)>>>>::arg_type<3>, const int * const &&>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_425)>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_425)>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_425)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_425)>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_425)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_425)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_425)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_425)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_425)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_425)>>>>> == false);
std::string * volatile && fn_426(volatile int * const &&, const volatile int * const &&, int * volatile &&, const int * volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_426)>>>>>::result_type, std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_426)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_426)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_426)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_426)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_426)>>>>>::arg0_type, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_426)>>>>>::arg_type<0>, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_426)>>>>::arg1_type, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_426)>>>>>::arg_type<1>, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_426)>>>>>::arg2_type, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_426)>>>>>::arg_type<2>, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_426)>>::arg_type<3>, const int * volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_426)>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_426)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_426)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_426)>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_426)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_426)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_426)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_426)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_426)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_426)>>>>>> == false);
const std::string * volatile && fn_427(volatile int * volatile &&, const volatile int * volatile &&, int * const volatile &&, const int * const volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_427)>>>>>::result_type, const std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_427)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_427)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_427)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_427)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_427)>>>>::arg0_type, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_427)>>>>>::arg_type<0>, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_427)>>>>>::arg1_type, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_427)>>>>>::arg_type<1>, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(fn_427)>::arg2_type, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_427)>>::arg_type<2>, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_427)>>::arg_type<3>, const int * const volatile &&>);
static_assert(callable_traits<std::add_cv_t<decltype(fn_427)>>::arity == 4);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_427)>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_427)>>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_427)>>>::is_variadic == true);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_427)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_427)>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_427)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_427)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_427)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_427)>>>> == false);
volatile std::string * volatile && fn_428(volatile int * const volatile &&, const volatile int * const volatile &&, float, float *);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_428)>>>>::result_type, volatile std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_428)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_428)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_428)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_428)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_428)>>>>::arg0_type, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_428)>>>>::arg_type<0>, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_428)>>::arg1_type, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_428)>>>::arg_type<1>, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_428)>>>::arg2_type, float>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_428)>>>::arg_type<2>, float>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_428)>>>::arg_type<3>, float *>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_428)>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_428)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_428)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_428)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_428)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_428)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_428)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_428)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_428)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_428)>>>>>> == false);
const volatile std::string * volatile && fn_429(const float *, volatile float *, const volatile float *, float &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_429)>>>>>::result_type, const volatile std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_429)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_429)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_429)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_429)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_429)>>::arg0_type, const float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_429)>>>::arg_type<0>, const float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_429)>>>::arg1_type, volatile float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_429)>>>::arg_type<1>, volatile float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_429)>>>::arg2_type, const volatile float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_429)>>>>::arg_type<2>, const volatile float *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_429)>>>>::arg_type<3>, float &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_429)>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_429)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_429)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_429)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_429)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_429)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_429)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_429)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_429)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_429)>>>>> == false);
std::string * const volatile && fn_430(const float &, volatile float &, const volatile float &, float * &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_430)>>>>>::result_type, std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_430)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_430)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(fn_430)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<decltype(fn_430)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_430)>>::arg0_type, const float &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_430)>>::arg_type<0>, const float &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_430)>>::arg1_type, volatile float &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_430)>>>::arg_type<1>, volatile float &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_430)>>>::arg2_type, const volatile float &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_430)>>>::arg_type<2>, const volatile float &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_430)>>>::arg_type<3>, float * &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_430)>>>>::arity == 4);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_430)>>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_430)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_430)>>>::is_variadic == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_430)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_430)>>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_430)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_430)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_430)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_430)>>>>> == false);
const std::string * const volatile && fn_431(const float * &, volatile float * &, const volatile float * &, float * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_431)>>>>::result_type, const std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_431)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_431)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_431)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_431)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_431)>>>::arg0_type, const float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_431)>>>>::arg_type<0>, const float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_431)>>>>::arg1_type, volatile float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_431)>>>>::arg_type<1>, volatile float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_431)>>>>::arg2_type, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_431)>>>>>::arg_type<2>, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_431)>>>>>::arg_type<3>, float * const &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_431)>>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_431)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_431)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_431)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_431)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_431)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_431)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_431)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_431)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_431)>>> == false);
volatile std::string * const volatile && fn_432(const float * const &, volatile float * const &, const volatile float * const &, float * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_432)>>>::result_type, volatile std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_432)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_432)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_432)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_432)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_432)>>>>::arg0_type, const float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_432)>>>>::arg_type<0>, const float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_432)>>>>::arg1_type, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_432)>>>>>::arg_type<1>, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_432)>>>>>::arg2_type, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_432)>>>>>::arg_type<2>, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_432)>>>>::arg_type<3>, float * volatile &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_432)>>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_432)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_432)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_432)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_432)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_432)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_432)>>>>>::is_volatile == false);
static_assert(callable_traits<decltype(fn_432)>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_432)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<decltype(fn_432)>>> == false);
const volatile std::string * const volatile && fn_433(const float * volatile &, volatile float * volatile &, const volatile float * volatile &, float * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_433)>>::result_type, const volatile std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<decltype(fn_433)>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_433)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_433)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_433)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_433)>>>::arg0_type, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_433)>>>>::arg_type<0>, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_433)>>>>::arg1_type, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_433)>>>>::arg_type<1>, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_433)>>>::arg2_type, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_433)>>>>::arg_type<2>, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_433)>>>>::arg_type<3>, float * const volatile &>);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_433)>>>>::arity == 4);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_433)>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_433)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_433)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_433)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_433)>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_433)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_433)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_433)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_433)>>>> == false);
void fn_434(const float * const volatile &, volatile float * const volatile &, const volatile float * const volatile &, float &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_434)>>>>::result_type, void>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_434)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_434)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_434)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_434)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_434)>>>>>::arg0_type, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_434)>>>>>::arg_type<0>, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_434)>>>>::arg1_type, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_434)>>>>>::arg_type<1>, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_434)>>>>>::arg2_type, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_434)>>>>>::arg_type<2>, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_434)>>>>::arg_type<3>, float &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_434)>>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_434)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_434)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_434)>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_434)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_434)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_434)>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_434)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_434)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_434)>>>>> == false);
void * fn_435(const float &&, volatile float &&, const volatile float &&, float * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_435)>>>>::result_type, void *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_435)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_435)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_435)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_435)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_435)>>>>::arg0_type, const float &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_435)>>>>>::arg_type<0>, const float &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_435)>>>>>::arg1_type, volatile float &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_435)>>>>>::arg_type<1>, volatile float &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_435)>>>>::arg2_type, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_435)>>>>>::arg_type<2>, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_435)>>>>>::arg_type<3>, float * &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_435)>>>>>::arity == 4);
static_assert(callable_traits<decltype(fn_435)>::is_functor == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_435)>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_435)>>::is_variadic == true);
static_assert(callable_traits<std::add_cv_t<decltype(fn_435)>>::is_noexcept == true);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_435)>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_435)>>>::is_volatile == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_435)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_435)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_435)>>>> == false);
const void * fn_436(const float * &&, volatile float * &&, const volatile float * &&, float * const &&);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_436)>>>>::result_type, const void *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_436)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_436)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_436)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_436)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_436)>>>>::arg0_type, const float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_436)>>>>::arg_type<0>, const float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_436)>>>::arg1_type, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_436)>>>>::arg_type<1>, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_436)>>>>::arg2_type, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_436)>>>>::arg_type<2>, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_436)>>::arg_type<3>, float * const &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_436)>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_436)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_436)>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_436)>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_436)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_436)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_436)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_436)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_436)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_436)>>>>>> == false);
volatile void * fn_437(const float * const &&, volatile float * const &&, const volatile float * const &&, float * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_437)>>>>>::result_type, volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_437)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_437)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_437)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_437)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_437)>>>>::arg0_type, const float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_437)>>>>>::arg_type<0>, const float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_437)>>>>>::arg1_type, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_437)>>>>>::arg_type<1>, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_437)>>::arg2_type, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_437)>>>::arg_type<2>, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_437)>>>::arg_type<3>, float * volatile &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_437)>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_437)>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_437)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_437)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_437)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_437)>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_437)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_437)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_437)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_437)>>>>> == false);
const volatile void * fn_438(const float * volatile &&, volatile float * volatile &&, const volatile float * volatile &&, float * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_438)>>>>>::result_type, const volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_438)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_438)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_438)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_438)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_438)>>>>>::arg0_type, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_438)>>>>>::arg_type<0>, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(fn_438)>::arg1_type, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_438)>>::arg_type<1>, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_438)>>::arg2_type, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_438)>>::arg_type<2>, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_438)>>::arg_type<3>, float * const volatile &&>);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_438)>>>::arity == 4);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_438)>>>::is_functor == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_438)>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_438)>>>::is_variadic == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_438)>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_438)>>>>::is_const == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_438)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_438)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_438)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_438)>>>>> == false);
void * & fn_439(const float * const volatile &&, volatile float * const volatile &&, const volatile float * const volatile &&, std::string, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_439)>>>>::result_type, void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_439)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_439)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_439)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_439)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_439)>>::arg0_type, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_439)>>>::arg_type<0>, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_439)>>>::arg1_type, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_439)>>>::arg_type<1>, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_439)>>>::arg2_type, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_439)>>>>::arg_type<2>, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_439)>>>>::arg_type<3>, std::string>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_439)>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_439)>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_439)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_439)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_439)>>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_439)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_439)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_439)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_439)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_439)>>>>> == false);
const void * & fn_440(std::string *, const std::string *, volatile std::string *, const volatile std::string *);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_440)>>>>>::result_type, const void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_440)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_440)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_440)>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_440)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_440)>>>::arg0_type, std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_440)>>>::arg_type<0>, std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_440)>>>::arg1_type, const std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_440)>>>>::arg_type<1>, const std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_440)>>>>::arg2_type, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_440)>>>>::arg_type<2>, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_440)>>>>::arg_type<3>, const volatile std::string *>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_440)>>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_440)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_440)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_440)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_440)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_440)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_440)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_440)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_440)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_440)>>>>>> == false);
volatile void * & fn_441(std::string &, const std::string &, volatile std::string &, const volatile std::string &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_441)>>>>>::result_type, volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(fn_441)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_const_t<decltype(fn_441)>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<decltype(fn_441)>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_cv_t<decltype(fn_441)>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_441)>>::arg0_type, std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_441)>>>::arg_type<0>, std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_441)>>>::arg1_type, const std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_441)>>>::arg_type<1>, const std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_441)>>>::arg2_type, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_441)>>>>::arg_type<2>, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_441)>>>>::arg_type<3>, const volatile std::string &>);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_441)>>>>::arity == 4);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_441)>>>::is_functor == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_441)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_441)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_441)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_441)>>>::is_const == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_441)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_441)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_441)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_441)>>> == false);
const volatile void * & fn_442(std::string * &, const std::string * &, volatile std::string * &, const volatile std::string * &);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_442)>>>::result_type, const volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_442)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_442)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_442)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_442)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_442)>>>>::arg0_type, std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_442)>>>>::arg_type<0>, std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_442)>>>>::arg1_type, const std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_442)>>>>>::arg_type<1>, const std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_442)>>>>>::arg2_type, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_442)>>>>>::arg_type<2>, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_442)>>>>::arg_type<3>, const volatile std::string * &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_442)>>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_442)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_442)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_442)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_442)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_442)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_442)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_442)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_442)>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_442)>>>> == false);
void * const & fn_443(std::string * const &, const std::string * const &, volatile std::string * const &, const volatile std::string * const &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_443)>>>::result_type, void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_443)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_443)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_443)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_443)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_443)>>>>::arg0_type, std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_443)>>>>>::arg_type<0>, std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_443)>>>>>::arg1_type, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_443)>>>>>::arg_type<1>, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_443)>>>>::arg2_type, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_443)>>>>>::arg_type<2>, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_443)>>>>>::arg_type<3>, const volatile std::string * const &>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_443)>>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_443)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_443)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_443)>>>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_443)>>>>>::is_noexcept == true);
static_assert(callable_traits<decltype(fn_443)>::is_const == false);
static_assert(callable_traits<std::add_const_t<decltype(fn_443)>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_443)>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_443)>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_pointer_t<decltype(fn_443)>>> == false);
const void * const & fn_444(std::string * volatile &, const std::string * volatile &, volatile std::string * volatile &, const volatile std::string * volatile &);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_444)>>>::result_type, const void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_444)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_444)>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_444)>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_444)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_444)>>>>::arg0_type, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_444)>>>>::arg_type<0>, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_444)>>>::arg1_type, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_444)>>>>::arg_type<1>, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_444)>>>>::arg2_type, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_444)>>>>::arg_type<2>, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_444)>>>::arg_type<3>, const volatile std::string * volatile &>);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_444)>>>>::arity == 4);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_444)>>>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_444)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<decltype(fn_444)>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_444)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_444)>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_444)>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_444)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_444)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_444)>>>>> == false);
volatile void * const & fn_445(std::string * const volatile &, const std::string * const volatile &, volatile std::string * const volatile &, const volatile std::string * const volatile &, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_445)>>>>::result_type, volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_445)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_445)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_445)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_445)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_445)>>>>::arg0_type, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_445)>>>>>::arg_type<0>, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_445)>>>>>::arg1_type, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_445)>>>>>::arg_type<1>, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_445)>>>>::arg2_type, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_445)>>>>>::arg_type<2>, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_445)>>>>>::arg_type<3>, const volatile std::string * const volatile &>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_445)>>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<decltype(fn_445)>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_445)>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_445)>>>::is_variadic == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_445)>>>::is_noexcept == true);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_445)>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_445)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_445)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_445)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_445)>>>>> == false);
const volatile void * const & fn_446(std::string &&, const std::string &&, volatile std::string &&, const volatile std::string &&);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_446)>>>>>::result_type, const volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_446)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_446)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_446)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_446)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_446)>>>>>::arg0_type, std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_446)>>>>>::arg_type<0>, std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_446)>>>>::arg1_type, const std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_446)>>>>>::arg_type<1>, const std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_446)>>>>>::arg2_type, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_446)>>>>>::arg_type<2>, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(fn_446)>::arg_type<3>, const volatile std::string &&>);
static_assert(callable_traits<std::add_const_t<decltype(fn_446)>>::arity == 4);
static_assert(callable_traits<std::add_volatile_t<decltype(fn_446)>>::is_functor == false);
static_assert(callable_traits<std::add_cv_t<decltype(fn_446)>>::is_member_function == false);
static_assert(callable_traits<std::add_pointer_t<decltype(fn_446)>>::is_variadic == false);
static_assert(callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_446)>>>::is_noexcept == false);
static_assert(callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_446)>>>::is_const == false);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_446)>>>::is_volatile == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_446)>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_446)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_446)>>>>> == false);
void * volatile & fn_447(std::string * &&, const std::string * &&, volatile std::string * &&, const volatile std::string * &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_447)>>>>::result_type, void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_447)>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_447)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_447)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_447)>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_447)>>>::arg0_type, std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_447)>>>>::arg_type<0>, std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_447)>>>>::arg1_type, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_447)>>>>::arg_type<1>, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_447)>>::arg2_type, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_447)>>>::arg_type<2>, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_447)>>>::arg_type<3>, const volatile std::string * &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_447)>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_447)>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_447)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_447)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_447)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_447)>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_447)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_447)>>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_447)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_447)>>>>> == false);
const void * volatile & fn_448(std::string * const &&, const std::string * const &&, volatile std::string * const &&, const volatile std::string * const &&);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_448)>>>>>::result_type, const void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_448)>>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_448)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_448)>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_448)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_448)>>>>>::arg0_type, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_448)>>>>>::arg_type<0>, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<decltype(fn_448)>>::arg1_type, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_const_t<decltype(fn_448)>>>::arg_type<1>, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<decltype(fn_448)>>>::arg2_type, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<decltype(fn_448)>>>::arg_type<2>, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<decltype(fn_448)>>>::arg_type<3>, const volatile std::string * const &&>);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_448)>>>>::arity == 4);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_448)>>>>::is_functor == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_448)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_448)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_448)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_448)>>>>>::is_const == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_448)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_448)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_448)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_448)>>>>>> == false);
volatile void * volatile & fn_449(std::string * volatile &&, const std::string * volatile &&, volatile std::string * volatile &&, const volatile std::string * volatile &&, ...) noexcept;
static_assert(std::is_same_v<callable_traits<std::add_rvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_449)>>>>>::result_type, volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_449)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_449)>>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_449)>>>>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_rvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_449)>>>>>> == false);
static_assert(std::is_same_v<callable_traits<decltype(fn_449)>::arg0_type, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_const_t<decltype(fn_449)>>::arg_type<0>, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_volatile_t<decltype(fn_449)>>::arg1_type, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<decltype(fn_449)>>::arg_type<1>, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<decltype(fn_449)>>::arg2_type, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_const_t<decltype(fn_449)>>>::arg_type<2>, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_pointer_t<std::add_volatile_t<decltype(fn_449)>>>::arg_type<3>, const volatile std::string * volatile &&>);
static_assert(callable_traits<std::add_pointer_t<std::add_cv_t<decltype(fn_449)>>>::arity == 4);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<decltype(fn_449)>>>::is_functor == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_449)>>>>::is_member_function == false);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_449)>>>>::is_variadic == true);
static_assert(callable_traits<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_449)>>>>::is_noexcept == true);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<decltype(fn_449)>>>::is_const == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_449)>>>>::is_volatile == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_449)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_449)>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<decltype(fn_449)>>>> == false);
const volatile void * volatile & fn_450(std::string * const volatile &&, const std::string * const volatile &&, volatile std::string * const volatile &&, const volatile std::string * const volatile &&);
static_assert(std::is_same_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_450)>>>>::result_type, const volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_450)>>>>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<std::add_cv_t<std::add_pointer_t<std::add_cv_t<decltype(fn_450)>>>>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<std::add_lvalue_reference_t<decltype(fn_450)>>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<decltype(fn_450)>>>> == false);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<decltype(fn_450)>>>::arg0_type, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<decltype(fn_450)>>>::arg_type<0>, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<decltype(fn_450)>>>::arg1_type, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_const_t<decltype(fn_450)>>>>::arg_type<1>, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_450)>>>>::arg2_type, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_pointer_t<std::add_cv_t<decltype(fn_450)>>>>::arg_type<2>, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<decltype(fn_450)>>>>::arg_type<3>, const volatile std::string * const volatile &&>);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_const_t<decltype(fn_450)>>>>>::arity == 4);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_450)>>>>>::is_functor == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_const_t<std::add_pointer_t<std::add_cv_t<decltype(fn_450)>>>>>::is_member_function == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<decltype(fn_450)>>>>::is_variadic == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_const_t<decltype(fn_450)>>>>>::is_noexcept == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_450)>>>>>::is_const == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_volatile_t<std::add_pointer_t<std::add_cv_t<decltype(fn_450)>>>>>::is_volatile == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<decltype(fn_450)>>>>::is_lvalue_reference == false);
static_assert(callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_const_t<decltype(fn_450)>>>>>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<std::add_lvalue_reference_t<std::add_cv_t<std::add_pointer_t<std::add_volatile_t<decltype(fn_450)>>>>>> == false);
struct class_0 { void mem_fn(); };
static_assert(std::is_same_v<callable_traits<decltype(&class_0::mem_fn)>::result_type, void>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_0::mem_fn)>> == false);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_0::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_0::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_0::mem_fn)>> == false);
static_assert(callable_traits<decltype(&class_0::mem_fn)>::arity == 0);
static_assert(callable_traits<decltype(&class_0::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_0::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_0::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_0::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_0::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_0::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_0::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_0::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_0::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_0::mem_fn)>::class_type, class_0>);
struct class_1 { void * mem_fn(void *, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_1::mem_fn)>::result_type, void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_1::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_1::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_1::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_1::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_1::mem_fn)>::arg0_type, void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_1::mem_fn)>::arg_type<0>, void *>);
static_assert(callable_traits<decltype(&class_1::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_1::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_1::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_1::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_1::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_1::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_1::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_1::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_1::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_1::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_1::mem_fn)>::class_type, class_1>);
struct class_2 { const void * mem_fn(const void *) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_2::mem_fn)>::result_type, const void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_2::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_2::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_2::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_2::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_2::mem_fn)>::arg0_type, const void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_2::mem_fn)>::arg_type<0>, const void *>);
static_assert(callable_traits<decltype(&class_2::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_2::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_2::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_2::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_2::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_2::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_2::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_2::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_2::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_2::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_2::mem_fn)>::class_type, class_2>);
struct class_3 { volatile void * mem_fn(volatile void *, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_3::mem_fn)>::result_type, volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_3::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_3::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_3::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_3::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_3::mem_fn)>::arg0_type, volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_3::mem_fn)>::arg_type<0>, volatile void *>);
static_assert(callable_traits<decltype(&class_3::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_3::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_3::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_3::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_3::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_3::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_3::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_3::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_3::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_3::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_3::mem_fn)>::class_type, class_3>);
struct class_4 { const volatile void * mem_fn(const volatile void *) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_4::mem_fn)>::result_type, const volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_4::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_4::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_4::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_4::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_4::mem_fn)>::arg0_type, const volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_4::mem_fn)>::arg_type<0>, const volatile void *>);
static_assert(callable_traits<decltype(&class_4::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_4::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_4::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_4::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_4::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_4::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_4::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_4::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_4::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_4::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_4::mem_fn)>::class_type, class_4>);
struct class_5 { void * & mem_fn(void * &, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_5::mem_fn)>::result_type, void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_5::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_5::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_5::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_5::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_5::mem_fn)>::arg0_type, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_5::mem_fn)>::arg_type<0>, void * &>);
static_assert(callable_traits<decltype(&class_5::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_5::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_5::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_5::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_5::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_5::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_5::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_5::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_5::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_5::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_5::mem_fn)>::class_type, class_5>);
struct class_6 { const void * & mem_fn(const void * &) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_6::mem_fn)>::result_type, const void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_6::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_6::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_6::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_6::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_6::mem_fn)>::arg0_type, const void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_6::mem_fn)>::arg_type<0>, const void * &>);
static_assert(callable_traits<decltype(&class_6::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_6::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_6::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_6::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_6::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_6::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_6::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_6::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_6::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_6::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_6::mem_fn)>::class_type, class_6>);
struct class_7 { volatile void * & mem_fn(volatile void * &, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_7::mem_fn)>::result_type, volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_7::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_7::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_7::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_7::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_7::mem_fn)>::arg0_type, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_7::mem_fn)>::arg_type<0>, volatile void * &>);
static_assert(callable_traits<decltype(&class_7::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_7::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_7::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_7::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_7::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_7::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_7::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_7::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_7::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_7::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_7::mem_fn)>::class_type, class_7>);
struct class_8 { const volatile void * & mem_fn(const volatile void * &) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_8::mem_fn)>::result_type, const volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_8::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_8::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_8::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_8::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_8::mem_fn)>::arg0_type, const volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_8::mem_fn)>::arg_type<0>, const volatile void * &>);
static_assert(callable_traits<decltype(&class_8::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_8::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_8::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_8::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_8::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_8::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_8::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_8::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_8::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_8::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_8::mem_fn)>::class_type, class_8>);
struct class_9 { void * const & mem_fn(void * const &, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_9::mem_fn)>::result_type, void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_9::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_9::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_9::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_9::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_9::mem_fn)>::arg0_type, void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_9::mem_fn)>::arg_type<0>, void * const &>);
static_assert(callable_traits<decltype(&class_9::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_9::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_9::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_9::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_9::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_9::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_9::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_9::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_9::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_9::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_9::mem_fn)>::class_type, class_9>);
struct class_10 { const void * const & mem_fn(const void * const &) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_10::mem_fn)>::result_type, const void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_10::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_10::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_10::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_10::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_10::mem_fn)>::arg0_type, const void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_10::mem_fn)>::arg_type<0>, const void * const &>);
static_assert(callable_traits<decltype(&class_10::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_10::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_10::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_10::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_10::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_10::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_10::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_10::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_10::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_10::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_10::mem_fn)>::class_type, class_10>);
struct class_11 { volatile void * const & mem_fn(volatile void * const &, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_11::mem_fn)>::result_type, volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_11::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_11::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_11::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_11::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_11::mem_fn)>::arg0_type, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_11::mem_fn)>::arg_type<0>, volatile void * const &>);
static_assert(callable_traits<decltype(&class_11::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_11::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_11::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_11::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_11::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_11::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_11::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_11::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_11::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_11::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_11::mem_fn)>::class_type, class_11>);
struct class_12 { const volatile void * const & mem_fn(const volatile void * const &) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_12::mem_fn)>::result_type, const volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_12::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_12::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_12::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_12::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_12::mem_fn)>::arg0_type, const volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_12::mem_fn)>::arg_type<0>, const volatile void * const &>);
static_assert(callable_traits<decltype(&class_12::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_12::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_12::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_12::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_12::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_12::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_12::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_12::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_12::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_12::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_12::mem_fn)>::class_type, class_12>);
struct class_13 { void * volatile & mem_fn(void * volatile &, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_13::mem_fn)>::result_type, void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_13::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_13::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_13::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_13::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_13::mem_fn)>::arg0_type, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_13::mem_fn)>::arg_type<0>, void * volatile &>);
static_assert(callable_traits<decltype(&class_13::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_13::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_13::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_13::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_13::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_13::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_13::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_13::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_13::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_13::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_13::mem_fn)>::class_type, class_13>);
struct class_14 { const void * volatile & mem_fn(const void * volatile &) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_14::mem_fn)>::result_type, const void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_14::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_14::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_14::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_14::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_14::mem_fn)>::arg0_type, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_14::mem_fn)>::arg_type<0>, const void * volatile &>);
static_assert(callable_traits<decltype(&class_14::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_14::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_14::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_14::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_14::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_14::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_14::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_14::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_14::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_14::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_14::mem_fn)>::class_type, class_14>);
struct class_15 { volatile void * volatile & mem_fn(volatile void * volatile &, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_15::mem_fn)>::result_type, volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_15::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_15::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_15::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_15::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_15::mem_fn)>::arg0_type, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_15::mem_fn)>::arg_type<0>, volatile void * volatile &>);
static_assert(callable_traits<decltype(&class_15::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_15::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_15::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_15::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_15::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_15::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_15::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_15::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_15::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_15::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_15::mem_fn)>::class_type, class_15>);
struct class_16 { const volatile void * volatile & mem_fn(const volatile void * volatile &) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_16::mem_fn)>::result_type, const volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_16::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_16::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_16::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_16::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_16::mem_fn)>::arg0_type, const volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_16::mem_fn)>::arg_type<0>, const volatile void * volatile &>);
static_assert(callable_traits<decltype(&class_16::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_16::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_16::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_16::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_16::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_16::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_16::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_16::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_16::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_16::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_16::mem_fn)>::class_type, class_16>);
struct class_17 { void * const volatile & mem_fn(void * const volatile &, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_17::mem_fn)>::result_type, void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_17::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_17::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_17::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_17::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_17::mem_fn)>::arg0_type, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_17::mem_fn)>::arg_type<0>, void * const volatile &>);
static_assert(callable_traits<decltype(&class_17::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_17::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_17::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_17::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_17::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_17::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_17::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_17::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_17::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_17::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_17::mem_fn)>::class_type, class_17>);
struct class_18 { const void * const volatile & mem_fn(const void * const volatile &) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_18::mem_fn)>::result_type, const void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_18::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_18::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_18::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_18::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_18::mem_fn)>::arg0_type, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_18::mem_fn)>::arg_type<0>, const void * const volatile &>);
static_assert(callable_traits<decltype(&class_18::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_18::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_18::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_18::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_18::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_18::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_18::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_18::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_18::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_18::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_18::mem_fn)>::class_type, class_18>);
struct class_19 { volatile void * const volatile & mem_fn(volatile void * const volatile &, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_19::mem_fn)>::result_type, volatile void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_19::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_19::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_19::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_19::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_19::mem_fn)>::arg0_type, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_19::mem_fn)>::arg_type<0>, volatile void * const volatile &>);
static_assert(callable_traits<decltype(&class_19::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_19::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_19::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_19::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_19::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_19::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_19::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_19::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_19::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_19::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_19::mem_fn)>::class_type, class_19>);
struct class_20 { const volatile void * const volatile & mem_fn(const volatile void * const volatile &) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_20::mem_fn)>::result_type, const volatile void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_20::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_20::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_20::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_20::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_20::mem_fn)>::arg0_type, const volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_20::mem_fn)>::arg_type<0>, const volatile void * const volatile &>);
static_assert(callable_traits<decltype(&class_20::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_20::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_20::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_20::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_20::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_20::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_20::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_20::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_20::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_20::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_20::mem_fn)>::class_type, class_20>);
struct class_21 { void * && mem_fn(void * &&, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_21::mem_fn)>::result_type, void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_21::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_21::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_21::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_21::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_21::mem_fn)>::arg0_type, void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_21::mem_fn)>::arg_type<0>, void * &&>);
static_assert(callable_traits<decltype(&class_21::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_21::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_21::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_21::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_21::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_21::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_21::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_21::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_21::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_21::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_21::mem_fn)>::class_type, class_21>);
struct class_22 { const void * && mem_fn(const void * &&) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_22::mem_fn)>::result_type, const void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_22::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_22::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_22::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_22::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_22::mem_fn)>::arg0_type, const void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_22::mem_fn)>::arg_type<0>, const void * &&>);
static_assert(callable_traits<decltype(&class_22::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_22::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_22::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_22::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_22::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_22::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_22::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_22::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_22::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_22::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_22::mem_fn)>::class_type, class_22>);
struct class_23 { volatile void * && mem_fn(volatile void * &&, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_23::mem_fn)>::result_type, volatile void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_23::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_23::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_23::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_23::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_23::mem_fn)>::arg0_type, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_23::mem_fn)>::arg_type<0>, volatile void * &&>);
static_assert(callable_traits<decltype(&class_23::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_23::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_23::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_23::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_23::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_23::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_23::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_23::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_23::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_23::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_23::mem_fn)>::class_type, class_23>);
struct class_24 { const volatile void * && mem_fn(const volatile void * &&); };
static_assert(std::is_same_v<callable_traits<decltype(&class_24::mem_fn)>::result_type, const volatile void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_24::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_24::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_24::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_24::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_24::mem_fn)>::arg0_type, const volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_24::mem_fn)>::arg_type<0>, const volatile void * &&>);
static_assert(callable_traits<decltype(&class_24::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_24::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_24::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_24::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_24::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_24::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_24::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_24::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_24::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_24::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_24::mem_fn)>::class_type, class_24>);
struct class_25 { void * const && mem_fn(void * const &&, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_25::mem_fn)>::result_type, void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_25::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_25::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_25::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_25::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_25::mem_fn)>::arg0_type, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_25::mem_fn)>::arg_type<0>, void * const &&>);
static_assert(callable_traits<decltype(&class_25::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_25::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_25::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_25::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_25::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_25::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_25::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_25::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_25::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_25::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_25::mem_fn)>::class_type, class_25>);
struct class_26 { const void * const && mem_fn(const void * const &&) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_26::mem_fn)>::result_type, const void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_26::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_26::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_26::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_26::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_26::mem_fn)>::arg0_type, const void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_26::mem_fn)>::arg_type<0>, const void * const &&>);
static_assert(callable_traits<decltype(&class_26::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_26::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_26::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_26::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_26::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_26::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_26::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_26::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_26::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_26::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_26::mem_fn)>::class_type, class_26>);
struct class_27 { volatile void * const && mem_fn(volatile void * const &&, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_27::mem_fn)>::result_type, volatile void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_27::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_27::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_27::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_27::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_27::mem_fn)>::arg0_type, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_27::mem_fn)>::arg_type<0>, volatile void * const &&>);
static_assert(callable_traits<decltype(&class_27::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_27::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_27::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_27::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_27::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_27::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_27::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_27::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_27::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_27::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_27::mem_fn)>::class_type, class_27>);
struct class_28 { const volatile void * const && mem_fn(const volatile void * const &&) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_28::mem_fn)>::result_type, const volatile void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_28::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_28::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_28::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_28::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_28::mem_fn)>::arg0_type, const volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_28::mem_fn)>::arg_type<0>, const volatile void * const &&>);
static_assert(callable_traits<decltype(&class_28::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_28::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_28::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_28::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_28::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_28::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_28::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_28::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_28::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_28::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_28::mem_fn)>::class_type, class_28>);
struct class_29 { void * volatile && mem_fn(void * volatile &&, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_29::mem_fn)>::result_type, void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_29::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_29::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_29::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_29::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_29::mem_fn)>::arg0_type, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_29::mem_fn)>::arg_type<0>, void * volatile &&>);
static_assert(callable_traits<decltype(&class_29::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_29::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_29::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_29::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_29::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_29::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_29::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_29::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_29::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_29::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_29::mem_fn)>::class_type, class_29>);
struct class_30 { const void * volatile && mem_fn(const void * volatile &&) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_30::mem_fn)>::result_type, const void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_30::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_30::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_30::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_30::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_30::mem_fn)>::arg0_type, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_30::mem_fn)>::arg_type<0>, const void * volatile &&>);
static_assert(callable_traits<decltype(&class_30::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_30::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_30::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_30::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_30::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_30::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_30::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_30::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_30::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_30::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_30::mem_fn)>::class_type, class_30>);
struct class_31 { volatile void * volatile && mem_fn(volatile void * volatile &&, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_31::mem_fn)>::result_type, volatile void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_31::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_31::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_31::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_31::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_31::mem_fn)>::arg0_type, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_31::mem_fn)>::arg_type<0>, volatile void * volatile &&>);
static_assert(callable_traits<decltype(&class_31::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_31::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_31::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_31::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_31::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_31::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_31::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_31::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_31::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_31::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_31::mem_fn)>::class_type, class_31>);
struct class_32 { const volatile void * volatile && mem_fn(const volatile void * volatile &&) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_32::mem_fn)>::result_type, const volatile void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_32::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_32::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_32::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_32::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_32::mem_fn)>::arg0_type, const volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_32::mem_fn)>::arg_type<0>, const volatile void * volatile &&>);
static_assert(callable_traits<decltype(&class_32::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_32::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_32::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_32::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_32::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_32::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_32::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_32::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_32::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_32::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_32::mem_fn)>::class_type, class_32>);
struct class_33 { void * const volatile && mem_fn(void * const volatile &&, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_33::mem_fn)>::result_type, void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_33::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_33::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_33::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_33::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_33::mem_fn)>::arg0_type, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_33::mem_fn)>::arg_type<0>, void * const volatile &&>);
static_assert(callable_traits<decltype(&class_33::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_33::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_33::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_33::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_33::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_33::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_33::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_33::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_33::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_33::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_33::mem_fn)>::class_type, class_33>);
struct class_34 { const void * const volatile && mem_fn(const void * const volatile &&) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_34::mem_fn)>::result_type, const void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_34::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_34::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_34::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_34::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_34::mem_fn)>::arg0_type, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_34::mem_fn)>::arg_type<0>, const void * const volatile &&>);
static_assert(callable_traits<decltype(&class_34::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_34::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_34::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_34::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_34::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_34::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_34::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_34::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_34::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_34::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_34::mem_fn)>::class_type, class_34>);
struct class_35 { volatile void * const volatile && mem_fn(volatile void * const volatile &&, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_35::mem_fn)>::result_type, volatile void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_35::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_35::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_35::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_35::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_35::mem_fn)>::arg0_type, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_35::mem_fn)>::arg_type<0>, volatile void * const volatile &&>);
static_assert(callable_traits<decltype(&class_35::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_35::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_35::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_35::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_35::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_35::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_35::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_35::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_35::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_35::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_35::mem_fn)>::class_type, class_35>);
struct class_36 { const volatile void * const volatile && mem_fn(const volatile void * const volatile &&) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_36::mem_fn)>::result_type, const volatile void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_36::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_36::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_36::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_36::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_36::mem_fn)>::arg0_type, const volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_36::mem_fn)>::arg_type<0>, const volatile void * const volatile &&>);
static_assert(callable_traits<decltype(&class_36::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_36::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_36::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_36::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_36::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_36::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_36::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_36::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_36::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_36::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_36::mem_fn)>::class_type, class_36>);
struct class_37 { bool mem_fn(bool, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_37::mem_fn)>::result_type, bool>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_37::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_37::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_37::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_37::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_37::mem_fn)>::arg0_type, bool>);
static_assert(std::is_same_v<callable_traits<decltype(&class_37::mem_fn)>::arg_type<0>, bool>);
static_assert(callable_traits<decltype(&class_37::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_37::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_37::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_37::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_37::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_37::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_37::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_37::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_37::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_37::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_37::mem_fn)>::class_type, class_37>);
struct class_38 { bool * mem_fn(bool *) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_38::mem_fn)>::result_type, bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_38::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_38::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_38::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_38::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_38::mem_fn)>::arg0_type, bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_38::mem_fn)>::arg_type<0>, bool *>);
static_assert(callable_traits<decltype(&class_38::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_38::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_38::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_38::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_38::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_38::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_38::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_38::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_38::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_38::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_38::mem_fn)>::class_type, class_38>);
struct class_39 { const bool * mem_fn(const bool *, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_39::mem_fn)>::result_type, const bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_39::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_39::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_39::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_39::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_39::mem_fn)>::arg0_type, const bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_39::mem_fn)>::arg_type<0>, const bool *>);
static_assert(callable_traits<decltype(&class_39::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_39::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_39::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_39::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_39::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_39::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_39::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_39::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_39::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_39::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_39::mem_fn)>::class_type, class_39>);
struct class_40 { volatile bool * mem_fn(volatile bool *) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_40::mem_fn)>::result_type, volatile bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_40::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_40::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_40::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_40::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_40::mem_fn)>::arg0_type, volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_40::mem_fn)>::arg_type<0>, volatile bool *>);
static_assert(callable_traits<decltype(&class_40::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_40::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_40::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_40::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_40::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_40::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_40::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_40::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_40::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_40::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_40::mem_fn)>::class_type, class_40>);
struct class_41 { const volatile bool * mem_fn(const volatile bool *, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_41::mem_fn)>::result_type, const volatile bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_41::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_41::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_41::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_41::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_41::mem_fn)>::arg0_type, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_41::mem_fn)>::arg_type<0>, const volatile bool *>);
static_assert(callable_traits<decltype(&class_41::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_41::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_41::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_41::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_41::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_41::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_41::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_41::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_41::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_41::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_41::mem_fn)>::class_type, class_41>);
struct class_42 { bool & mem_fn(bool &) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_42::mem_fn)>::result_type, bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_42::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_42::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_42::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_42::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_42::mem_fn)>::arg0_type, bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_42::mem_fn)>::arg_type<0>, bool &>);
static_assert(callable_traits<decltype(&class_42::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_42::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_42::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_42::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_42::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_42::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_42::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_42::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_42::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_42::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_42::mem_fn)>::class_type, class_42>);
struct class_43 { const bool & mem_fn(const bool &, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_43::mem_fn)>::result_type, const bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_43::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_43::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_43::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_43::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_43::mem_fn)>::arg0_type, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_43::mem_fn)>::arg_type<0>, const bool &>);
static_assert(callable_traits<decltype(&class_43::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_43::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_43::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_43::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_43::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_43::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_43::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_43::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_43::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_43::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_43::mem_fn)>::class_type, class_43>);
struct class_44 { volatile bool & mem_fn(volatile bool &) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_44::mem_fn)>::result_type, volatile bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_44::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_44::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_44::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_44::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_44::mem_fn)>::arg0_type, volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_44::mem_fn)>::arg_type<0>, volatile bool &>);
static_assert(callable_traits<decltype(&class_44::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_44::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_44::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_44::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_44::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_44::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_44::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_44::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_44::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_44::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_44::mem_fn)>::class_type, class_44>);
struct class_45 { const volatile bool & mem_fn(const volatile bool &, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_45::mem_fn)>::result_type, const volatile bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_45::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_45::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_45::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_45::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_45::mem_fn)>::arg0_type, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_45::mem_fn)>::arg_type<0>, const volatile bool &>);
static_assert(callable_traits<decltype(&class_45::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_45::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_45::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_45::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_45::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_45::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_45::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_45::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_45::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_45::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_45::mem_fn)>::class_type, class_45>);
struct class_46 { bool * & mem_fn(bool * &) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_46::mem_fn)>::result_type, bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_46::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_46::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_46::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_46::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_46::mem_fn)>::arg0_type, bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_46::mem_fn)>::arg_type<0>, bool * &>);
static_assert(callable_traits<decltype(&class_46::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_46::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_46::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_46::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_46::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_46::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_46::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_46::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_46::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_46::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_46::mem_fn)>::class_type, class_46>);
struct class_47 { const bool * & mem_fn(const bool * &, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_47::mem_fn)>::result_type, const bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_47::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_47::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_47::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_47::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_47::mem_fn)>::arg0_type, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_47::mem_fn)>::arg_type<0>, const bool * &>);
static_assert(callable_traits<decltype(&class_47::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_47::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_47::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_47::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_47::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_47::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_47::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_47::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_47::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_47::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_47::mem_fn)>::class_type, class_47>);
struct class_48 { volatile bool * & mem_fn(volatile bool * &); };
static_assert(std::is_same_v<callable_traits<decltype(&class_48::mem_fn)>::result_type, volatile bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_48::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_48::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_48::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_48::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_48::mem_fn)>::arg0_type, volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_48::mem_fn)>::arg_type<0>, volatile bool * &>);
static_assert(callable_traits<decltype(&class_48::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_48::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_48::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_48::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_48::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_48::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_48::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_48::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_48::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_48::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_48::mem_fn)>::class_type, class_48>);
struct class_49 { const volatile bool * & mem_fn(const volatile bool * &, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_49::mem_fn)>::result_type, const volatile bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_49::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_49::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_49::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_49::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_49::mem_fn)>::arg0_type, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_49::mem_fn)>::arg_type<0>, const volatile bool * &>);
static_assert(callable_traits<decltype(&class_49::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_49::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_49::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_49::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_49::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_49::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_49::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_49::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_49::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_49::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_49::mem_fn)>::class_type, class_49>);
struct class_50 { bool * const & mem_fn(bool * const &) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_50::mem_fn)>::result_type, bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_50::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_50::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_50::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_50::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_50::mem_fn)>::arg0_type, bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_50::mem_fn)>::arg_type<0>, bool * const &>);
static_assert(callable_traits<decltype(&class_50::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_50::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_50::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_50::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_50::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_50::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_50::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_50::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_50::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_50::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_50::mem_fn)>::class_type, class_50>);
struct class_51 { const bool * const & mem_fn(const bool * const &, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_51::mem_fn)>::result_type, const bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_51::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_51::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_51::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_51::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_51::mem_fn)>::arg0_type, const bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_51::mem_fn)>::arg_type<0>, const bool * const &>);
static_assert(callable_traits<decltype(&class_51::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_51::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_51::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_51::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_51::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_51::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_51::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_51::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_51::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_51::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_51::mem_fn)>::class_type, class_51>);
struct class_52 { volatile bool * const & mem_fn(volatile bool * const &) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_52::mem_fn)>::result_type, volatile bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_52::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_52::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_52::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_52::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_52::mem_fn)>::arg0_type, volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_52::mem_fn)>::arg_type<0>, volatile bool * const &>);
static_assert(callable_traits<decltype(&class_52::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_52::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_52::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_52::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_52::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_52::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_52::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_52::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_52::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_52::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_52::mem_fn)>::class_type, class_52>);
struct class_53 { const volatile bool * const & mem_fn(const volatile bool * const &, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_53::mem_fn)>::result_type, const volatile bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_53::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_53::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_53::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_53::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_53::mem_fn)>::arg0_type, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_53::mem_fn)>::arg_type<0>, const volatile bool * const &>);
static_assert(callable_traits<decltype(&class_53::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_53::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_53::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_53::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_53::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_53::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_53::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_53::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_53::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_53::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_53::mem_fn)>::class_type, class_53>);
struct class_54 { bool * volatile & mem_fn(bool * volatile &) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_54::mem_fn)>::result_type, bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_54::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_54::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_54::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_54::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_54::mem_fn)>::arg0_type, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_54::mem_fn)>::arg_type<0>, bool * volatile &>);
static_assert(callable_traits<decltype(&class_54::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_54::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_54::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_54::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_54::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_54::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_54::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_54::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_54::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_54::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_54::mem_fn)>::class_type, class_54>);
struct class_55 { const bool * volatile & mem_fn(const bool * volatile &, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_55::mem_fn)>::result_type, const bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_55::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_55::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_55::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_55::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_55::mem_fn)>::arg0_type, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_55::mem_fn)>::arg_type<0>, const bool * volatile &>);
static_assert(callable_traits<decltype(&class_55::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_55::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_55::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_55::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_55::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_55::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_55::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_55::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_55::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_55::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_55::mem_fn)>::class_type, class_55>);
struct class_56 { volatile bool * volatile & mem_fn(volatile bool * volatile &) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_56::mem_fn)>::result_type, volatile bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_56::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_56::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_56::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_56::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_56::mem_fn)>::arg0_type, volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_56::mem_fn)>::arg_type<0>, volatile bool * volatile &>);
static_assert(callable_traits<decltype(&class_56::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_56::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_56::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_56::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_56::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_56::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_56::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_56::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_56::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_56::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_56::mem_fn)>::class_type, class_56>);
struct class_57 { const volatile bool * volatile & mem_fn(const volatile bool * volatile &, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_57::mem_fn)>::result_type, const volatile bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_57::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_57::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_57::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_57::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_57::mem_fn)>::arg0_type, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_57::mem_fn)>::arg_type<0>, const volatile bool * volatile &>);
static_assert(callable_traits<decltype(&class_57::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_57::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_57::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_57::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_57::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_57::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_57::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_57::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_57::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_57::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_57::mem_fn)>::class_type, class_57>);
struct class_58 { bool * const volatile & mem_fn(bool * const volatile &) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_58::mem_fn)>::result_type, bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_58::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_58::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_58::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_58::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_58::mem_fn)>::arg0_type, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_58::mem_fn)>::arg_type<0>, bool * const volatile &>);
static_assert(callable_traits<decltype(&class_58::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_58::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_58::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_58::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_58::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_58::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_58::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_58::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_58::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_58::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_58::mem_fn)>::class_type, class_58>);
struct class_59 { const bool * const volatile & mem_fn(const bool * const volatile &, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_59::mem_fn)>::result_type, const bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_59::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_59::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_59::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_59::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_59::mem_fn)>::arg0_type, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_59::mem_fn)>::arg_type<0>, const bool * const volatile &>);
static_assert(callable_traits<decltype(&class_59::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_59::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_59::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_59::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_59::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_59::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_59::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_59::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_59::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_59::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_59::mem_fn)>::class_type, class_59>);
struct class_60 { volatile bool * const volatile & mem_fn(volatile bool * const volatile &) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_60::mem_fn)>::result_type, volatile bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_60::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_60::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_60::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_60::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_60::mem_fn)>::arg0_type, volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_60::mem_fn)>::arg_type<0>, volatile bool * const volatile &>);
static_assert(callable_traits<decltype(&class_60::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_60::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_60::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_60::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_60::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_60::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_60::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_60::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_60::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_60::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_60::mem_fn)>::class_type, class_60>);
struct class_61 { const volatile bool * const volatile & mem_fn(const volatile bool * const volatile &, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_61::mem_fn)>::result_type, const volatile bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_61::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_61::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_61::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_61::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_61::mem_fn)>::arg0_type, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_61::mem_fn)>::arg_type<0>, const volatile bool * const volatile &>);
static_assert(callable_traits<decltype(&class_61::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_61::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_61::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_61::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_61::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_61::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_61::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_61::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_61::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_61::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_61::mem_fn)>::class_type, class_61>);
struct class_62 { bool && mem_fn(bool &&) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_62::mem_fn)>::result_type, bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_62::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_62::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_62::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_62::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_62::mem_fn)>::arg0_type, bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_62::mem_fn)>::arg_type<0>, bool &&>);
static_assert(callable_traits<decltype(&class_62::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_62::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_62::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_62::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_62::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_62::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_62::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_62::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_62::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_62::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_62::mem_fn)>::class_type, class_62>);
struct class_63 { const bool && mem_fn(const bool &&, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_63::mem_fn)>::result_type, const bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_63::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_63::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_63::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_63::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_63::mem_fn)>::arg0_type, const bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_63::mem_fn)>::arg_type<0>, const bool &&>);
static_assert(callable_traits<decltype(&class_63::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_63::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_63::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_63::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_63::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_63::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_63::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_63::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_63::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_63::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_63::mem_fn)>::class_type, class_63>);
struct class_64 { volatile bool && mem_fn(volatile bool &&) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_64::mem_fn)>::result_type, volatile bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_64::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_64::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_64::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_64::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_64::mem_fn)>::arg0_type, volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_64::mem_fn)>::arg_type<0>, volatile bool &&>);
static_assert(callable_traits<decltype(&class_64::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_64::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_64::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_64::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_64::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_64::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_64::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_64::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_64::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_64::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_64::mem_fn)>::class_type, class_64>);
struct class_65 { const volatile bool && mem_fn(const volatile bool &&, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_65::mem_fn)>::result_type, const volatile bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_65::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_65::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_65::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_65::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_65::mem_fn)>::arg0_type, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_65::mem_fn)>::arg_type<0>, const volatile bool &&>);
static_assert(callable_traits<decltype(&class_65::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_65::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_65::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_65::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_65::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_65::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_65::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_65::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_65::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_65::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_65::mem_fn)>::class_type, class_65>);
struct class_66 { bool * && mem_fn(bool * &&) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_66::mem_fn)>::result_type, bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_66::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_66::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_66::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_66::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_66::mem_fn)>::arg0_type, bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_66::mem_fn)>::arg_type<0>, bool * &&>);
static_assert(callable_traits<decltype(&class_66::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_66::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_66::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_66::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_66::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_66::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_66::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_66::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_66::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_66::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_66::mem_fn)>::class_type, class_66>);
struct class_67 { const bool * && mem_fn(const bool * &&, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_67::mem_fn)>::result_type, const bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_67::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_67::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_67::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_67::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_67::mem_fn)>::arg0_type, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_67::mem_fn)>::arg_type<0>, const bool * &&>);
static_assert(callable_traits<decltype(&class_67::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_67::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_67::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_67::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_67::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_67::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_67::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_67::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_67::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_67::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_67::mem_fn)>::class_type, class_67>);
struct class_68 { volatile bool * && mem_fn(volatile bool * &&) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_68::mem_fn)>::result_type, volatile bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_68::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_68::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_68::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_68::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_68::mem_fn)>::arg0_type, volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_68::mem_fn)>::arg_type<0>, volatile bool * &&>);
static_assert(callable_traits<decltype(&class_68::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_68::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_68::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_68::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_68::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_68::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_68::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_68::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_68::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_68::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_68::mem_fn)>::class_type, class_68>);
struct class_69 { const volatile bool * && mem_fn(const volatile bool * &&, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_69::mem_fn)>::result_type, const volatile bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_69::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_69::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_69::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_69::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_69::mem_fn)>::arg0_type, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_69::mem_fn)>::arg_type<0>, const volatile bool * &&>);
static_assert(callable_traits<decltype(&class_69::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_69::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_69::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_69::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_69::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_69::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_69::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_69::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_69::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_69::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_69::mem_fn)>::class_type, class_69>);
struct class_70 { bool * const && mem_fn(bool * const &&) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_70::mem_fn)>::result_type, bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_70::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_70::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_70::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_70::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_70::mem_fn)>::arg0_type, bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_70::mem_fn)>::arg_type<0>, bool * const &&>);
static_assert(callable_traits<decltype(&class_70::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_70::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_70::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_70::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_70::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_70::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_70::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_70::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_70::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_70::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_70::mem_fn)>::class_type, class_70>);
struct class_71 { const bool * const && mem_fn(const bool * const &&, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_71::mem_fn)>::result_type, const bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_71::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_71::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_71::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_71::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_71::mem_fn)>::arg0_type, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_71::mem_fn)>::arg_type<0>, const bool * const &&>);
static_assert(callable_traits<decltype(&class_71::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_71::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_71::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_71::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_71::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_71::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_71::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_71::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_71::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_71::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_71::mem_fn)>::class_type, class_71>);
struct class_72 { volatile bool * const && mem_fn(volatile bool * const &&); };
static_assert(std::is_same_v<callable_traits<decltype(&class_72::mem_fn)>::result_type, volatile bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_72::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_72::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_72::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_72::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_72::mem_fn)>::arg0_type, volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_72::mem_fn)>::arg_type<0>, volatile bool * const &&>);
static_assert(callable_traits<decltype(&class_72::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_72::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_72::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_72::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_72::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_72::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_72::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_72::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_72::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_72::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_72::mem_fn)>::class_type, class_72>);
struct class_73 { const volatile bool * const && mem_fn(const volatile bool * const &&, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_73::mem_fn)>::result_type, const volatile bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_73::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_73::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_73::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_73::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_73::mem_fn)>::arg0_type, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_73::mem_fn)>::arg_type<0>, const volatile bool * const &&>);
static_assert(callable_traits<decltype(&class_73::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_73::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_73::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_73::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_73::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_73::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_73::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_73::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_73::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_73::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_73::mem_fn)>::class_type, class_73>);
struct class_74 { bool * volatile && mem_fn(bool * volatile &&) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_74::mem_fn)>::result_type, bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_74::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_74::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_74::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_74::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_74::mem_fn)>::arg0_type, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_74::mem_fn)>::arg_type<0>, bool * volatile &&>);
static_assert(callable_traits<decltype(&class_74::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_74::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_74::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_74::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_74::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_74::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_74::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_74::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_74::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_74::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_74::mem_fn)>::class_type, class_74>);
struct class_75 { const bool * volatile && mem_fn(const bool * volatile &&, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_75::mem_fn)>::result_type, const bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_75::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_75::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_75::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_75::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_75::mem_fn)>::arg0_type, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_75::mem_fn)>::arg_type<0>, const bool * volatile &&>);
static_assert(callable_traits<decltype(&class_75::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_75::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_75::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_75::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_75::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_75::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_75::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_75::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_75::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_75::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_75::mem_fn)>::class_type, class_75>);
struct class_76 { volatile bool * volatile && mem_fn(volatile bool * volatile &&) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_76::mem_fn)>::result_type, volatile bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_76::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_76::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_76::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_76::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_76::mem_fn)>::arg0_type, volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_76::mem_fn)>::arg_type<0>, volatile bool * volatile &&>);
static_assert(callable_traits<decltype(&class_76::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_76::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_76::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_76::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_76::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_76::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_76::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_76::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_76::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_76::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_76::mem_fn)>::class_type, class_76>);
struct class_77 { const volatile bool * volatile && mem_fn(const volatile bool * volatile &&, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_77::mem_fn)>::result_type, const volatile bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_77::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_77::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_77::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_77::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_77::mem_fn)>::arg0_type, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_77::mem_fn)>::arg_type<0>, const volatile bool * volatile &&>);
static_assert(callable_traits<decltype(&class_77::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_77::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_77::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_77::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_77::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_77::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_77::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_77::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_77::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_77::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_77::mem_fn)>::class_type, class_77>);
struct class_78 { bool * const volatile && mem_fn(bool * const volatile &&) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_78::mem_fn)>::result_type, bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_78::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_78::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_78::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_78::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_78::mem_fn)>::arg0_type, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_78::mem_fn)>::arg_type<0>, bool * const volatile &&>);
static_assert(callable_traits<decltype(&class_78::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_78::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_78::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_78::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_78::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_78::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_78::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_78::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_78::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_78::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_78::mem_fn)>::class_type, class_78>);
struct class_79 { const bool * const volatile && mem_fn(const bool * const volatile &&, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_79::mem_fn)>::result_type, const bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_79::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_79::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_79::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_79::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_79::mem_fn)>::arg0_type, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_79::mem_fn)>::arg_type<0>, const bool * const volatile &&>);
static_assert(callable_traits<decltype(&class_79::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_79::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_79::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_79::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_79::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_79::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_79::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_79::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_79::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_79::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_79::mem_fn)>::class_type, class_79>);
struct class_80 { volatile bool * const volatile && mem_fn(volatile bool * const volatile &&) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_80::mem_fn)>::result_type, volatile bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_80::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_80::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_80::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_80::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_80::mem_fn)>::arg0_type, volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_80::mem_fn)>::arg_type<0>, volatile bool * const volatile &&>);
static_assert(callable_traits<decltype(&class_80::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_80::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_80::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_80::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_80::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_80::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_80::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_80::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_80::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_80::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_80::mem_fn)>::class_type, class_80>);
struct class_81 { const volatile bool * const volatile && mem_fn(const volatile bool * const volatile &&, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_81::mem_fn)>::result_type, const volatile bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_81::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_81::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_81::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_81::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_81::mem_fn)>::arg0_type, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_81::mem_fn)>::arg_type<0>, const volatile bool * const volatile &&>);
static_assert(callable_traits<decltype(&class_81::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_81::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_81::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_81::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_81::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_81::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_81::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_81::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_81::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_81::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_81::mem_fn)>::class_type, class_81>);
struct class_82 { int mem_fn(int) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_82::mem_fn)>::result_type, int>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_82::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_82::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_82::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_82::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_82::mem_fn)>::arg0_type, int>);
static_assert(std::is_same_v<callable_traits<decltype(&class_82::mem_fn)>::arg_type<0>, int>);
static_assert(callable_traits<decltype(&class_82::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_82::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_82::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_82::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_82::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_82::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_82::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_82::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_82::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_82::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_82::mem_fn)>::class_type, class_82>);
struct class_83 { int * mem_fn(int *, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_83::mem_fn)>::result_type, int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_83::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_83::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_83::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_83::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_83::mem_fn)>::arg0_type, int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_83::mem_fn)>::arg_type<0>, int *>);
static_assert(callable_traits<decltype(&class_83::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_83::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_83::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_83::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_83::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_83::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_83::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_83::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_83::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_83::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_83::mem_fn)>::class_type, class_83>);
struct class_84 { const int * mem_fn(const int *) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_84::mem_fn)>::result_type, const int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_84::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_84::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_84::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_84::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_84::mem_fn)>::arg0_type, const int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_84::mem_fn)>::arg_type<0>, const int *>);
static_assert(callable_traits<decltype(&class_84::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_84::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_84::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_84::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_84::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_84::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_84::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_84::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_84::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_84::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_84::mem_fn)>::class_type, class_84>);
struct class_85 { volatile int * mem_fn(volatile int *, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_85::mem_fn)>::result_type, volatile int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_85::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_85::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_85::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_85::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_85::mem_fn)>::arg0_type, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_85::mem_fn)>::arg_type<0>, volatile int *>);
static_assert(callable_traits<decltype(&class_85::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_85::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_85::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_85::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_85::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_85::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_85::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_85::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_85::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_85::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_85::mem_fn)>::class_type, class_85>);
struct class_86 { const volatile int * mem_fn(const volatile int *) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_86::mem_fn)>::result_type, const volatile int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_86::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_86::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_86::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_86::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_86::mem_fn)>::arg0_type, const volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_86::mem_fn)>::arg_type<0>, const volatile int *>);
static_assert(callable_traits<decltype(&class_86::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_86::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_86::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_86::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_86::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_86::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_86::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_86::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_86::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_86::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_86::mem_fn)>::class_type, class_86>);
struct class_87 { int & mem_fn(int &, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_87::mem_fn)>::result_type, int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_87::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_87::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_87::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_87::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_87::mem_fn)>::arg0_type, int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_87::mem_fn)>::arg_type<0>, int &>);
static_assert(callable_traits<decltype(&class_87::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_87::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_87::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_87::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_87::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_87::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_87::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_87::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_87::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_87::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_87::mem_fn)>::class_type, class_87>);
struct class_88 { const int & mem_fn(const int &) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_88::mem_fn)>::result_type, const int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_88::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_88::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_88::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_88::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_88::mem_fn)>::arg0_type, const int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_88::mem_fn)>::arg_type<0>, const int &>);
static_assert(callable_traits<decltype(&class_88::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_88::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_88::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_88::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_88::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_88::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_88::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_88::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_88::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_88::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_88::mem_fn)>::class_type, class_88>);
struct class_89 { volatile int & mem_fn(volatile int &, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_89::mem_fn)>::result_type, volatile int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_89::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_89::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_89::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_89::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_89::mem_fn)>::arg0_type, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_89::mem_fn)>::arg_type<0>, volatile int &>);
static_assert(callable_traits<decltype(&class_89::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_89::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_89::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_89::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_89::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_89::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_89::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_89::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_89::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_89::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_89::mem_fn)>::class_type, class_89>);
struct class_90 { const volatile int & mem_fn(const volatile int &) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_90::mem_fn)>::result_type, const volatile int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_90::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_90::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_90::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_90::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_90::mem_fn)>::arg0_type, const volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_90::mem_fn)>::arg_type<0>, const volatile int &>);
static_assert(callable_traits<decltype(&class_90::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_90::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_90::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_90::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_90::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_90::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_90::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_90::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_90::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_90::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_90::mem_fn)>::class_type, class_90>);
struct class_91 { int * & mem_fn(int * &, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_91::mem_fn)>::result_type, int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_91::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_91::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_91::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_91::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_91::mem_fn)>::arg0_type, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_91::mem_fn)>::arg_type<0>, int * &>);
static_assert(callable_traits<decltype(&class_91::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_91::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_91::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_91::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_91::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_91::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_91::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_91::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_91::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_91::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_91::mem_fn)>::class_type, class_91>);
struct class_92 { const int * & mem_fn(const int * &) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_92::mem_fn)>::result_type, const int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_92::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_92::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_92::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_92::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_92::mem_fn)>::arg0_type, const int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_92::mem_fn)>::arg_type<0>, const int * &>);
static_assert(callable_traits<decltype(&class_92::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_92::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_92::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_92::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_92::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_92::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_92::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_92::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_92::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_92::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_92::mem_fn)>::class_type, class_92>);
struct class_93 { volatile int * & mem_fn(volatile int * &, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_93::mem_fn)>::result_type, volatile int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_93::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_93::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_93::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_93::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_93::mem_fn)>::arg0_type, volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_93::mem_fn)>::arg_type<0>, volatile int * &>);
static_assert(callable_traits<decltype(&class_93::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_93::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_93::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_93::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_93::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_93::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_93::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_93::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_93::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_93::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_93::mem_fn)>::class_type, class_93>);
struct class_94 { const volatile int * & mem_fn(const volatile int * &) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_94::mem_fn)>::result_type, const volatile int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_94::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_94::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_94::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_94::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_94::mem_fn)>::arg0_type, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_94::mem_fn)>::arg_type<0>, const volatile int * &>);
static_assert(callable_traits<decltype(&class_94::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_94::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_94::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_94::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_94::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_94::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_94::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_94::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_94::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_94::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_94::mem_fn)>::class_type, class_94>);
struct class_95 { int * const & mem_fn(int * const &, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_95::mem_fn)>::result_type, int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_95::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_95::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_95::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_95::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_95::mem_fn)>::arg0_type, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_95::mem_fn)>::arg_type<0>, int * const &>);
static_assert(callable_traits<decltype(&class_95::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_95::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_95::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_95::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_95::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_95::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_95::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_95::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_95::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_95::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_95::mem_fn)>::class_type, class_95>);
struct class_96 { const int * const & mem_fn(const int * const &); };
static_assert(std::is_same_v<callable_traits<decltype(&class_96::mem_fn)>::result_type, const int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_96::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_96::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_96::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_96::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_96::mem_fn)>::arg0_type, const int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_96::mem_fn)>::arg_type<0>, const int * const &>);
static_assert(callable_traits<decltype(&class_96::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_96::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_96::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_96::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_96::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_96::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_96::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_96::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_96::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_96::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_96::mem_fn)>::class_type, class_96>);
struct class_97 { volatile int * const & mem_fn(volatile int * const &, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_97::mem_fn)>::result_type, volatile int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_97::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_97::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_97::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_97::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_97::mem_fn)>::arg0_type, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_97::mem_fn)>::arg_type<0>, volatile int * const &>);
static_assert(callable_traits<decltype(&class_97::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_97::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_97::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_97::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_97::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_97::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_97::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_97::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_97::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_97::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_97::mem_fn)>::class_type, class_97>);
struct class_98 { const volatile int * const & mem_fn(const volatile int * const &) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_98::mem_fn)>::result_type, const volatile int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_98::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_98::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_98::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_98::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_98::mem_fn)>::arg0_type, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_98::mem_fn)>::arg_type<0>, const volatile int * const &>);
static_assert(callable_traits<decltype(&class_98::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_98::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_98::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_98::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_98::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_98::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_98::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_98::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_98::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_98::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_98::mem_fn)>::class_type, class_98>);
struct class_99 { int * volatile & mem_fn(int * volatile &, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_99::mem_fn)>::result_type, int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_99::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_99::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_99::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_99::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_99::mem_fn)>::arg0_type, int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_99::mem_fn)>::arg_type<0>, int * volatile &>);
static_assert(callable_traits<decltype(&class_99::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_99::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_99::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_99::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_99::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_99::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_99::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_99::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_99::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_99::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_99::mem_fn)>::class_type, class_99>);
struct class_100 { const int * volatile & mem_fn(const int * volatile &) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_100::mem_fn)>::result_type, const int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_100::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_100::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_100::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_100::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_100::mem_fn)>::arg0_type, const int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_100::mem_fn)>::arg_type<0>, const int * volatile &>);
static_assert(callable_traits<decltype(&class_100::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_100::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_100::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_100::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_100::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_100::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_100::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_100::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_100::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_100::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_100::mem_fn)>::class_type, class_100>);
struct class_101 { volatile int * volatile & mem_fn(volatile int * volatile &, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_101::mem_fn)>::result_type, volatile int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_101::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_101::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_101::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_101::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_101::mem_fn)>::arg0_type, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_101::mem_fn)>::arg_type<0>, volatile int * volatile &>);
static_assert(callable_traits<decltype(&class_101::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_101::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_101::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_101::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_101::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_101::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_101::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_101::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_101::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_101::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_101::mem_fn)>::class_type, class_101>);
struct class_102 { const volatile int * volatile & mem_fn(const volatile int * volatile &) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_102::mem_fn)>::result_type, const volatile int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_102::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_102::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_102::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_102::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_102::mem_fn)>::arg0_type, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_102::mem_fn)>::arg_type<0>, const volatile int * volatile &>);
static_assert(callable_traits<decltype(&class_102::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_102::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_102::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_102::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_102::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_102::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_102::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_102::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_102::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_102::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_102::mem_fn)>::class_type, class_102>);
struct class_103 { int * const volatile & mem_fn(int * const volatile &, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_103::mem_fn)>::result_type, int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_103::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_103::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_103::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_103::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_103::mem_fn)>::arg0_type, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_103::mem_fn)>::arg_type<0>, int * const volatile &>);
static_assert(callable_traits<decltype(&class_103::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_103::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_103::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_103::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_103::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_103::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_103::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_103::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_103::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_103::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_103::mem_fn)>::class_type, class_103>);
struct class_104 { const int * const volatile & mem_fn(const int * const volatile &) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_104::mem_fn)>::result_type, const int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_104::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_104::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_104::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_104::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_104::mem_fn)>::arg0_type, const int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_104::mem_fn)>::arg_type<0>, const int * const volatile &>);
static_assert(callable_traits<decltype(&class_104::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_104::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_104::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_104::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_104::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_104::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_104::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_104::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_104::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_104::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_104::mem_fn)>::class_type, class_104>);
struct class_105 { volatile int * const volatile & mem_fn(volatile int * const volatile &, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_105::mem_fn)>::result_type, volatile int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_105::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_105::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_105::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_105::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_105::mem_fn)>::arg0_type, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_105::mem_fn)>::arg_type<0>, volatile int * const volatile &>);
static_assert(callable_traits<decltype(&class_105::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_105::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_105::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_105::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_105::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_105::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_105::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_105::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_105::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_105::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_105::mem_fn)>::class_type, class_105>);
struct class_106 { const volatile int * const volatile & mem_fn(const volatile int * const volatile &) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_106::mem_fn)>::result_type, const volatile int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_106::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_106::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_106::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_106::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_106::mem_fn)>::arg0_type, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_106::mem_fn)>::arg_type<0>, const volatile int * const volatile &>);
static_assert(callable_traits<decltype(&class_106::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_106::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_106::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_106::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_106::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_106::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_106::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_106::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_106::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_106::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_106::mem_fn)>::class_type, class_106>);
struct class_107 { int && mem_fn(int &&, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_107::mem_fn)>::result_type, int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_107::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_107::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_107::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_107::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_107::mem_fn)>::arg0_type, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_107::mem_fn)>::arg_type<0>, int &&>);
static_assert(callable_traits<decltype(&class_107::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_107::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_107::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_107::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_107::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_107::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_107::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_107::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_107::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_107::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_107::mem_fn)>::class_type, class_107>);
struct class_108 { const int && mem_fn(const int &&) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_108::mem_fn)>::result_type, const int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_108::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_108::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_108::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_108::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_108::mem_fn)>::arg0_type, const int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_108::mem_fn)>::arg_type<0>, const int &&>);
static_assert(callable_traits<decltype(&class_108::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_108::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_108::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_108::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_108::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_108::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_108::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_108::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_108::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_108::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_108::mem_fn)>::class_type, class_108>);
struct class_109 { volatile int && mem_fn(volatile int &&, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_109::mem_fn)>::result_type, volatile int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_109::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_109::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_109::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_109::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_109::mem_fn)>::arg0_type, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_109::mem_fn)>::arg_type<0>, volatile int &&>);
static_assert(callable_traits<decltype(&class_109::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_109::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_109::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_109::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_109::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_109::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_109::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_109::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_109::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_109::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_109::mem_fn)>::class_type, class_109>);
struct class_110 { const volatile int && mem_fn(const volatile int &&) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_110::mem_fn)>::result_type, const volatile int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_110::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_110::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_110::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_110::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_110::mem_fn)>::arg0_type, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_110::mem_fn)>::arg_type<0>, const volatile int &&>);
static_assert(callable_traits<decltype(&class_110::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_110::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_110::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_110::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_110::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_110::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_110::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_110::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_110::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_110::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_110::mem_fn)>::class_type, class_110>);
struct class_111 { int * && mem_fn(int * &&, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_111::mem_fn)>::result_type, int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_111::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_111::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_111::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_111::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_111::mem_fn)>::arg0_type, int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_111::mem_fn)>::arg_type<0>, int * &&>);
static_assert(callable_traits<decltype(&class_111::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_111::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_111::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_111::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_111::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_111::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_111::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_111::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_111::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_111::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_111::mem_fn)>::class_type, class_111>);
struct class_112 { const int * && mem_fn(const int * &&) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_112::mem_fn)>::result_type, const int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_112::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_112::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_112::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_112::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_112::mem_fn)>::arg0_type, const int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_112::mem_fn)>::arg_type<0>, const int * &&>);
static_assert(callable_traits<decltype(&class_112::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_112::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_112::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_112::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_112::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_112::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_112::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_112::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_112::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_112::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_112::mem_fn)>::class_type, class_112>);
struct class_113 { volatile int * && mem_fn(volatile int * &&, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_113::mem_fn)>::result_type, volatile int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_113::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_113::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_113::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_113::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_113::mem_fn)>::arg0_type, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_113::mem_fn)>::arg_type<0>, volatile int * &&>);
static_assert(callable_traits<decltype(&class_113::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_113::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_113::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_113::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_113::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_113::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_113::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_113::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_113::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_113::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_113::mem_fn)>::class_type, class_113>);
struct class_114 { const volatile int * && mem_fn(const volatile int * &&) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_114::mem_fn)>::result_type, const volatile int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_114::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_114::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_114::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_114::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_114::mem_fn)>::arg0_type, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_114::mem_fn)>::arg_type<0>, const volatile int * &&>);
static_assert(callable_traits<decltype(&class_114::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_114::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_114::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_114::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_114::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_114::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_114::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_114::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_114::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_114::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_114::mem_fn)>::class_type, class_114>);
struct class_115 { int * const && mem_fn(int * const &&, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_115::mem_fn)>::result_type, int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_115::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_115::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_115::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_115::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_115::mem_fn)>::arg0_type, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_115::mem_fn)>::arg_type<0>, int * const &&>);
static_assert(callable_traits<decltype(&class_115::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_115::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_115::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_115::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_115::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_115::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_115::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_115::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_115::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_115::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_115::mem_fn)>::class_type, class_115>);
struct class_116 { const int * const && mem_fn(const int * const &&) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_116::mem_fn)>::result_type, const int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_116::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_116::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_116::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_116::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_116::mem_fn)>::arg0_type, const int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_116::mem_fn)>::arg_type<0>, const int * const &&>);
static_assert(callable_traits<decltype(&class_116::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_116::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_116::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_116::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_116::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_116::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_116::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_116::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_116::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_116::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_116::mem_fn)>::class_type, class_116>);
struct class_117 { volatile int * const && mem_fn(volatile int * const &&, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_117::mem_fn)>::result_type, volatile int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_117::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_117::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_117::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_117::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_117::mem_fn)>::arg0_type, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_117::mem_fn)>::arg_type<0>, volatile int * const &&>);
static_assert(callable_traits<decltype(&class_117::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_117::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_117::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_117::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_117::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_117::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_117::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_117::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_117::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_117::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_117::mem_fn)>::class_type, class_117>);
struct class_118 { const volatile int * const && mem_fn(const volatile int * const &&) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_118::mem_fn)>::result_type, const volatile int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_118::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_118::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_118::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_118::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_118::mem_fn)>::arg0_type, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_118::mem_fn)>::arg_type<0>, const volatile int * const &&>);
static_assert(callable_traits<decltype(&class_118::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_118::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_118::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_118::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_118::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_118::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_118::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_118::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_118::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_118::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_118::mem_fn)>::class_type, class_118>);
struct class_119 { int * volatile && mem_fn(int * volatile &&, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_119::mem_fn)>::result_type, int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_119::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_119::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_119::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_119::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_119::mem_fn)>::arg0_type, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_119::mem_fn)>::arg_type<0>, int * volatile &&>);
static_assert(callable_traits<decltype(&class_119::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_119::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_119::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_119::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_119::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_119::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_119::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_119::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_119::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_119::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_119::mem_fn)>::class_type, class_119>);
struct class_120 { const int * volatile && mem_fn(const int * volatile &&); };
static_assert(std::is_same_v<callable_traits<decltype(&class_120::mem_fn)>::result_type, const int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_120::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_120::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_120::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_120::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_120::mem_fn)>::arg0_type, const int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_120::mem_fn)>::arg_type<0>, const int * volatile &&>);
static_assert(callable_traits<decltype(&class_120::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_120::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_120::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_120::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_120::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_120::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_120::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_120::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_120::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_120::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_120::mem_fn)>::class_type, class_120>);
struct class_121 { volatile int * volatile && mem_fn(volatile int * volatile &&, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_121::mem_fn)>::result_type, volatile int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_121::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_121::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_121::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_121::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_121::mem_fn)>::arg0_type, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_121::mem_fn)>::arg_type<0>, volatile int * volatile &&>);
static_assert(callable_traits<decltype(&class_121::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_121::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_121::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_121::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_121::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_121::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_121::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_121::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_121::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_121::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_121::mem_fn)>::class_type, class_121>);
struct class_122 { const volatile int * volatile && mem_fn(const volatile int * volatile &&) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_122::mem_fn)>::result_type, const volatile int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_122::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_122::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_122::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_122::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_122::mem_fn)>::arg0_type, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_122::mem_fn)>::arg_type<0>, const volatile int * volatile &&>);
static_assert(callable_traits<decltype(&class_122::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_122::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_122::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_122::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_122::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_122::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_122::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_122::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_122::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_122::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_122::mem_fn)>::class_type, class_122>);
struct class_123 { int * const volatile && mem_fn(int * const volatile &&, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_123::mem_fn)>::result_type, int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_123::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_123::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_123::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_123::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_123::mem_fn)>::arg0_type, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_123::mem_fn)>::arg_type<0>, int * const volatile &&>);
static_assert(callable_traits<decltype(&class_123::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_123::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_123::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_123::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_123::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_123::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_123::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_123::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_123::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_123::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_123::mem_fn)>::class_type, class_123>);
struct class_124 { const int * const volatile && mem_fn(const int * const volatile &&) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_124::mem_fn)>::result_type, const int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_124::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_124::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_124::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_124::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_124::mem_fn)>::arg0_type, const int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_124::mem_fn)>::arg_type<0>, const int * const volatile &&>);
static_assert(callable_traits<decltype(&class_124::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_124::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_124::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_124::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_124::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_124::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_124::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_124::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_124::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_124::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_124::mem_fn)>::class_type, class_124>);
struct class_125 { volatile int * const volatile && mem_fn(volatile int * const volatile &&, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_125::mem_fn)>::result_type, volatile int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_125::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_125::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_125::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_125::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_125::mem_fn)>::arg0_type, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_125::mem_fn)>::arg_type<0>, volatile int * const volatile &&>);
static_assert(callable_traits<decltype(&class_125::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_125::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_125::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_125::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_125::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_125::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_125::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_125::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_125::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_125::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_125::mem_fn)>::class_type, class_125>);
struct class_126 { const volatile int * const volatile && mem_fn(const volatile int * const volatile &&) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_126::mem_fn)>::result_type, const volatile int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_126::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_126::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_126::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_126::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_126::mem_fn)>::arg0_type, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_126::mem_fn)>::arg_type<0>, const volatile int * const volatile &&>);
static_assert(callable_traits<decltype(&class_126::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_126::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_126::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_126::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_126::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_126::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_126::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_126::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_126::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_126::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_126::mem_fn)>::class_type, class_126>);
struct class_127 { float mem_fn(float, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_127::mem_fn)>::result_type, float>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_127::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_127::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_127::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_127::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_127::mem_fn)>::arg0_type, float>);
static_assert(std::is_same_v<callable_traits<decltype(&class_127::mem_fn)>::arg_type<0>, float>);
static_assert(callable_traits<decltype(&class_127::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_127::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_127::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_127::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_127::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_127::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_127::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_127::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_127::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_127::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_127::mem_fn)>::class_type, class_127>);
struct class_128 { float * mem_fn(float *) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_128::mem_fn)>::result_type, float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_128::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_128::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_128::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_128::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_128::mem_fn)>::arg0_type, float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_128::mem_fn)>::arg_type<0>, float *>);
static_assert(callable_traits<decltype(&class_128::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_128::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_128::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_128::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_128::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_128::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_128::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_128::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_128::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_128::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_128::mem_fn)>::class_type, class_128>);
struct class_129 { const float * mem_fn(const float *, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_129::mem_fn)>::result_type, const float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_129::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_129::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_129::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_129::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_129::mem_fn)>::arg0_type, const float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_129::mem_fn)>::arg_type<0>, const float *>);
static_assert(callable_traits<decltype(&class_129::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_129::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_129::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_129::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_129::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_129::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_129::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_129::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_129::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_129::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_129::mem_fn)>::class_type, class_129>);
struct class_130 { volatile float * mem_fn(volatile float *) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_130::mem_fn)>::result_type, volatile float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_130::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_130::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_130::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_130::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_130::mem_fn)>::arg0_type, volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_130::mem_fn)>::arg_type<0>, volatile float *>);
static_assert(callable_traits<decltype(&class_130::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_130::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_130::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_130::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_130::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_130::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_130::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_130::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_130::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_130::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_130::mem_fn)>::class_type, class_130>);
struct class_131 { const volatile float * mem_fn(const volatile float *, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_131::mem_fn)>::result_type, const volatile float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_131::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_131::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_131::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_131::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_131::mem_fn)>::arg0_type, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_131::mem_fn)>::arg_type<0>, const volatile float *>);
static_assert(callable_traits<decltype(&class_131::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_131::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_131::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_131::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_131::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_131::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_131::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_131::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_131::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_131::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_131::mem_fn)>::class_type, class_131>);
struct class_132 { float & mem_fn(float &) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_132::mem_fn)>::result_type, float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_132::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_132::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_132::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_132::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_132::mem_fn)>::arg0_type, float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_132::mem_fn)>::arg_type<0>, float &>);
static_assert(callable_traits<decltype(&class_132::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_132::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_132::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_132::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_132::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_132::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_132::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_132::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_132::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_132::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_132::mem_fn)>::class_type, class_132>);
struct class_133 { const float & mem_fn(const float &, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_133::mem_fn)>::result_type, const float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_133::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_133::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_133::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_133::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_133::mem_fn)>::arg0_type, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_133::mem_fn)>::arg_type<0>, const float &>);
static_assert(callable_traits<decltype(&class_133::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_133::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_133::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_133::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_133::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_133::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_133::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_133::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_133::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_133::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_133::mem_fn)>::class_type, class_133>);
struct class_134 { volatile float & mem_fn(volatile float &) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_134::mem_fn)>::result_type, volatile float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_134::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_134::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_134::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_134::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_134::mem_fn)>::arg0_type, volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_134::mem_fn)>::arg_type<0>, volatile float &>);
static_assert(callable_traits<decltype(&class_134::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_134::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_134::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_134::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_134::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_134::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_134::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_134::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_134::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_134::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_134::mem_fn)>::class_type, class_134>);
struct class_135 { const volatile float & mem_fn(const volatile float &, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_135::mem_fn)>::result_type, const volatile float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_135::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_135::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_135::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_135::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_135::mem_fn)>::arg0_type, const volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_135::mem_fn)>::arg_type<0>, const volatile float &>);
static_assert(callable_traits<decltype(&class_135::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_135::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_135::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_135::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_135::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_135::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_135::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_135::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_135::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_135::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_135::mem_fn)>::class_type, class_135>);
struct class_136 { float * & mem_fn(float * &) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_136::mem_fn)>::result_type, float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_136::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_136::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_136::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_136::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_136::mem_fn)>::arg0_type, float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_136::mem_fn)>::arg_type<0>, float * &>);
static_assert(callable_traits<decltype(&class_136::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_136::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_136::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_136::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_136::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_136::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_136::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_136::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_136::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_136::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_136::mem_fn)>::class_type, class_136>);
struct class_137 { const float * & mem_fn(const float * &, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_137::mem_fn)>::result_type, const float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_137::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_137::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_137::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_137::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_137::mem_fn)>::arg0_type, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_137::mem_fn)>::arg_type<0>, const float * &>);
static_assert(callable_traits<decltype(&class_137::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_137::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_137::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_137::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_137::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_137::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_137::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_137::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_137::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_137::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_137::mem_fn)>::class_type, class_137>);
struct class_138 { volatile float * & mem_fn(volatile float * &) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_138::mem_fn)>::result_type, volatile float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_138::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_138::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_138::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_138::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_138::mem_fn)>::arg0_type, volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_138::mem_fn)>::arg_type<0>, volatile float * &>);
static_assert(callable_traits<decltype(&class_138::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_138::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_138::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_138::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_138::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_138::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_138::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_138::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_138::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_138::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_138::mem_fn)>::class_type, class_138>);
struct class_139 { const volatile float * & mem_fn(const volatile float * &, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_139::mem_fn)>::result_type, const volatile float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_139::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_139::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_139::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_139::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_139::mem_fn)>::arg0_type, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_139::mem_fn)>::arg_type<0>, const volatile float * &>);
static_assert(callable_traits<decltype(&class_139::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_139::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_139::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_139::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_139::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_139::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_139::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_139::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_139::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_139::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_139::mem_fn)>::class_type, class_139>);
struct class_140 { float * const & mem_fn(float * const &) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_140::mem_fn)>::result_type, float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_140::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_140::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_140::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_140::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_140::mem_fn)>::arg0_type, float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_140::mem_fn)>::arg_type<0>, float * const &>);
static_assert(callable_traits<decltype(&class_140::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_140::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_140::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_140::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_140::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_140::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_140::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_140::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_140::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_140::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_140::mem_fn)>::class_type, class_140>);
struct class_141 { const float * const & mem_fn(const float * const &, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_141::mem_fn)>::result_type, const float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_141::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_141::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_141::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_141::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_141::mem_fn)>::arg0_type, const float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_141::mem_fn)>::arg_type<0>, const float * const &>);
static_assert(callable_traits<decltype(&class_141::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_141::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_141::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_141::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_141::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_141::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_141::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_141::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_141::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_141::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_141::mem_fn)>::class_type, class_141>);
struct class_142 { volatile float * const & mem_fn(volatile float * const &) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_142::mem_fn)>::result_type, volatile float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_142::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_142::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_142::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_142::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_142::mem_fn)>::arg0_type, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_142::mem_fn)>::arg_type<0>, volatile float * const &>);
static_assert(callable_traits<decltype(&class_142::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_142::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_142::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_142::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_142::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_142::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_142::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_142::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_142::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_142::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_142::mem_fn)>::class_type, class_142>);
struct class_143 { const volatile float * const & mem_fn(const volatile float * const &, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_143::mem_fn)>::result_type, const volatile float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_143::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_143::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_143::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_143::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_143::mem_fn)>::arg0_type, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_143::mem_fn)>::arg_type<0>, const volatile float * const &>);
static_assert(callable_traits<decltype(&class_143::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_143::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_143::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_143::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_143::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_143::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_143::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_143::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_143::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_143::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_143::mem_fn)>::class_type, class_143>);
struct class_144 { float * volatile & mem_fn(float * volatile &); };
static_assert(std::is_same_v<callable_traits<decltype(&class_144::mem_fn)>::result_type, float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_144::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_144::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_144::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_144::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_144::mem_fn)>::arg0_type, float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_144::mem_fn)>::arg_type<0>, float * volatile &>);
static_assert(callable_traits<decltype(&class_144::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_144::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_144::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_144::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_144::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_144::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_144::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_144::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_144::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_144::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_144::mem_fn)>::class_type, class_144>);
struct class_145 { const float * volatile & mem_fn(const float * volatile &, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_145::mem_fn)>::result_type, const float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_145::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_145::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_145::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_145::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_145::mem_fn)>::arg0_type, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_145::mem_fn)>::arg_type<0>, const float * volatile &>);
static_assert(callable_traits<decltype(&class_145::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_145::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_145::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_145::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_145::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_145::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_145::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_145::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_145::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_145::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_145::mem_fn)>::class_type, class_145>);
struct class_146 { volatile float * volatile & mem_fn(volatile float * volatile &) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_146::mem_fn)>::result_type, volatile float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_146::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_146::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_146::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_146::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_146::mem_fn)>::arg0_type, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_146::mem_fn)>::arg_type<0>, volatile float * volatile &>);
static_assert(callable_traits<decltype(&class_146::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_146::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_146::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_146::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_146::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_146::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_146::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_146::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_146::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_146::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_146::mem_fn)>::class_type, class_146>);
struct class_147 { const volatile float * volatile & mem_fn(const volatile float * volatile &, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_147::mem_fn)>::result_type, const volatile float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_147::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_147::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_147::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_147::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_147::mem_fn)>::arg0_type, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_147::mem_fn)>::arg_type<0>, const volatile float * volatile &>);
static_assert(callable_traits<decltype(&class_147::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_147::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_147::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_147::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_147::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_147::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_147::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_147::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_147::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_147::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_147::mem_fn)>::class_type, class_147>);
struct class_148 { float * const volatile & mem_fn(float * const volatile &) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_148::mem_fn)>::result_type, float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_148::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_148::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_148::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_148::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_148::mem_fn)>::arg0_type, float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_148::mem_fn)>::arg_type<0>, float * const volatile &>);
static_assert(callable_traits<decltype(&class_148::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_148::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_148::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_148::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_148::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_148::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_148::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_148::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_148::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_148::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_148::mem_fn)>::class_type, class_148>);
struct class_149 { const float * const volatile & mem_fn(const float * const volatile &, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_149::mem_fn)>::result_type, const float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_149::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_149::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_149::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_149::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_149::mem_fn)>::arg0_type, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_149::mem_fn)>::arg_type<0>, const float * const volatile &>);
static_assert(callable_traits<decltype(&class_149::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_149::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_149::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_149::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_149::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_149::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_149::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_149::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_149::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_149::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_149::mem_fn)>::class_type, class_149>);
struct class_150 { volatile float * const volatile & mem_fn(volatile float * const volatile &) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_150::mem_fn)>::result_type, volatile float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_150::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_150::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_150::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_150::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_150::mem_fn)>::arg0_type, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_150::mem_fn)>::arg_type<0>, volatile float * const volatile &>);
static_assert(callable_traits<decltype(&class_150::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_150::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_150::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_150::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_150::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_150::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_150::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_150::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_150::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_150::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_150::mem_fn)>::class_type, class_150>);
struct class_151 { const volatile float * const volatile & mem_fn(const volatile float * const volatile &, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_151::mem_fn)>::result_type, const volatile float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_151::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_151::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_151::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_151::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_151::mem_fn)>::arg0_type, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_151::mem_fn)>::arg_type<0>, const volatile float * const volatile &>);
static_assert(callable_traits<decltype(&class_151::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_151::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_151::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_151::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_151::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_151::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_151::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_151::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_151::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_151::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_151::mem_fn)>::class_type, class_151>);
struct class_152 { float && mem_fn(float &&) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_152::mem_fn)>::result_type, float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_152::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_152::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_152::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_152::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_152::mem_fn)>::arg0_type, float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_152::mem_fn)>::arg_type<0>, float &&>);
static_assert(callable_traits<decltype(&class_152::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_152::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_152::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_152::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_152::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_152::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_152::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_152::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_152::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_152::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_152::mem_fn)>::class_type, class_152>);
struct class_153 { const float && mem_fn(const float &&, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_153::mem_fn)>::result_type, const float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_153::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_153::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_153::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_153::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_153::mem_fn)>::arg0_type, const float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_153::mem_fn)>::arg_type<0>, const float &&>);
static_assert(callable_traits<decltype(&class_153::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_153::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_153::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_153::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_153::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_153::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_153::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_153::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_153::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_153::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_153::mem_fn)>::class_type, class_153>);
struct class_154 { volatile float && mem_fn(volatile float &&) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_154::mem_fn)>::result_type, volatile float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_154::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_154::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_154::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_154::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_154::mem_fn)>::arg0_type, volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_154::mem_fn)>::arg_type<0>, volatile float &&>);
static_assert(callable_traits<decltype(&class_154::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_154::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_154::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_154::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_154::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_154::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_154::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_154::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_154::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_154::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_154::mem_fn)>::class_type, class_154>);
struct class_155 { const volatile float && mem_fn(const volatile float &&, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_155::mem_fn)>::result_type, const volatile float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_155::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_155::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_155::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_155::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_155::mem_fn)>::arg0_type, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_155::mem_fn)>::arg_type<0>, const volatile float &&>);
static_assert(callable_traits<decltype(&class_155::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_155::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_155::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_155::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_155::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_155::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_155::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_155::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_155::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_155::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_155::mem_fn)>::class_type, class_155>);
struct class_156 { float * && mem_fn(float * &&) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_156::mem_fn)>::result_type, float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_156::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_156::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_156::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_156::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_156::mem_fn)>::arg0_type, float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_156::mem_fn)>::arg_type<0>, float * &&>);
static_assert(callable_traits<decltype(&class_156::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_156::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_156::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_156::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_156::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_156::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_156::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_156::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_156::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_156::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_156::mem_fn)>::class_type, class_156>);
struct class_157 { const float * && mem_fn(const float * &&, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_157::mem_fn)>::result_type, const float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_157::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_157::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_157::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_157::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_157::mem_fn)>::arg0_type, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_157::mem_fn)>::arg_type<0>, const float * &&>);
static_assert(callable_traits<decltype(&class_157::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_157::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_157::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_157::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_157::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_157::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_157::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_157::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_157::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_157::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_157::mem_fn)>::class_type, class_157>);
struct class_158 { volatile float * && mem_fn(volatile float * &&) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_158::mem_fn)>::result_type, volatile float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_158::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_158::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_158::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_158::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_158::mem_fn)>::arg0_type, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_158::mem_fn)>::arg_type<0>, volatile float * &&>);
static_assert(callable_traits<decltype(&class_158::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_158::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_158::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_158::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_158::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_158::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_158::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_158::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_158::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_158::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_158::mem_fn)>::class_type, class_158>);
struct class_159 { const volatile float * && mem_fn(const volatile float * &&, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_159::mem_fn)>::result_type, const volatile float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_159::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_159::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_159::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_159::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_159::mem_fn)>::arg0_type, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_159::mem_fn)>::arg_type<0>, const volatile float * &&>);
static_assert(callable_traits<decltype(&class_159::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_159::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_159::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_159::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_159::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_159::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_159::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_159::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_159::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_159::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_159::mem_fn)>::class_type, class_159>);
struct class_160 { float * const && mem_fn(float * const &&) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_160::mem_fn)>::result_type, float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_160::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_160::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_160::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_160::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_160::mem_fn)>::arg0_type, float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_160::mem_fn)>::arg_type<0>, float * const &&>);
static_assert(callable_traits<decltype(&class_160::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_160::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_160::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_160::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_160::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_160::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_160::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_160::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_160::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_160::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_160::mem_fn)>::class_type, class_160>);
struct class_161 { const float * const && mem_fn(const float * const &&, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_161::mem_fn)>::result_type, const float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_161::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_161::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_161::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_161::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_161::mem_fn)>::arg0_type, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_161::mem_fn)>::arg_type<0>, const float * const &&>);
static_assert(callable_traits<decltype(&class_161::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_161::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_161::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_161::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_161::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_161::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_161::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_161::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_161::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_161::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_161::mem_fn)>::class_type, class_161>);
struct class_162 { volatile float * const && mem_fn(volatile float * const &&) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_162::mem_fn)>::result_type, volatile float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_162::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_162::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_162::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_162::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_162::mem_fn)>::arg0_type, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_162::mem_fn)>::arg_type<0>, volatile float * const &&>);
static_assert(callable_traits<decltype(&class_162::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_162::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_162::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_162::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_162::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_162::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_162::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_162::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_162::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_162::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_162::mem_fn)>::class_type, class_162>);
struct class_163 { const volatile float * const && mem_fn(const volatile float * const &&, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_163::mem_fn)>::result_type, const volatile float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_163::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_163::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_163::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_163::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_163::mem_fn)>::arg0_type, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_163::mem_fn)>::arg_type<0>, const volatile float * const &&>);
static_assert(callable_traits<decltype(&class_163::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_163::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_163::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_163::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_163::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_163::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_163::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_163::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_163::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_163::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_163::mem_fn)>::class_type, class_163>);
struct class_164 { float * volatile && mem_fn(float * volatile &&) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_164::mem_fn)>::result_type, float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_164::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_164::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_164::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_164::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_164::mem_fn)>::arg0_type, float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_164::mem_fn)>::arg_type<0>, float * volatile &&>);
static_assert(callable_traits<decltype(&class_164::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_164::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_164::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_164::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_164::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_164::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_164::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_164::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_164::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_164::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_164::mem_fn)>::class_type, class_164>);
struct class_165 { const float * volatile && mem_fn(const float * volatile &&, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_165::mem_fn)>::result_type, const float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_165::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_165::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_165::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_165::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_165::mem_fn)>::arg0_type, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_165::mem_fn)>::arg_type<0>, const float * volatile &&>);
static_assert(callable_traits<decltype(&class_165::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_165::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_165::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_165::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_165::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_165::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_165::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_165::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_165::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_165::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_165::mem_fn)>::class_type, class_165>);
struct class_166 { volatile float * volatile && mem_fn(volatile float * volatile &&) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_166::mem_fn)>::result_type, volatile float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_166::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_166::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_166::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_166::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_166::mem_fn)>::arg0_type, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_166::mem_fn)>::arg_type<0>, volatile float * volatile &&>);
static_assert(callable_traits<decltype(&class_166::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_166::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_166::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_166::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_166::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_166::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_166::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_166::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_166::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_166::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_166::mem_fn)>::class_type, class_166>);
struct class_167 { const volatile float * volatile && mem_fn(const volatile float * volatile &&, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_167::mem_fn)>::result_type, const volatile float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_167::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_167::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_167::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_167::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_167::mem_fn)>::arg0_type, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_167::mem_fn)>::arg_type<0>, const volatile float * volatile &&>);
static_assert(callable_traits<decltype(&class_167::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_167::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_167::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_167::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_167::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_167::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_167::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_167::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_167::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_167::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_167::mem_fn)>::class_type, class_167>);
struct class_168 { float * const volatile && mem_fn(float * const volatile &&); };
static_assert(std::is_same_v<callable_traits<decltype(&class_168::mem_fn)>::result_type, float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_168::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_168::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_168::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_168::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_168::mem_fn)>::arg0_type, float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_168::mem_fn)>::arg_type<0>, float * const volatile &&>);
static_assert(callable_traits<decltype(&class_168::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_168::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_168::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_168::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_168::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_168::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_168::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_168::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_168::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_168::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_168::mem_fn)>::class_type, class_168>);
struct class_169 { const float * const volatile && mem_fn(const float * const volatile &&, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_169::mem_fn)>::result_type, const float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_169::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_169::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_169::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_169::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_169::mem_fn)>::arg0_type, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_169::mem_fn)>::arg_type<0>, const float * const volatile &&>);
static_assert(callable_traits<decltype(&class_169::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_169::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_169::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_169::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_169::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_169::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_169::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_169::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_169::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_169::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_169::mem_fn)>::class_type, class_169>);
struct class_170 { volatile float * const volatile && mem_fn(volatile float * const volatile &&) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_170::mem_fn)>::result_type, volatile float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_170::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_170::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_170::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_170::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_170::mem_fn)>::arg0_type, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_170::mem_fn)>::arg_type<0>, volatile float * const volatile &&>);
static_assert(callable_traits<decltype(&class_170::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_170::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_170::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_170::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_170::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_170::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_170::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_170::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_170::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_170::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_170::mem_fn)>::class_type, class_170>);
struct class_171 { const volatile float * const volatile && mem_fn(const volatile float * const volatile &&, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_171::mem_fn)>::result_type, const volatile float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_171::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_171::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_171::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_171::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_171::mem_fn)>::arg0_type, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_171::mem_fn)>::arg_type<0>, const volatile float * const volatile &&>);
static_assert(callable_traits<decltype(&class_171::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_171::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_171::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_171::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_171::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_171::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_171::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_171::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_171::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_171::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_171::mem_fn)>::class_type, class_171>);
struct class_172 { std::string mem_fn(std::string) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_172::mem_fn)>::result_type, std::string>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_172::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_172::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_172::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_172::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_172::mem_fn)>::arg0_type, std::string>);
static_assert(std::is_same_v<callable_traits<decltype(&class_172::mem_fn)>::arg_type<0>, std::string>);
static_assert(callable_traits<decltype(&class_172::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_172::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_172::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_172::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_172::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_172::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_172::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_172::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_172::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_172::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_172::mem_fn)>::class_type, class_172>);
struct class_173 { std::string * mem_fn(std::string *, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_173::mem_fn)>::result_type, std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_173::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_173::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_173::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_173::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_173::mem_fn)>::arg0_type, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_173::mem_fn)>::arg_type<0>, std::string *>);
static_assert(callable_traits<decltype(&class_173::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_173::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_173::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_173::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_173::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_173::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_173::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_173::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_173::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_173::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_173::mem_fn)>::class_type, class_173>);
struct class_174 { const std::string * mem_fn(const std::string *) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_174::mem_fn)>::result_type, const std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_174::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_174::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_174::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_174::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_174::mem_fn)>::arg0_type, const std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_174::mem_fn)>::arg_type<0>, const std::string *>);
static_assert(callable_traits<decltype(&class_174::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_174::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_174::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_174::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_174::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_174::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_174::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_174::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_174::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_174::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_174::mem_fn)>::class_type, class_174>);
struct class_175 { volatile std::string * mem_fn(volatile std::string *, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_175::mem_fn)>::result_type, volatile std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_175::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_175::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_175::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_175::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_175::mem_fn)>::arg0_type, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_175::mem_fn)>::arg_type<0>, volatile std::string *>);
static_assert(callable_traits<decltype(&class_175::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_175::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_175::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_175::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_175::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_175::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_175::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_175::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_175::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_175::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_175::mem_fn)>::class_type, class_175>);
struct class_176 { const volatile std::string * mem_fn(const volatile std::string *) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_176::mem_fn)>::result_type, const volatile std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_176::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_176::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_176::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_176::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_176::mem_fn)>::arg0_type, const volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_176::mem_fn)>::arg_type<0>, const volatile std::string *>);
static_assert(callable_traits<decltype(&class_176::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_176::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_176::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_176::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_176::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_176::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_176::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_176::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_176::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_176::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_176::mem_fn)>::class_type, class_176>);
struct class_177 { std::string & mem_fn(std::string &, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_177::mem_fn)>::result_type, std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_177::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_177::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_177::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_177::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_177::mem_fn)>::arg0_type, std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_177::mem_fn)>::arg_type<0>, std::string &>);
static_assert(callable_traits<decltype(&class_177::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_177::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_177::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_177::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_177::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_177::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_177::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_177::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_177::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_177::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_177::mem_fn)>::class_type, class_177>);
struct class_178 { const std::string & mem_fn(const std::string &) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_178::mem_fn)>::result_type, const std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_178::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_178::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_178::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_178::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_178::mem_fn)>::arg0_type, const std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_178::mem_fn)>::arg_type<0>, const std::string &>);
static_assert(callable_traits<decltype(&class_178::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_178::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_178::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_178::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_178::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_178::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_178::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_178::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_178::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_178::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_178::mem_fn)>::class_type, class_178>);
struct class_179 { volatile std::string & mem_fn(volatile std::string &, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_179::mem_fn)>::result_type, volatile std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_179::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_179::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_179::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_179::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_179::mem_fn)>::arg0_type, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_179::mem_fn)>::arg_type<0>, volatile std::string &>);
static_assert(callable_traits<decltype(&class_179::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_179::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_179::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_179::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_179::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_179::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_179::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_179::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_179::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_179::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_179::mem_fn)>::class_type, class_179>);
struct class_180 { const volatile std::string & mem_fn(const volatile std::string &) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_180::mem_fn)>::result_type, const volatile std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_180::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_180::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_180::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_180::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_180::mem_fn)>::arg0_type, const volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_180::mem_fn)>::arg_type<0>, const volatile std::string &>);
static_assert(callable_traits<decltype(&class_180::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_180::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_180::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_180::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_180::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_180::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_180::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_180::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_180::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_180::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_180::mem_fn)>::class_type, class_180>);
struct class_181 { std::string * & mem_fn(std::string * &, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_181::mem_fn)>::result_type, std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_181::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_181::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_181::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_181::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_181::mem_fn)>::arg0_type, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_181::mem_fn)>::arg_type<0>, std::string * &>);
static_assert(callable_traits<decltype(&class_181::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_181::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_181::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_181::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_181::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_181::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_181::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_181::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_181::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_181::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_181::mem_fn)>::class_type, class_181>);
struct class_182 { const std::string * & mem_fn(const std::string * &) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_182::mem_fn)>::result_type, const std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_182::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_182::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_182::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_182::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_182::mem_fn)>::arg0_type, const std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_182::mem_fn)>::arg_type<0>, const std::string * &>);
static_assert(callable_traits<decltype(&class_182::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_182::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_182::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_182::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_182::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_182::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_182::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_182::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_182::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_182::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_182::mem_fn)>::class_type, class_182>);
struct class_183 { volatile std::string * & mem_fn(volatile std::string * &, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_183::mem_fn)>::result_type, volatile std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_183::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_183::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_183::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_183::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_183::mem_fn)>::arg0_type, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_183::mem_fn)>::arg_type<0>, volatile std::string * &>);
static_assert(callable_traits<decltype(&class_183::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_183::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_183::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_183::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_183::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_183::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_183::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_183::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_183::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_183::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_183::mem_fn)>::class_type, class_183>);
struct class_184 { const volatile std::string * & mem_fn(const volatile std::string * &) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_184::mem_fn)>::result_type, const volatile std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_184::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_184::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_184::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_184::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_184::mem_fn)>::arg0_type, const volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_184::mem_fn)>::arg_type<0>, const volatile std::string * &>);
static_assert(callable_traits<decltype(&class_184::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_184::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_184::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_184::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_184::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_184::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_184::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_184::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_184::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_184::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_184::mem_fn)>::class_type, class_184>);
struct class_185 { std::string * const & mem_fn(std::string * const &, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_185::mem_fn)>::result_type, std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_185::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_185::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_185::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_185::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_185::mem_fn)>::arg0_type, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_185::mem_fn)>::arg_type<0>, std::string * const &>);
static_assert(callable_traits<decltype(&class_185::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_185::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_185::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_185::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_185::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_185::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_185::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_185::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_185::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_185::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_185::mem_fn)>::class_type, class_185>);
struct class_186 { const std::string * const & mem_fn(const std::string * const &) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_186::mem_fn)>::result_type, const std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_186::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_186::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_186::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_186::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_186::mem_fn)>::arg0_type, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_186::mem_fn)>::arg_type<0>, const std::string * const &>);
static_assert(callable_traits<decltype(&class_186::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_186::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_186::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_186::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_186::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_186::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_186::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_186::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_186::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_186::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_186::mem_fn)>::class_type, class_186>);
struct class_187 { volatile std::string * const & mem_fn(volatile std::string * const &, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_187::mem_fn)>::result_type, volatile std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_187::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_187::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_187::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_187::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_187::mem_fn)>::arg0_type, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_187::mem_fn)>::arg_type<0>, volatile std::string * const &>);
static_assert(callable_traits<decltype(&class_187::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_187::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_187::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_187::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_187::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_187::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_187::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_187::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_187::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_187::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_187::mem_fn)>::class_type, class_187>);
struct class_188 { const volatile std::string * const & mem_fn(const volatile std::string * const &) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_188::mem_fn)>::result_type, const volatile std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_188::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_188::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_188::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_188::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_188::mem_fn)>::arg0_type, const volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_188::mem_fn)>::arg_type<0>, const volatile std::string * const &>);
static_assert(callable_traits<decltype(&class_188::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_188::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_188::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_188::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_188::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_188::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_188::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_188::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_188::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_188::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_188::mem_fn)>::class_type, class_188>);
struct class_189 { std::string * volatile & mem_fn(std::string * volatile &, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_189::mem_fn)>::result_type, std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_189::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_189::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_189::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_189::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_189::mem_fn)>::arg0_type, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_189::mem_fn)>::arg_type<0>, std::string * volatile &>);
static_assert(callable_traits<decltype(&class_189::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_189::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_189::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_189::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_189::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_189::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_189::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_189::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_189::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_189::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_189::mem_fn)>::class_type, class_189>);
struct class_190 { const std::string * volatile & mem_fn(const std::string * volatile &) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_190::mem_fn)>::result_type, const std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_190::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_190::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_190::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_190::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_190::mem_fn)>::arg0_type, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_190::mem_fn)>::arg_type<0>, const std::string * volatile &>);
static_assert(callable_traits<decltype(&class_190::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_190::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_190::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_190::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_190::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_190::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_190::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_190::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_190::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_190::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_190::mem_fn)>::class_type, class_190>);
struct class_191 { volatile std::string * volatile & mem_fn(volatile std::string * volatile &, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_191::mem_fn)>::result_type, volatile std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_191::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_191::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_191::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_191::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_191::mem_fn)>::arg0_type, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_191::mem_fn)>::arg_type<0>, volatile std::string * volatile &>);
static_assert(callable_traits<decltype(&class_191::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_191::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_191::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_191::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_191::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_191::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_191::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_191::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_191::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_191::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_191::mem_fn)>::class_type, class_191>);
struct class_192 { const volatile std::string * volatile & mem_fn(const volatile std::string * volatile &); };
static_assert(std::is_same_v<callable_traits<decltype(&class_192::mem_fn)>::result_type, const volatile std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_192::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_192::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_192::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_192::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_192::mem_fn)>::arg0_type, const volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_192::mem_fn)>::arg_type<0>, const volatile std::string * volatile &>);
static_assert(callable_traits<decltype(&class_192::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_192::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_192::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_192::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_192::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_192::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_192::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_192::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_192::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_192::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_192::mem_fn)>::class_type, class_192>);
struct class_193 { std::string * const volatile & mem_fn(std::string * const volatile &, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_193::mem_fn)>::result_type, std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_193::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_193::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_193::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_193::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_193::mem_fn)>::arg0_type, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_193::mem_fn)>::arg_type<0>, std::string * const volatile &>);
static_assert(callable_traits<decltype(&class_193::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_193::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_193::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_193::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_193::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_193::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_193::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_193::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_193::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_193::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_193::mem_fn)>::class_type, class_193>);
struct class_194 { const std::string * const volatile & mem_fn(const std::string * const volatile &) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_194::mem_fn)>::result_type, const std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_194::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_194::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_194::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_194::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_194::mem_fn)>::arg0_type, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_194::mem_fn)>::arg_type<0>, const std::string * const volatile &>);
static_assert(callable_traits<decltype(&class_194::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_194::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_194::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_194::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_194::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_194::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_194::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_194::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_194::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_194::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_194::mem_fn)>::class_type, class_194>);
struct class_195 { volatile std::string * const volatile & mem_fn(volatile std::string * const volatile &, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_195::mem_fn)>::result_type, volatile std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_195::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_195::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_195::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_195::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_195::mem_fn)>::arg0_type, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_195::mem_fn)>::arg_type<0>, volatile std::string * const volatile &>);
static_assert(callable_traits<decltype(&class_195::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_195::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_195::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_195::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_195::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_195::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_195::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_195::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_195::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_195::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_195::mem_fn)>::class_type, class_195>);
struct class_196 { const volatile std::string * const volatile & mem_fn(const volatile std::string * const volatile &) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_196::mem_fn)>::result_type, const volatile std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_196::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_196::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_196::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_196::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_196::mem_fn)>::arg0_type, const volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_196::mem_fn)>::arg_type<0>, const volatile std::string * const volatile &>);
static_assert(callable_traits<decltype(&class_196::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_196::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_196::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_196::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_196::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_196::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_196::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_196::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_196::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_196::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_196::mem_fn)>::class_type, class_196>);
struct class_197 { std::string && mem_fn(std::string &&, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_197::mem_fn)>::result_type, std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_197::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_197::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_197::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_197::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_197::mem_fn)>::arg0_type, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_197::mem_fn)>::arg_type<0>, std::string &&>);
static_assert(callable_traits<decltype(&class_197::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_197::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_197::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_197::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_197::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_197::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_197::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_197::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_197::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_197::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_197::mem_fn)>::class_type, class_197>);
struct class_198 { const std::string && mem_fn(const std::string &&) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_198::mem_fn)>::result_type, const std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_198::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_198::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_198::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_198::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_198::mem_fn)>::arg0_type, const std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_198::mem_fn)>::arg_type<0>, const std::string &&>);
static_assert(callable_traits<decltype(&class_198::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_198::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_198::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_198::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_198::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_198::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_198::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_198::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_198::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_198::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_198::mem_fn)>::class_type, class_198>);
struct class_199 { volatile std::string && mem_fn(volatile std::string &&, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_199::mem_fn)>::result_type, volatile std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_199::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_199::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_199::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_199::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_199::mem_fn)>::arg0_type, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_199::mem_fn)>::arg_type<0>, volatile std::string &&>);
static_assert(callable_traits<decltype(&class_199::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_199::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_199::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_199::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_199::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_199::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_199::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_199::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_199::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_199::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_199::mem_fn)>::class_type, class_199>);
struct class_200 { const volatile std::string && mem_fn(const volatile std::string &&) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_200::mem_fn)>::result_type, const volatile std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_200::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_200::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_200::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_200::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_200::mem_fn)>::arg0_type, const volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_200::mem_fn)>::arg_type<0>, const volatile std::string &&>);
static_assert(callable_traits<decltype(&class_200::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_200::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_200::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_200::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_200::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_200::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_200::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_200::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_200::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_200::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_200::mem_fn)>::class_type, class_200>);
struct class_201 { std::string * && mem_fn(std::string * &&, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_201::mem_fn)>::result_type, std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_201::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_201::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_201::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_201::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_201::mem_fn)>::arg0_type, std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_201::mem_fn)>::arg_type<0>, std::string * &&>);
static_assert(callable_traits<decltype(&class_201::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_201::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_201::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_201::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_201::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_201::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_201::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_201::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_201::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_201::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_201::mem_fn)>::class_type, class_201>);
struct class_202 { const std::string * && mem_fn(const std::string * &&) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_202::mem_fn)>::result_type, const std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_202::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_202::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_202::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_202::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_202::mem_fn)>::arg0_type, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_202::mem_fn)>::arg_type<0>, const std::string * &&>);
static_assert(callable_traits<decltype(&class_202::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_202::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_202::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_202::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_202::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_202::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_202::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_202::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_202::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_202::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_202::mem_fn)>::class_type, class_202>);
struct class_203 { volatile std::string * && mem_fn(volatile std::string * &&, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_203::mem_fn)>::result_type, volatile std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_203::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_203::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_203::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_203::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_203::mem_fn)>::arg0_type, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_203::mem_fn)>::arg_type<0>, volatile std::string * &&>);
static_assert(callable_traits<decltype(&class_203::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_203::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_203::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_203::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_203::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_203::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_203::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_203::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_203::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_203::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_203::mem_fn)>::class_type, class_203>);
struct class_204 { const volatile std::string * && mem_fn(const volatile std::string * &&) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_204::mem_fn)>::result_type, const volatile std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_204::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_204::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_204::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_204::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_204::mem_fn)>::arg0_type, const volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_204::mem_fn)>::arg_type<0>, const volatile std::string * &&>);
static_assert(callable_traits<decltype(&class_204::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_204::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_204::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_204::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_204::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_204::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_204::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_204::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_204::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_204::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_204::mem_fn)>::class_type, class_204>);
struct class_205 { std::string * const && mem_fn(std::string * const &&, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_205::mem_fn)>::result_type, std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_205::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_205::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_205::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_205::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_205::mem_fn)>::arg0_type, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_205::mem_fn)>::arg_type<0>, std::string * const &&>);
static_assert(callable_traits<decltype(&class_205::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_205::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_205::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_205::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_205::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_205::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_205::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_205::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_205::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_205::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_205::mem_fn)>::class_type, class_205>);
struct class_206 { const std::string * const && mem_fn(const std::string * const &&) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_206::mem_fn)>::result_type, const std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_206::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_206::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_206::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_206::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_206::mem_fn)>::arg0_type, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_206::mem_fn)>::arg_type<0>, const std::string * const &&>);
static_assert(callable_traits<decltype(&class_206::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_206::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_206::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_206::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_206::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_206::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_206::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_206::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_206::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_206::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_206::mem_fn)>::class_type, class_206>);
struct class_207 { volatile std::string * const && mem_fn(volatile std::string * const &&, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_207::mem_fn)>::result_type, volatile std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_207::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_207::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_207::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_207::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_207::mem_fn)>::arg0_type, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_207::mem_fn)>::arg_type<0>, volatile std::string * const &&>);
static_assert(callable_traits<decltype(&class_207::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_207::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_207::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_207::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_207::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_207::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_207::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_207::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_207::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_207::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_207::mem_fn)>::class_type, class_207>);
struct class_208 { const volatile std::string * const && mem_fn(const volatile std::string * const &&) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_208::mem_fn)>::result_type, const volatile std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_208::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_208::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_208::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_208::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_208::mem_fn)>::arg0_type, const volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_208::mem_fn)>::arg_type<0>, const volatile std::string * const &&>);
static_assert(callable_traits<decltype(&class_208::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_208::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_208::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_208::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_208::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_208::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_208::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_208::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_208::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_208::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_208::mem_fn)>::class_type, class_208>);
struct class_209 { std::string * volatile && mem_fn(std::string * volatile &&, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_209::mem_fn)>::result_type, std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_209::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_209::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_209::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_209::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_209::mem_fn)>::arg0_type, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_209::mem_fn)>::arg_type<0>, std::string * volatile &&>);
static_assert(callable_traits<decltype(&class_209::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_209::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_209::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_209::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_209::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_209::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_209::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_209::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_209::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_209::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_209::mem_fn)>::class_type, class_209>);
struct class_210 { const std::string * volatile && mem_fn(const std::string * volatile &&) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_210::mem_fn)>::result_type, const std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_210::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_210::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_210::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_210::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_210::mem_fn)>::arg0_type, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_210::mem_fn)>::arg_type<0>, const std::string * volatile &&>);
static_assert(callable_traits<decltype(&class_210::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_210::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_210::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_210::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_210::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_210::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_210::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_210::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_210::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_210::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_210::mem_fn)>::class_type, class_210>);
struct class_211 { volatile std::string * volatile && mem_fn(volatile std::string * volatile &&, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_211::mem_fn)>::result_type, volatile std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_211::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_211::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_211::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_211::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_211::mem_fn)>::arg0_type, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_211::mem_fn)>::arg_type<0>, volatile std::string * volatile &&>);
static_assert(callable_traits<decltype(&class_211::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_211::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_211::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_211::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_211::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_211::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_211::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_211::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_211::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_211::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_211::mem_fn)>::class_type, class_211>);
struct class_212 { const volatile std::string * volatile && mem_fn(const volatile std::string * volatile &&) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_212::mem_fn)>::result_type, const volatile std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_212::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_212::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_212::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_212::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_212::mem_fn)>::arg0_type, const volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_212::mem_fn)>::arg_type<0>, const volatile std::string * volatile &&>);
static_assert(callable_traits<decltype(&class_212::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_212::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_212::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_212::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_212::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_212::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_212::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_212::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_212::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_212::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_212::mem_fn)>::class_type, class_212>);
struct class_213 { std::string * const volatile && mem_fn(std::string * const volatile &&, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_213::mem_fn)>::result_type, std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_213::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_213::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_213::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_213::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_213::mem_fn)>::arg0_type, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_213::mem_fn)>::arg_type<0>, std::string * const volatile &&>);
static_assert(callable_traits<decltype(&class_213::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_213::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_213::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_213::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_213::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_213::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_213::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_213::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_213::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_213::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_213::mem_fn)>::class_type, class_213>);
struct class_214 { const std::string * const volatile && mem_fn(const std::string * const volatile &&) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_214::mem_fn)>::result_type, const std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_214::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_214::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_214::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_214::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_214::mem_fn)>::arg0_type, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_214::mem_fn)>::arg_type<0>, const std::string * const volatile &&>);
static_assert(callable_traits<decltype(&class_214::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_214::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_214::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_214::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_214::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_214::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_214::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_214::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_214::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_214::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_214::mem_fn)>::class_type, class_214>);
struct class_215 { volatile std::string * const volatile && mem_fn(volatile std::string * const volatile &&, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_215::mem_fn)>::result_type, volatile std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_215::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_215::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_215::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_215::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_215::mem_fn)>::arg0_type, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_215::mem_fn)>::arg_type<0>, volatile std::string * const volatile &&>);
static_assert(callable_traits<decltype(&class_215::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_215::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_215::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_215::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_215::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_215::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_215::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_215::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_215::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_215::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_215::mem_fn)>::class_type, class_215>);
struct class_216 { const volatile std::string * const volatile && mem_fn(const volatile std::string * const volatile &&); };
static_assert(std::is_same_v<callable_traits<decltype(&class_216::mem_fn)>::result_type, const volatile std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_216::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_216::mem_fn)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_216::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_216::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_216::mem_fn)>::arg0_type, const volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_216::mem_fn)>::arg_type<0>, const volatile std::string * const volatile &&>);
static_assert(callable_traits<decltype(&class_216::mem_fn)>::arity == 1);
static_assert(callable_traits<decltype(&class_216::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_216::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_216::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_216::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_216::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_216::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_216::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_216::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_216::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_216::mem_fn)>::class_type, class_216>);
struct class_217 { void mem_fn(void *, const void *, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_217::mem_fn)>::result_type, void>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_217::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_217::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_217::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_217::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_217::mem_fn)>::arg0_type, void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_217::mem_fn)>::arg_type<0>, void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_217::mem_fn)>::arg1_type, const void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_217::mem_fn)>::arg_type<1>, const void *>);
static_assert(callable_traits<decltype(&class_217::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_217::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_217::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_217::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_217::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_217::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_217::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_217::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_217::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_217::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_217::mem_fn)>::class_type, class_217>);
struct class_218 { void * mem_fn(volatile void *, const volatile void *) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_218::mem_fn)>::result_type, void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_218::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_218::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_218::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_218::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_218::mem_fn)>::arg0_type, volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_218::mem_fn)>::arg_type<0>, volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_218::mem_fn)>::arg1_type, const volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_218::mem_fn)>::arg_type<1>, const volatile void *>);
static_assert(callable_traits<decltype(&class_218::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_218::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_218::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_218::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_218::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_218::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_218::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_218::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_218::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_218::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_218::mem_fn)>::class_type, class_218>);
struct class_219 { const void * mem_fn(void * &, const void * &, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_219::mem_fn)>::result_type, const void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_219::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_219::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_219::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_219::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_219::mem_fn)>::arg0_type, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_219::mem_fn)>::arg_type<0>, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_219::mem_fn)>::arg1_type, const void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_219::mem_fn)>::arg_type<1>, const void * &>);
static_assert(callable_traits<decltype(&class_219::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_219::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_219::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_219::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_219::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_219::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_219::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_219::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_219::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_219::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_219::mem_fn)>::class_type, class_219>);
struct class_220 { volatile void * mem_fn(volatile void * &, const volatile void * &) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_220::mem_fn)>::result_type, volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_220::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_220::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_220::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_220::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_220::mem_fn)>::arg0_type, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_220::mem_fn)>::arg_type<0>, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_220::mem_fn)>::arg1_type, const volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_220::mem_fn)>::arg_type<1>, const volatile void * &>);
static_assert(callable_traits<decltype(&class_220::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_220::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_220::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_220::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_220::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_220::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_220::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_220::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_220::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_220::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_220::mem_fn)>::class_type, class_220>);
struct class_221 { const volatile void * mem_fn(void * const &, const void * const &, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_221::mem_fn)>::result_type, const volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_221::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_221::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_221::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_221::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_221::mem_fn)>::arg0_type, void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_221::mem_fn)>::arg_type<0>, void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_221::mem_fn)>::arg1_type, const void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_221::mem_fn)>::arg_type<1>, const void * const &>);
static_assert(callable_traits<decltype(&class_221::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_221::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_221::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_221::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_221::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_221::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_221::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_221::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_221::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_221::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_221::mem_fn)>::class_type, class_221>);
struct class_222 { void * & mem_fn(volatile void * const &, const volatile void * const &) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_222::mem_fn)>::result_type, void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_222::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_222::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_222::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_222::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_222::mem_fn)>::arg0_type, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_222::mem_fn)>::arg_type<0>, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_222::mem_fn)>::arg1_type, const volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_222::mem_fn)>::arg_type<1>, const volatile void * const &>);
static_assert(callable_traits<decltype(&class_222::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_222::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_222::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_222::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_222::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_222::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_222::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_222::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_222::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_222::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_222::mem_fn)>::class_type, class_222>);
struct class_223 { const void * & mem_fn(void * volatile &, const void * volatile &, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_223::mem_fn)>::result_type, const void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_223::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_223::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_223::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_223::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_223::mem_fn)>::arg0_type, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_223::mem_fn)>::arg_type<0>, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_223::mem_fn)>::arg1_type, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_223::mem_fn)>::arg_type<1>, const void * volatile &>);
static_assert(callable_traits<decltype(&class_223::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_223::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_223::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_223::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_223::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_223::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_223::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_223::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_223::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_223::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_223::mem_fn)>::class_type, class_223>);
struct class_224 { volatile void * & mem_fn(volatile void * volatile &, const volatile void * volatile &) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_224::mem_fn)>::result_type, volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_224::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_224::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_224::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_224::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_224::mem_fn)>::arg0_type, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_224::mem_fn)>::arg_type<0>, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_224::mem_fn)>::arg1_type, const volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_224::mem_fn)>::arg_type<1>, const volatile void * volatile &>);
static_assert(callable_traits<decltype(&class_224::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_224::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_224::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_224::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_224::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_224::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_224::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_224::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_224::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_224::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_224::mem_fn)>::class_type, class_224>);
struct class_225 { const volatile void * & mem_fn(void * const volatile &, const void * const volatile &, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_225::mem_fn)>::result_type, const volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_225::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_225::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_225::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_225::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_225::mem_fn)>::arg0_type, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_225::mem_fn)>::arg_type<0>, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_225::mem_fn)>::arg1_type, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_225::mem_fn)>::arg_type<1>, const void * const volatile &>);
static_assert(callable_traits<decltype(&class_225::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_225::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_225::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_225::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_225::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_225::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_225::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_225::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_225::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_225::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_225::mem_fn)>::class_type, class_225>);
struct class_226 { void * const & mem_fn(volatile void * const volatile &, const volatile void * const volatile &) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_226::mem_fn)>::result_type, void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_226::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_226::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_226::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_226::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_226::mem_fn)>::arg0_type, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_226::mem_fn)>::arg_type<0>, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_226::mem_fn)>::arg1_type, const volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_226::mem_fn)>::arg_type<1>, const volatile void * const volatile &>);
static_assert(callable_traits<decltype(&class_226::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_226::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_226::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_226::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_226::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_226::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_226::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_226::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_226::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_226::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_226::mem_fn)>::class_type, class_226>);
struct class_227 { const void * const & mem_fn(void * &&, const void * &&, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_227::mem_fn)>::result_type, const void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_227::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_227::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_227::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_227::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_227::mem_fn)>::arg0_type, void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_227::mem_fn)>::arg_type<0>, void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_227::mem_fn)>::arg1_type, const void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_227::mem_fn)>::arg_type<1>, const void * &&>);
static_assert(callable_traits<decltype(&class_227::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_227::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_227::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_227::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_227::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_227::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_227::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_227::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_227::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_227::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_227::mem_fn)>::class_type, class_227>);
struct class_228 { volatile void * const & mem_fn(volatile void * &&, const volatile void * &&) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_228::mem_fn)>::result_type, volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_228::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_228::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_228::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_228::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_228::mem_fn)>::arg0_type, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_228::mem_fn)>::arg_type<0>, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_228::mem_fn)>::arg1_type, const volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_228::mem_fn)>::arg_type<1>, const volatile void * &&>);
static_assert(callable_traits<decltype(&class_228::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_228::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_228::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_228::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_228::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_228::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_228::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_228::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_228::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_228::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_228::mem_fn)>::class_type, class_228>);
struct class_229 { const volatile void * const & mem_fn(void * const &&, const void * const &&, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_229::mem_fn)>::result_type, const volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_229::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_229::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_229::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_229::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_229::mem_fn)>::arg0_type, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_229::mem_fn)>::arg_type<0>, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_229::mem_fn)>::arg1_type, const void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_229::mem_fn)>::arg_type<1>, const void * const &&>);
static_assert(callable_traits<decltype(&class_229::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_229::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_229::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_229::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_229::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_229::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_229::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_229::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_229::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_229::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_229::mem_fn)>::class_type, class_229>);
struct class_230 { void * volatile & mem_fn(volatile void * const &&, const volatile void * const &&) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_230::mem_fn)>::result_type, void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_230::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_230::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_230::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_230::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_230::mem_fn)>::arg0_type, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_230::mem_fn)>::arg_type<0>, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_230::mem_fn)>::arg1_type, const volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_230::mem_fn)>::arg_type<1>, const volatile void * const &&>);
static_assert(callable_traits<decltype(&class_230::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_230::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_230::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_230::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_230::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_230::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_230::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_230::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_230::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_230::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_230::mem_fn)>::class_type, class_230>);
struct class_231 { const void * volatile & mem_fn(void * volatile &&, const void * volatile &&, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_231::mem_fn)>::result_type, const void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_231::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_231::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_231::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_231::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_231::mem_fn)>::arg0_type, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_231::mem_fn)>::arg_type<0>, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_231::mem_fn)>::arg1_type, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_231::mem_fn)>::arg_type<1>, const void * volatile &&>);
static_assert(callable_traits<decltype(&class_231::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_231::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_231::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_231::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_231::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_231::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_231::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_231::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_231::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_231::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_231::mem_fn)>::class_type, class_231>);
struct class_232 { volatile void * volatile & mem_fn(volatile void * volatile &&, const volatile void * volatile &&) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_232::mem_fn)>::result_type, volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_232::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_232::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_232::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_232::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_232::mem_fn)>::arg0_type, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_232::mem_fn)>::arg_type<0>, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_232::mem_fn)>::arg1_type, const volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_232::mem_fn)>::arg_type<1>, const volatile void * volatile &&>);
static_assert(callable_traits<decltype(&class_232::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_232::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_232::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_232::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_232::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_232::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_232::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_232::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_232::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_232::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_232::mem_fn)>::class_type, class_232>);
struct class_233 { const volatile void * volatile & mem_fn(void * const volatile &&, const void * const volatile &&, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_233::mem_fn)>::result_type, const volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_233::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_233::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_233::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_233::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_233::mem_fn)>::arg0_type, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_233::mem_fn)>::arg_type<0>, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_233::mem_fn)>::arg1_type, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_233::mem_fn)>::arg_type<1>, const void * const volatile &&>);
static_assert(callable_traits<decltype(&class_233::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_233::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_233::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_233::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_233::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_233::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_233::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_233::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_233::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_233::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_233::mem_fn)>::class_type, class_233>);
struct class_234 { void * const volatile & mem_fn(volatile void * const volatile &&, const volatile void * const volatile &&) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_234::mem_fn)>::result_type, void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_234::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_234::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_234::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_234::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_234::mem_fn)>::arg0_type, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_234::mem_fn)>::arg_type<0>, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_234::mem_fn)>::arg1_type, const volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_234::mem_fn)>::arg_type<1>, const volatile void * const volatile &&>);
static_assert(callable_traits<decltype(&class_234::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_234::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_234::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_234::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_234::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_234::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_234::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_234::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_234::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_234::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_234::mem_fn)>::class_type, class_234>);
struct class_235 { const void * const volatile & mem_fn(bool, bool *, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_235::mem_fn)>::result_type, const void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_235::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_235::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_235::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_235::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_235::mem_fn)>::arg0_type, bool>);
static_assert(std::is_same_v<callable_traits<decltype(&class_235::mem_fn)>::arg_type<0>, bool>);
static_assert(std::is_same_v<callable_traits<decltype(&class_235::mem_fn)>::arg1_type, bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_235::mem_fn)>::arg_type<1>, bool *>);
static_assert(callable_traits<decltype(&class_235::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_235::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_235::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_235::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_235::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_235::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_235::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_235::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_235::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_235::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_235::mem_fn)>::class_type, class_235>);
struct class_236 { volatile void * const volatile & mem_fn(const bool *, volatile bool *) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_236::mem_fn)>::result_type, volatile void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_236::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_236::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_236::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_236::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_236::mem_fn)>::arg0_type, const bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_236::mem_fn)>::arg_type<0>, const bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_236::mem_fn)>::arg1_type, volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_236::mem_fn)>::arg_type<1>, volatile bool *>);
static_assert(callable_traits<decltype(&class_236::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_236::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_236::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_236::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_236::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_236::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_236::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_236::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_236::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_236::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_236::mem_fn)>::class_type, class_236>);
struct class_237 { const volatile void * const volatile & mem_fn(const volatile bool *, bool &, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_237::mem_fn)>::result_type, const volatile void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_237::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_237::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_237::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_237::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_237::mem_fn)>::arg0_type, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_237::mem_fn)>::arg_type<0>, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_237::mem_fn)>::arg1_type, bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_237::mem_fn)>::arg_type<1>, bool &>);
static_assert(callable_traits<decltype(&class_237::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_237::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_237::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_237::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_237::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_237::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_237::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_237::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_237::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_237::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_237::mem_fn)>::class_type, class_237>);
struct class_238 { void * && mem_fn(const bool &, volatile bool &) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_238::mem_fn)>::result_type, void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_238::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_238::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_238::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_238::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_238::mem_fn)>::arg0_type, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_238::mem_fn)>::arg_type<0>, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_238::mem_fn)>::arg1_type, volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_238::mem_fn)>::arg_type<1>, volatile bool &>);
static_assert(callable_traits<decltype(&class_238::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_238::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_238::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_238::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_238::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_238::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_238::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_238::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_238::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_238::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_238::mem_fn)>::class_type, class_238>);
struct class_239 { const void * && mem_fn(const volatile bool &, bool * &, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_239::mem_fn)>::result_type, const void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_239::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_239::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_239::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_239::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_239::mem_fn)>::arg0_type, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_239::mem_fn)>::arg_type<0>, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_239::mem_fn)>::arg1_type, bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_239::mem_fn)>::arg_type<1>, bool * &>);
static_assert(callable_traits<decltype(&class_239::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_239::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_239::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_239::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_239::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_239::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_239::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_239::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_239::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_239::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_239::mem_fn)>::class_type, class_239>);
struct class_240 { volatile void * && mem_fn(const bool * &, volatile bool * &); };
static_assert(std::is_same_v<callable_traits<decltype(&class_240::mem_fn)>::result_type, volatile void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_240::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_240::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_240::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_240::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_240::mem_fn)>::arg0_type, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_240::mem_fn)>::arg_type<0>, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_240::mem_fn)>::arg1_type, volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_240::mem_fn)>::arg_type<1>, volatile bool * &>);
static_assert(callable_traits<decltype(&class_240::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_240::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_240::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_240::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_240::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_240::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_240::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_240::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_240::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_240::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_240::mem_fn)>::class_type, class_240>);
struct class_241 { const volatile void * && mem_fn(const volatile bool * &, bool * const &, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_241::mem_fn)>::result_type, const volatile void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_241::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_241::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_241::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_241::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_241::mem_fn)>::arg0_type, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_241::mem_fn)>::arg_type<0>, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_241::mem_fn)>::arg1_type, bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_241::mem_fn)>::arg_type<1>, bool * const &>);
static_assert(callable_traits<decltype(&class_241::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_241::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_241::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_241::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_241::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_241::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_241::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_241::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_241::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_241::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_241::mem_fn)>::class_type, class_241>);
struct class_242 { void * const && mem_fn(const bool * const &, volatile bool * const &) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_242::mem_fn)>::result_type, void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_242::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_242::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_242::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_242::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_242::mem_fn)>::arg0_type, const bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_242::mem_fn)>::arg_type<0>, const bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_242::mem_fn)>::arg1_type, volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_242::mem_fn)>::arg_type<1>, volatile bool * const &>);
static_assert(callable_traits<decltype(&class_242::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_242::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_242::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_242::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_242::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_242::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_242::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_242::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_242::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_242::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_242::mem_fn)>::class_type, class_242>);
struct class_243 { const void * const && mem_fn(const volatile bool * const &, bool * volatile &, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_243::mem_fn)>::result_type, const void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_243::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_243::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_243::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_243::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_243::mem_fn)>::arg0_type, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_243::mem_fn)>::arg_type<0>, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_243::mem_fn)>::arg1_type, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_243::mem_fn)>::arg_type<1>, bool * volatile &>);
static_assert(callable_traits<decltype(&class_243::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_243::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_243::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_243::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_243::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_243::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_243::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_243::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_243::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_243::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_243::mem_fn)>::class_type, class_243>);
struct class_244 { volatile void * const && mem_fn(const bool * volatile &, volatile bool * volatile &) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_244::mem_fn)>::result_type, volatile void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_244::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_244::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_244::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_244::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_244::mem_fn)>::arg0_type, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_244::mem_fn)>::arg_type<0>, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_244::mem_fn)>::arg1_type, volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_244::mem_fn)>::arg_type<1>, volatile bool * volatile &>);
static_assert(callable_traits<decltype(&class_244::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_244::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_244::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_244::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_244::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_244::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_244::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_244::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_244::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_244::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_244::mem_fn)>::class_type, class_244>);
struct class_245 { const volatile void * const && mem_fn(const volatile bool * volatile &, bool * const volatile &, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_245::mem_fn)>::result_type, const volatile void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_245::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_245::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_245::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_245::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_245::mem_fn)>::arg0_type, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_245::mem_fn)>::arg_type<0>, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_245::mem_fn)>::arg1_type, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_245::mem_fn)>::arg_type<1>, bool * const volatile &>);
static_assert(callable_traits<decltype(&class_245::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_245::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_245::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_245::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_245::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_245::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_245::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_245::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_245::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_245::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_245::mem_fn)>::class_type, class_245>);
struct class_246 { void * volatile && mem_fn(const bool * const volatile &, volatile bool * const volatile &) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_246::mem_fn)>::result_type, void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_246::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_246::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_246::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_246::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_246::mem_fn)>::arg0_type, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_246::mem_fn)>::arg_type<0>, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_246::mem_fn)>::arg1_type, volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_246::mem_fn)>::arg_type<1>, volatile bool * const volatile &>);
static_assert(callable_traits<decltype(&class_246::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_246::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_246::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_246::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_246::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_246::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_246::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_246::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_246::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_246::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_246::mem_fn)>::class_type, class_246>);
struct class_247 { const void * volatile && mem_fn(const volatile bool * const volatile &, bool &&, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_247::mem_fn)>::result_type, const void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_247::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_247::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_247::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_247::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_247::mem_fn)>::arg0_type, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_247::mem_fn)>::arg_type<0>, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_247::mem_fn)>::arg1_type, bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_247::mem_fn)>::arg_type<1>, bool &&>);
static_assert(callable_traits<decltype(&class_247::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_247::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_247::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_247::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_247::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_247::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_247::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_247::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_247::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_247::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_247::mem_fn)>::class_type, class_247>);
struct class_248 { volatile void * volatile && mem_fn(const bool &&, volatile bool &&) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_248::mem_fn)>::result_type, volatile void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_248::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_248::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_248::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_248::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_248::mem_fn)>::arg0_type, const bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_248::mem_fn)>::arg_type<0>, const bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_248::mem_fn)>::arg1_type, volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_248::mem_fn)>::arg_type<1>, volatile bool &&>);
static_assert(callable_traits<decltype(&class_248::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_248::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_248::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_248::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_248::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_248::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_248::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_248::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_248::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_248::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_248::mem_fn)>::class_type, class_248>);
struct class_249 { const volatile void * volatile && mem_fn(const volatile bool &&, bool * &&, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_249::mem_fn)>::result_type, const volatile void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_249::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_249::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_249::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_249::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_249::mem_fn)>::arg0_type, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_249::mem_fn)>::arg_type<0>, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_249::mem_fn)>::arg1_type, bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_249::mem_fn)>::arg_type<1>, bool * &&>);
static_assert(callable_traits<decltype(&class_249::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_249::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_249::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_249::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_249::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_249::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_249::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_249::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_249::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_249::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_249::mem_fn)>::class_type, class_249>);
struct class_250 { void * const volatile && mem_fn(const bool * &&, volatile bool * &&) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_250::mem_fn)>::result_type, void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_250::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_250::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_250::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_250::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_250::mem_fn)>::arg0_type, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_250::mem_fn)>::arg_type<0>, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_250::mem_fn)>::arg1_type, volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_250::mem_fn)>::arg_type<1>, volatile bool * &&>);
static_assert(callable_traits<decltype(&class_250::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_250::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_250::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_250::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_250::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_250::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_250::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_250::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_250::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_250::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_250::mem_fn)>::class_type, class_250>);
struct class_251 { const void * const volatile && mem_fn(const volatile bool * &&, bool * const &&, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_251::mem_fn)>::result_type, const void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_251::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_251::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_251::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_251::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_251::mem_fn)>::arg0_type, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_251::mem_fn)>::arg_type<0>, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_251::mem_fn)>::arg1_type, bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_251::mem_fn)>::arg_type<1>, bool * const &&>);
static_assert(callable_traits<decltype(&class_251::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_251::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_251::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_251::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_251::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_251::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_251::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_251::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_251::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_251::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_251::mem_fn)>::class_type, class_251>);
struct class_252 { volatile void * const volatile && mem_fn(const bool * const &&, volatile bool * const &&) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_252::mem_fn)>::result_type, volatile void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_252::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_252::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_252::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_252::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_252::mem_fn)>::arg0_type, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_252::mem_fn)>::arg_type<0>, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_252::mem_fn)>::arg1_type, volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_252::mem_fn)>::arg_type<1>, volatile bool * const &&>);
static_assert(callable_traits<decltype(&class_252::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_252::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_252::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_252::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_252::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_252::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_252::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_252::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_252::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_252::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_252::mem_fn)>::class_type, class_252>);
struct class_253 { const volatile void * const volatile && mem_fn(const volatile bool * const &&, bool * volatile &&, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_253::mem_fn)>::result_type, const volatile void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_253::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_253::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_253::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_253::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_253::mem_fn)>::arg0_type, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_253::mem_fn)>::arg_type<0>, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_253::mem_fn)>::arg1_type, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_253::mem_fn)>::arg_type<1>, bool * volatile &&>);
static_assert(callable_traits<decltype(&class_253::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_253::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_253::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_253::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_253::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_253::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_253::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_253::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_253::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_253::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_253::mem_fn)>::class_type, class_253>);
struct class_254 { bool mem_fn(const bool * volatile &&, volatile bool * volatile &&) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_254::mem_fn)>::result_type, bool>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_254::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_254::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_254::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_254::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_254::mem_fn)>::arg0_type, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_254::mem_fn)>::arg_type<0>, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_254::mem_fn)>::arg1_type, volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_254::mem_fn)>::arg_type<1>, volatile bool * volatile &&>);
static_assert(callable_traits<decltype(&class_254::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_254::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_254::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_254::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_254::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_254::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_254::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_254::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_254::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_254::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_254::mem_fn)>::class_type, class_254>);
struct class_255 { bool * mem_fn(const volatile bool * volatile &&, bool * const volatile &&, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_255::mem_fn)>::result_type, bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_255::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_255::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_255::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_255::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_255::mem_fn)>::arg0_type, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_255::mem_fn)>::arg_type<0>, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_255::mem_fn)>::arg1_type, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_255::mem_fn)>::arg_type<1>, bool * const volatile &&>);
static_assert(callable_traits<decltype(&class_255::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_255::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_255::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_255::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_255::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_255::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_255::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_255::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_255::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_255::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_255::mem_fn)>::class_type, class_255>);
struct class_256 { const bool * mem_fn(const bool * const volatile &&, volatile bool * const volatile &&) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_256::mem_fn)>::result_type, const bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_256::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_256::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_256::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_256::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_256::mem_fn)>::arg0_type, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_256::mem_fn)>::arg_type<0>, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_256::mem_fn)>::arg1_type, volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_256::mem_fn)>::arg_type<1>, volatile bool * const volatile &&>);
static_assert(callable_traits<decltype(&class_256::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_256::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_256::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_256::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_256::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_256::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_256::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_256::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_256::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_256::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_256::mem_fn)>::class_type, class_256>);
struct class_257 { volatile bool * mem_fn(const volatile bool * const volatile &&, int, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_257::mem_fn)>::result_type, volatile bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_257::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_257::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_257::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_257::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_257::mem_fn)>::arg0_type, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_257::mem_fn)>::arg_type<0>, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_257::mem_fn)>::arg1_type, int>);
static_assert(std::is_same_v<callable_traits<decltype(&class_257::mem_fn)>::arg_type<1>, int>);
static_assert(callable_traits<decltype(&class_257::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_257::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_257::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_257::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_257::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_257::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_257::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_257::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_257::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_257::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_257::mem_fn)>::class_type, class_257>);
struct class_258 { const volatile bool * mem_fn(int *, const int *) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_258::mem_fn)>::result_type, const volatile bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_258::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_258::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_258::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_258::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_258::mem_fn)>::arg0_type, int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_258::mem_fn)>::arg_type<0>, int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_258::mem_fn)>::arg1_type, const int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_258::mem_fn)>::arg_type<1>, const int *>);
static_assert(callable_traits<decltype(&class_258::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_258::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_258::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_258::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_258::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_258::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_258::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_258::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_258::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_258::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_258::mem_fn)>::class_type, class_258>);
struct class_259 { bool & mem_fn(volatile int *, const volatile int *, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_259::mem_fn)>::result_type, bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_259::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_259::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_259::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_259::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_259::mem_fn)>::arg0_type, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_259::mem_fn)>::arg_type<0>, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_259::mem_fn)>::arg1_type, const volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_259::mem_fn)>::arg_type<1>, const volatile int *>);
static_assert(callable_traits<decltype(&class_259::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_259::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_259::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_259::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_259::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_259::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_259::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_259::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_259::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_259::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_259::mem_fn)>::class_type, class_259>);
struct class_260 { const bool & mem_fn(int &, const int &) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_260::mem_fn)>::result_type, const bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_260::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_260::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_260::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_260::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_260::mem_fn)>::arg0_type, int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_260::mem_fn)>::arg_type<0>, int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_260::mem_fn)>::arg1_type, const int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_260::mem_fn)>::arg_type<1>, const int &>);
static_assert(callable_traits<decltype(&class_260::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_260::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_260::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_260::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_260::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_260::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_260::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_260::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_260::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_260::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_260::mem_fn)>::class_type, class_260>);
struct class_261 { volatile bool & mem_fn(volatile int &, const volatile int &, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_261::mem_fn)>::result_type, volatile bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_261::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_261::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_261::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_261::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_261::mem_fn)>::arg0_type, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_261::mem_fn)>::arg_type<0>, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_261::mem_fn)>::arg1_type, const volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_261::mem_fn)>::arg_type<1>, const volatile int &>);
static_assert(callable_traits<decltype(&class_261::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_261::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_261::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_261::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_261::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_261::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_261::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_261::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_261::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_261::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_261::mem_fn)>::class_type, class_261>);
struct class_262 { const volatile bool & mem_fn(int * &, const int * &) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_262::mem_fn)>::result_type, const volatile bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_262::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_262::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_262::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_262::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_262::mem_fn)>::arg0_type, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_262::mem_fn)>::arg_type<0>, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_262::mem_fn)>::arg1_type, const int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_262::mem_fn)>::arg_type<1>, const int * &>);
static_assert(callable_traits<decltype(&class_262::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_262::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_262::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_262::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_262::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_262::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_262::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_262::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_262::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_262::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_262::mem_fn)>::class_type, class_262>);
struct class_263 { bool * & mem_fn(volatile int * &, const volatile int * &, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_263::mem_fn)>::result_type, bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_263::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_263::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_263::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_263::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_263::mem_fn)>::arg0_type, volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_263::mem_fn)>::arg_type<0>, volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_263::mem_fn)>::arg1_type, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_263::mem_fn)>::arg_type<1>, const volatile int * &>);
static_assert(callable_traits<decltype(&class_263::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_263::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_263::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_263::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_263::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_263::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_263::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_263::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_263::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_263::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_263::mem_fn)>::class_type, class_263>);
struct class_264 { const bool * & mem_fn(int * const &, const int * const &); };
static_assert(std::is_same_v<callable_traits<decltype(&class_264::mem_fn)>::result_type, const bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_264::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_264::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_264::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_264::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_264::mem_fn)>::arg0_type, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_264::mem_fn)>::arg_type<0>, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_264::mem_fn)>::arg1_type, const int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_264::mem_fn)>::arg_type<1>, const int * const &>);
static_assert(callable_traits<decltype(&class_264::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_264::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_264::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_264::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_264::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_264::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_264::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_264::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_264::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_264::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_264::mem_fn)>::class_type, class_264>);
struct class_265 { volatile bool * & mem_fn(volatile int * const &, const volatile int * const &, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_265::mem_fn)>::result_type, volatile bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_265::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_265::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_265::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_265::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_265::mem_fn)>::arg0_type, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_265::mem_fn)>::arg_type<0>, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_265::mem_fn)>::arg1_type, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_265::mem_fn)>::arg_type<1>, const volatile int * const &>);
static_assert(callable_traits<decltype(&class_265::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_265::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_265::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_265::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_265::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_265::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_265::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_265::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_265::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_265::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_265::mem_fn)>::class_type, class_265>);
struct class_266 { const volatile bool * & mem_fn(int * volatile &, const int * volatile &) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_266::mem_fn)>::result_type, const volatile bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_266::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_266::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_266::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_266::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_266::mem_fn)>::arg0_type, int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_266::mem_fn)>::arg_type<0>, int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_266::mem_fn)>::arg1_type, const int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_266::mem_fn)>::arg_type<1>, const int * volatile &>);
static_assert(callable_traits<decltype(&class_266::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_266::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_266::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_266::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_266::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_266::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_266::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_266::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_266::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_266::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_266::mem_fn)>::class_type, class_266>);
struct class_267 { bool * const & mem_fn(volatile int * volatile &, const volatile int * volatile &, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_267::mem_fn)>::result_type, bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_267::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_267::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_267::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_267::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_267::mem_fn)>::arg0_type, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_267::mem_fn)>::arg_type<0>, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_267::mem_fn)>::arg1_type, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_267::mem_fn)>::arg_type<1>, const volatile int * volatile &>);
static_assert(callable_traits<decltype(&class_267::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_267::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_267::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_267::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_267::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_267::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_267::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_267::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_267::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_267::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_267::mem_fn)>::class_type, class_267>);
struct class_268 { const bool * const & mem_fn(int * const volatile &, const int * const volatile &) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_268::mem_fn)>::result_type, const bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_268::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_268::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_268::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_268::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_268::mem_fn)>::arg0_type, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_268::mem_fn)>::arg_type<0>, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_268::mem_fn)>::arg1_type, const int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_268::mem_fn)>::arg_type<1>, const int * const volatile &>);
static_assert(callable_traits<decltype(&class_268::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_268::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_268::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_268::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_268::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_268::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_268::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_268::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_268::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_268::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_268::mem_fn)>::class_type, class_268>);
struct class_269 { volatile bool * const & mem_fn(volatile int * const volatile &, const volatile int * const volatile &, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_269::mem_fn)>::result_type, volatile bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_269::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_269::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_269::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_269::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_269::mem_fn)>::arg0_type, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_269::mem_fn)>::arg_type<0>, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_269::mem_fn)>::arg1_type, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_269::mem_fn)>::arg_type<1>, const volatile int * const volatile &>);
static_assert(callable_traits<decltype(&class_269::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_269::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_269::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_269::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_269::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_269::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_269::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_269::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_269::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_269::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_269::mem_fn)>::class_type, class_269>);
struct class_270 { const volatile bool * const & mem_fn(int &&, const int &&) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_270::mem_fn)>::result_type, const volatile bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_270::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_270::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_270::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_270::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_270::mem_fn)>::arg0_type, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_270::mem_fn)>::arg_type<0>, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_270::mem_fn)>::arg1_type, const int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_270::mem_fn)>::arg_type<1>, const int &&>);
static_assert(callable_traits<decltype(&class_270::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_270::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_270::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_270::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_270::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_270::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_270::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_270::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_270::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_270::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_270::mem_fn)>::class_type, class_270>);
struct class_271 { bool * volatile & mem_fn(volatile int &&, const volatile int &&, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_271::mem_fn)>::result_type, bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_271::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_271::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_271::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_271::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_271::mem_fn)>::arg0_type, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_271::mem_fn)>::arg_type<0>, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_271::mem_fn)>::arg1_type, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_271::mem_fn)>::arg_type<1>, const volatile int &&>);
static_assert(callable_traits<decltype(&class_271::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_271::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_271::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_271::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_271::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_271::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_271::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_271::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_271::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_271::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_271::mem_fn)>::class_type, class_271>);
struct class_272 { const bool * volatile & mem_fn(int * &&, const int * &&) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_272::mem_fn)>::result_type, const bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_272::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_272::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_272::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_272::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_272::mem_fn)>::arg0_type, int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_272::mem_fn)>::arg_type<0>, int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_272::mem_fn)>::arg1_type, const int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_272::mem_fn)>::arg_type<1>, const int * &&>);
static_assert(callable_traits<decltype(&class_272::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_272::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_272::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_272::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_272::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_272::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_272::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_272::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_272::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_272::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_272::mem_fn)>::class_type, class_272>);
struct class_273 { volatile bool * volatile & mem_fn(volatile int * &&, const volatile int * &&, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_273::mem_fn)>::result_type, volatile bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_273::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_273::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_273::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_273::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_273::mem_fn)>::arg0_type, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_273::mem_fn)>::arg_type<0>, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_273::mem_fn)>::arg1_type, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_273::mem_fn)>::arg_type<1>, const volatile int * &&>);
static_assert(callable_traits<decltype(&class_273::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_273::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_273::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_273::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_273::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_273::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_273::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_273::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_273::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_273::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_273::mem_fn)>::class_type, class_273>);
struct class_274 { const volatile bool * volatile & mem_fn(int * const &&, const int * const &&) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_274::mem_fn)>::result_type, const volatile bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_274::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_274::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_274::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_274::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_274::mem_fn)>::arg0_type, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_274::mem_fn)>::arg_type<0>, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_274::mem_fn)>::arg1_type, const int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_274::mem_fn)>::arg_type<1>, const int * const &&>);
static_assert(callable_traits<decltype(&class_274::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_274::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_274::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_274::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_274::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_274::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_274::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_274::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_274::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_274::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_274::mem_fn)>::class_type, class_274>);
struct class_275 { bool * const volatile & mem_fn(volatile int * const &&, const volatile int * const &&, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_275::mem_fn)>::result_type, bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_275::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_275::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_275::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_275::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_275::mem_fn)>::arg0_type, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_275::mem_fn)>::arg_type<0>, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_275::mem_fn)>::arg1_type, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_275::mem_fn)>::arg_type<1>, const volatile int * const &&>);
static_assert(callable_traits<decltype(&class_275::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_275::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_275::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_275::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_275::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_275::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_275::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_275::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_275::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_275::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_275::mem_fn)>::class_type, class_275>);
struct class_276 { const bool * const volatile & mem_fn(int * volatile &&, const int * volatile &&) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_276::mem_fn)>::result_type, const bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_276::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_276::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_276::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_276::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_276::mem_fn)>::arg0_type, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_276::mem_fn)>::arg_type<0>, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_276::mem_fn)>::arg1_type, const int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_276::mem_fn)>::arg_type<1>, const int * volatile &&>);
static_assert(callable_traits<decltype(&class_276::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_276::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_276::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_276::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_276::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_276::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_276::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_276::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_276::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_276::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_276::mem_fn)>::class_type, class_276>);
struct class_277 { volatile bool * const volatile & mem_fn(volatile int * volatile &&, const volatile int * volatile &&, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_277::mem_fn)>::result_type, volatile bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_277::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_277::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_277::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_277::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_277::mem_fn)>::arg0_type, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_277::mem_fn)>::arg_type<0>, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_277::mem_fn)>::arg1_type, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_277::mem_fn)>::arg_type<1>, const volatile int * volatile &&>);
static_assert(callable_traits<decltype(&class_277::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_277::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_277::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_277::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_277::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_277::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_277::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_277::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_277::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_277::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_277::mem_fn)>::class_type, class_277>);
struct class_278 { const volatile bool * const volatile & mem_fn(int * const volatile &&, const int * const volatile &&) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_278::mem_fn)>::result_type, const volatile bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_278::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_278::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_278::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_278::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_278::mem_fn)>::arg0_type, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_278::mem_fn)>::arg_type<0>, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_278::mem_fn)>::arg1_type, const int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_278::mem_fn)>::arg_type<1>, const int * const volatile &&>);
static_assert(callable_traits<decltype(&class_278::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_278::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_278::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_278::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_278::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_278::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_278::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_278::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_278::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_278::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_278::mem_fn)>::class_type, class_278>);
struct class_279 { bool && mem_fn(volatile int * const volatile &&, const volatile int * const volatile &&, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_279::mem_fn)>::result_type, bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_279::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_279::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_279::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_279::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_279::mem_fn)>::arg0_type, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_279::mem_fn)>::arg_type<0>, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_279::mem_fn)>::arg1_type, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_279::mem_fn)>::arg_type<1>, const volatile int * const volatile &&>);
static_assert(callable_traits<decltype(&class_279::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_279::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_279::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_279::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_279::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_279::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_279::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_279::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_279::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_279::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_279::mem_fn)>::class_type, class_279>);
struct class_280 { const bool && mem_fn(float, float *) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_280::mem_fn)>::result_type, const bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_280::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_280::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_280::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_280::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_280::mem_fn)>::arg0_type, float>);
static_assert(std::is_same_v<callable_traits<decltype(&class_280::mem_fn)>::arg_type<0>, float>);
static_assert(std::is_same_v<callable_traits<decltype(&class_280::mem_fn)>::arg1_type, float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_280::mem_fn)>::arg_type<1>, float *>);
static_assert(callable_traits<decltype(&class_280::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_280::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_280::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_280::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_280::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_280::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_280::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_280::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_280::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_280::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_280::mem_fn)>::class_type, class_280>);
struct class_281 { volatile bool && mem_fn(const float *, volatile float *, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_281::mem_fn)>::result_type, volatile bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_281::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_281::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_281::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_281::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_281::mem_fn)>::arg0_type, const float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_281::mem_fn)>::arg_type<0>, const float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_281::mem_fn)>::arg1_type, volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_281::mem_fn)>::arg_type<1>, volatile float *>);
static_assert(callable_traits<decltype(&class_281::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_281::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_281::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_281::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_281::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_281::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_281::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_281::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_281::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_281::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_281::mem_fn)>::class_type, class_281>);
struct class_282 { const volatile bool && mem_fn(const volatile float *, float &) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_282::mem_fn)>::result_type, const volatile bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_282::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_282::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_282::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_282::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_282::mem_fn)>::arg0_type, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_282::mem_fn)>::arg_type<0>, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_282::mem_fn)>::arg1_type, float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_282::mem_fn)>::arg_type<1>, float &>);
static_assert(callable_traits<decltype(&class_282::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_282::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_282::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_282::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_282::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_282::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_282::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_282::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_282::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_282::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_282::mem_fn)>::class_type, class_282>);
struct class_283 { bool * && mem_fn(const float &, volatile float &, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_283::mem_fn)>::result_type, bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_283::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_283::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_283::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_283::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_283::mem_fn)>::arg0_type, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_283::mem_fn)>::arg_type<0>, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_283::mem_fn)>::arg1_type, volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_283::mem_fn)>::arg_type<1>, volatile float &>);
static_assert(callable_traits<decltype(&class_283::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_283::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_283::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_283::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_283::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_283::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_283::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_283::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_283::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_283::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_283::mem_fn)>::class_type, class_283>);
struct class_284 { const bool * && mem_fn(const volatile float &, float * &) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_284::mem_fn)>::result_type, const bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_284::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_284::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_284::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_284::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_284::mem_fn)>::arg0_type, const volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_284::mem_fn)>::arg_type<0>, const volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_284::mem_fn)>::arg1_type, float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_284::mem_fn)>::arg_type<1>, float * &>);
static_assert(callable_traits<decltype(&class_284::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_284::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_284::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_284::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_284::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_284::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_284::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_284::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_284::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_284::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_284::mem_fn)>::class_type, class_284>);
struct class_285 { volatile bool * && mem_fn(const float * &, volatile float * &, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_285::mem_fn)>::result_type, volatile bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_285::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_285::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_285::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_285::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_285::mem_fn)>::arg0_type, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_285::mem_fn)>::arg_type<0>, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_285::mem_fn)>::arg1_type, volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_285::mem_fn)>::arg_type<1>, volatile float * &>);
static_assert(callable_traits<decltype(&class_285::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_285::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_285::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_285::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_285::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_285::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_285::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_285::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_285::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_285::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_285::mem_fn)>::class_type, class_285>);
struct class_286 { const volatile bool * && mem_fn(const volatile float * &, float * const &) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_286::mem_fn)>::result_type, const volatile bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_286::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_286::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_286::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_286::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_286::mem_fn)>::arg0_type, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_286::mem_fn)>::arg_type<0>, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_286::mem_fn)>::arg1_type, float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_286::mem_fn)>::arg_type<1>, float * const &>);
static_assert(callable_traits<decltype(&class_286::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_286::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_286::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_286::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_286::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_286::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_286::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_286::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_286::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_286::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_286::mem_fn)>::class_type, class_286>);
struct class_287 { bool * const && mem_fn(const float * const &, volatile float * const &, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_287::mem_fn)>::result_type, bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_287::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_287::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_287::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_287::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_287::mem_fn)>::arg0_type, const float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_287::mem_fn)>::arg_type<0>, const float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_287::mem_fn)>::arg1_type, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_287::mem_fn)>::arg_type<1>, volatile float * const &>);
static_assert(callable_traits<decltype(&class_287::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_287::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_287::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_287::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_287::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_287::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_287::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_287::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_287::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_287::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_287::mem_fn)>::class_type, class_287>);
struct class_288 { const bool * const && mem_fn(const volatile float * const &, float * volatile &); };
static_assert(std::is_same_v<callable_traits<decltype(&class_288::mem_fn)>::result_type, const bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_288::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_288::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_288::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_288::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_288::mem_fn)>::arg0_type, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_288::mem_fn)>::arg_type<0>, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_288::mem_fn)>::arg1_type, float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_288::mem_fn)>::arg_type<1>, float * volatile &>);
static_assert(callable_traits<decltype(&class_288::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_288::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_288::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_288::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_288::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_288::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_288::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_288::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_288::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_288::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_288::mem_fn)>::class_type, class_288>);
struct class_289 { volatile bool * const && mem_fn(const float * volatile &, volatile float * volatile &, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_289::mem_fn)>::result_type, volatile bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_289::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_289::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_289::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_289::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_289::mem_fn)>::arg0_type, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_289::mem_fn)>::arg_type<0>, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_289::mem_fn)>::arg1_type, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_289::mem_fn)>::arg_type<1>, volatile float * volatile &>);
static_assert(callable_traits<decltype(&class_289::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_289::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_289::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_289::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_289::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_289::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_289::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_289::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_289::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_289::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_289::mem_fn)>::class_type, class_289>);
struct class_290 { const volatile bool * const && mem_fn(const volatile float * volatile &, float * const volatile &) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_290::mem_fn)>::result_type, const volatile bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_290::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_290::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_290::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_290::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_290::mem_fn)>::arg0_type, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_290::mem_fn)>::arg_type<0>, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_290::mem_fn)>::arg1_type, float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_290::mem_fn)>::arg_type<1>, float * const volatile &>);
static_assert(callable_traits<decltype(&class_290::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_290::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_290::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_290::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_290::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_290::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_290::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_290::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_290::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_290::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_290::mem_fn)>::class_type, class_290>);
struct class_291 { bool * volatile && mem_fn(const float * const volatile &, volatile float * const volatile &, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_291::mem_fn)>::result_type, bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_291::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_291::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_291::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_291::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_291::mem_fn)>::arg0_type, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_291::mem_fn)>::arg_type<0>, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_291::mem_fn)>::arg1_type, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_291::mem_fn)>::arg_type<1>, volatile float * const volatile &>);
static_assert(callable_traits<decltype(&class_291::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_291::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_291::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_291::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_291::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_291::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_291::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_291::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_291::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_291::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_291::mem_fn)>::class_type, class_291>);
struct class_292 { const bool * volatile && mem_fn(const volatile float * const volatile &, float &&) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_292::mem_fn)>::result_type, const bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_292::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_292::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_292::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_292::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_292::mem_fn)>::arg0_type, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_292::mem_fn)>::arg_type<0>, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_292::mem_fn)>::arg1_type, float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_292::mem_fn)>::arg_type<1>, float &&>);
static_assert(callable_traits<decltype(&class_292::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_292::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_292::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_292::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_292::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_292::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_292::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_292::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_292::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_292::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_292::mem_fn)>::class_type, class_292>);
struct class_293 { volatile bool * volatile && mem_fn(const float &&, volatile float &&, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_293::mem_fn)>::result_type, volatile bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_293::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_293::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_293::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_293::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_293::mem_fn)>::arg0_type, const float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_293::mem_fn)>::arg_type<0>, const float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_293::mem_fn)>::arg1_type, volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_293::mem_fn)>::arg_type<1>, volatile float &&>);
static_assert(callable_traits<decltype(&class_293::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_293::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_293::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_293::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_293::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_293::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_293::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_293::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_293::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_293::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_293::mem_fn)>::class_type, class_293>);
struct class_294 { const volatile bool * volatile && mem_fn(const volatile float &&, float * &&) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_294::mem_fn)>::result_type, const volatile bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_294::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_294::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_294::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_294::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_294::mem_fn)>::arg0_type, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_294::mem_fn)>::arg_type<0>, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_294::mem_fn)>::arg1_type, float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_294::mem_fn)>::arg_type<1>, float * &&>);
static_assert(callable_traits<decltype(&class_294::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_294::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_294::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_294::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_294::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_294::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_294::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_294::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_294::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_294::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_294::mem_fn)>::class_type, class_294>);
struct class_295 { bool * const volatile && mem_fn(const float * &&, volatile float * &&, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_295::mem_fn)>::result_type, bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_295::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_295::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_295::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_295::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_295::mem_fn)>::arg0_type, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_295::mem_fn)>::arg_type<0>, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_295::mem_fn)>::arg1_type, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_295::mem_fn)>::arg_type<1>, volatile float * &&>);
static_assert(callable_traits<decltype(&class_295::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_295::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_295::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_295::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_295::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_295::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_295::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_295::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_295::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_295::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_295::mem_fn)>::class_type, class_295>);
struct class_296 { const bool * const volatile && mem_fn(const volatile float * &&, float * const &&) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_296::mem_fn)>::result_type, const bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_296::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_296::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_296::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_296::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_296::mem_fn)>::arg0_type, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_296::mem_fn)>::arg_type<0>, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_296::mem_fn)>::arg1_type, float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_296::mem_fn)>::arg_type<1>, float * const &&>);
static_assert(callable_traits<decltype(&class_296::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_296::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_296::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_296::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_296::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_296::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_296::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_296::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_296::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_296::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_296::mem_fn)>::class_type, class_296>);
struct class_297 { volatile bool * const volatile && mem_fn(const float * const &&, volatile float * const &&, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_297::mem_fn)>::result_type, volatile bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_297::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_297::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_297::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_297::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_297::mem_fn)>::arg0_type, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_297::mem_fn)>::arg_type<0>, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_297::mem_fn)>::arg1_type, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_297::mem_fn)>::arg_type<1>, volatile float * const &&>);
static_assert(callable_traits<decltype(&class_297::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_297::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_297::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_297::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_297::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_297::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_297::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_297::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_297::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_297::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_297::mem_fn)>::class_type, class_297>);
struct class_298 { const volatile bool * const volatile && mem_fn(const volatile float * const &&, float * volatile &&) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_298::mem_fn)>::result_type, const volatile bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_298::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_298::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_298::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_298::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_298::mem_fn)>::arg0_type, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_298::mem_fn)>::arg_type<0>, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_298::mem_fn)>::arg1_type, float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_298::mem_fn)>::arg_type<1>, float * volatile &&>);
static_assert(callable_traits<decltype(&class_298::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_298::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_298::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_298::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_298::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_298::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_298::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_298::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_298::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_298::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_298::mem_fn)>::class_type, class_298>);
struct class_299 { int mem_fn(const float * volatile &&, volatile float * volatile &&, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_299::mem_fn)>::result_type, int>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_299::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_299::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_299::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_299::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_299::mem_fn)>::arg0_type, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_299::mem_fn)>::arg_type<0>, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_299::mem_fn)>::arg1_type, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_299::mem_fn)>::arg_type<1>, volatile float * volatile &&>);
static_assert(callable_traits<decltype(&class_299::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_299::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_299::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_299::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_299::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_299::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_299::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_299::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_299::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_299::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_299::mem_fn)>::class_type, class_299>);
struct class_300 { int * mem_fn(const volatile float * volatile &&, float * const volatile &&) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_300::mem_fn)>::result_type, int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_300::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_300::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_300::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_300::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_300::mem_fn)>::arg0_type, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_300::mem_fn)>::arg_type<0>, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_300::mem_fn)>::arg1_type, float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_300::mem_fn)>::arg_type<1>, float * const volatile &&>);
static_assert(callable_traits<decltype(&class_300::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_300::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_300::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_300::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_300::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_300::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_300::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_300::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_300::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_300::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_300::mem_fn)>::class_type, class_300>);
struct class_301 { const int * mem_fn(const float * const volatile &&, volatile float * const volatile &&, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_301::mem_fn)>::result_type, const int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_301::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_301::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_301::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_301::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_301::mem_fn)>::arg0_type, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_301::mem_fn)>::arg_type<0>, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_301::mem_fn)>::arg1_type, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_301::mem_fn)>::arg_type<1>, volatile float * const volatile &&>);
static_assert(callable_traits<decltype(&class_301::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_301::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_301::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_301::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_301::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_301::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_301::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_301::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_301::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_301::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_301::mem_fn)>::class_type, class_301>);
struct class_302 { volatile int * mem_fn(const volatile float * const volatile &&, std::string) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_302::mem_fn)>::result_type, volatile int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_302::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_302::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_302::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_302::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_302::mem_fn)>::arg0_type, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_302::mem_fn)>::arg_type<0>, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_302::mem_fn)>::arg1_type, std::string>);
static_assert(std::is_same_v<callable_traits<decltype(&class_302::mem_fn)>::arg_type<1>, std::string>);
static_assert(callable_traits<decltype(&class_302::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_302::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_302::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_302::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_302::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_302::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_302::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_302::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_302::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_302::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_302::mem_fn)>::class_type, class_302>);
struct class_303 { const volatile int * mem_fn(std::string *, const std::string *, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_303::mem_fn)>::result_type, const volatile int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_303::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_303::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_303::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_303::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_303::mem_fn)>::arg0_type, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_303::mem_fn)>::arg_type<0>, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_303::mem_fn)>::arg1_type, const std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_303::mem_fn)>::arg_type<1>, const std::string *>);
static_assert(callable_traits<decltype(&class_303::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_303::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_303::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_303::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_303::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_303::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_303::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_303::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_303::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_303::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_303::mem_fn)>::class_type, class_303>);
struct class_304 { int & mem_fn(volatile std::string *, const volatile std::string *) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_304::mem_fn)>::result_type, int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_304::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_304::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_304::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_304::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_304::mem_fn)>::arg0_type, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_304::mem_fn)>::arg_type<0>, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_304::mem_fn)>::arg1_type, const volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_304::mem_fn)>::arg_type<1>, const volatile std::string *>);
static_assert(callable_traits<decltype(&class_304::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_304::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_304::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_304::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_304::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_304::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_304::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_304::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_304::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_304::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_304::mem_fn)>::class_type, class_304>);
struct class_305 { const int & mem_fn(std::string &, const std::string &, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_305::mem_fn)>::result_type, const int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_305::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_305::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_305::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_305::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_305::mem_fn)>::arg0_type, std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_305::mem_fn)>::arg_type<0>, std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_305::mem_fn)>::arg1_type, const std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_305::mem_fn)>::arg_type<1>, const std::string &>);
static_assert(callable_traits<decltype(&class_305::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_305::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_305::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_305::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_305::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_305::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_305::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_305::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_305::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_305::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_305::mem_fn)>::class_type, class_305>);
struct class_306 { volatile int & mem_fn(volatile std::string &, const volatile std::string &) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_306::mem_fn)>::result_type, volatile int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_306::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_306::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_306::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_306::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_306::mem_fn)>::arg0_type, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_306::mem_fn)>::arg_type<0>, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_306::mem_fn)>::arg1_type, const volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_306::mem_fn)>::arg_type<1>, const volatile std::string &>);
static_assert(callable_traits<decltype(&class_306::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_306::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_306::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_306::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_306::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_306::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_306::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_306::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_306::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_306::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_306::mem_fn)>::class_type, class_306>);
struct class_307 { const volatile int & mem_fn(std::string * &, const std::string * &, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_307::mem_fn)>::result_type, const volatile int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_307::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_307::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_307::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_307::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_307::mem_fn)>::arg0_type, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_307::mem_fn)>::arg_type<0>, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_307::mem_fn)>::arg1_type, const std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_307::mem_fn)>::arg_type<1>, const std::string * &>);
static_assert(callable_traits<decltype(&class_307::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_307::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_307::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_307::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_307::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_307::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_307::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_307::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_307::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_307::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_307::mem_fn)>::class_type, class_307>);
struct class_308 { int * & mem_fn(volatile std::string * &, const volatile std::string * &) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_308::mem_fn)>::result_type, int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_308::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_308::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_308::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_308::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_308::mem_fn)>::arg0_type, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_308::mem_fn)>::arg_type<0>, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_308::mem_fn)>::arg1_type, const volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_308::mem_fn)>::arg_type<1>, const volatile std::string * &>);
static_assert(callable_traits<decltype(&class_308::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_308::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_308::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_308::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_308::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_308::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_308::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_308::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_308::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_308::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_308::mem_fn)>::class_type, class_308>);
struct class_309 { const int * & mem_fn(std::string * const &, const std::string * const &, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_309::mem_fn)>::result_type, const int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_309::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_309::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_309::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_309::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_309::mem_fn)>::arg0_type, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_309::mem_fn)>::arg_type<0>, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_309::mem_fn)>::arg1_type, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_309::mem_fn)>::arg_type<1>, const std::string * const &>);
static_assert(callable_traits<decltype(&class_309::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_309::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_309::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_309::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_309::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_309::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_309::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_309::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_309::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_309::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_309::mem_fn)>::class_type, class_309>);
struct class_310 { volatile int * & mem_fn(volatile std::string * const &, const volatile std::string * const &) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_310::mem_fn)>::result_type, volatile int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_310::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_310::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_310::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_310::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_310::mem_fn)>::arg0_type, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_310::mem_fn)>::arg_type<0>, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_310::mem_fn)>::arg1_type, const volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_310::mem_fn)>::arg_type<1>, const volatile std::string * const &>);
static_assert(callable_traits<decltype(&class_310::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_310::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_310::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_310::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_310::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_310::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_310::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_310::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_310::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_310::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_310::mem_fn)>::class_type, class_310>);
struct class_311 { const volatile int * & mem_fn(std::string * volatile &, const std::string * volatile &, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_311::mem_fn)>::result_type, const volatile int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_311::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_311::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_311::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_311::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_311::mem_fn)>::arg0_type, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_311::mem_fn)>::arg_type<0>, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_311::mem_fn)>::arg1_type, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_311::mem_fn)>::arg_type<1>, const std::string * volatile &>);
static_assert(callable_traits<decltype(&class_311::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_311::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_311::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_311::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_311::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_311::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_311::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_311::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_311::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_311::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_311::mem_fn)>::class_type, class_311>);
struct class_312 { int * const & mem_fn(volatile std::string * volatile &, const volatile std::string * volatile &); };
static_assert(std::is_same_v<callable_traits<decltype(&class_312::mem_fn)>::result_type, int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_312::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_312::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_312::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_312::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_312::mem_fn)>::arg0_type, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_312::mem_fn)>::arg_type<0>, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_312::mem_fn)>::arg1_type, const volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_312::mem_fn)>::arg_type<1>, const volatile std::string * volatile &>);
static_assert(callable_traits<decltype(&class_312::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_312::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_312::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_312::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_312::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_312::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_312::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_312::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_312::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_312::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_312::mem_fn)>::class_type, class_312>);
struct class_313 { const int * const & mem_fn(std::string * const volatile &, const std::string * const volatile &, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_313::mem_fn)>::result_type, const int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_313::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_313::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_313::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_313::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_313::mem_fn)>::arg0_type, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_313::mem_fn)>::arg_type<0>, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_313::mem_fn)>::arg1_type, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_313::mem_fn)>::arg_type<1>, const std::string * const volatile &>);
static_assert(callable_traits<decltype(&class_313::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_313::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_313::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_313::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_313::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_313::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_313::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_313::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_313::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_313::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_313::mem_fn)>::class_type, class_313>);
struct class_314 { volatile int * const & mem_fn(volatile std::string * const volatile &, const volatile std::string * const volatile &) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_314::mem_fn)>::result_type, volatile int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_314::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_314::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_314::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_314::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_314::mem_fn)>::arg0_type, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_314::mem_fn)>::arg_type<0>, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_314::mem_fn)>::arg1_type, const volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_314::mem_fn)>::arg_type<1>, const volatile std::string * const volatile &>);
static_assert(callable_traits<decltype(&class_314::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_314::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_314::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_314::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_314::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_314::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_314::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_314::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_314::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_314::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_314::mem_fn)>::class_type, class_314>);
struct class_315 { const volatile int * const & mem_fn(std::string &&, const std::string &&, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_315::mem_fn)>::result_type, const volatile int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_315::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_315::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_315::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_315::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_315::mem_fn)>::arg0_type, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_315::mem_fn)>::arg_type<0>, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_315::mem_fn)>::arg1_type, const std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_315::mem_fn)>::arg_type<1>, const std::string &&>);
static_assert(callable_traits<decltype(&class_315::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_315::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_315::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_315::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_315::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_315::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_315::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_315::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_315::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_315::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_315::mem_fn)>::class_type, class_315>);
struct class_316 { int * volatile & mem_fn(volatile std::string &&, const volatile std::string &&) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_316::mem_fn)>::result_type, int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_316::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_316::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_316::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_316::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_316::mem_fn)>::arg0_type, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_316::mem_fn)>::arg_type<0>, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_316::mem_fn)>::arg1_type, const volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_316::mem_fn)>::arg_type<1>, const volatile std::string &&>);
static_assert(callable_traits<decltype(&class_316::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_316::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_316::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_316::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_316::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_316::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_316::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_316::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_316::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_316::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_316::mem_fn)>::class_type, class_316>);
struct class_317 { const int * volatile & mem_fn(std::string * &&, const std::string * &&, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_317::mem_fn)>::result_type, const int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_317::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_317::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_317::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_317::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_317::mem_fn)>::arg0_type, std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_317::mem_fn)>::arg_type<0>, std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_317::mem_fn)>::arg1_type, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_317::mem_fn)>::arg_type<1>, const std::string * &&>);
static_assert(callable_traits<decltype(&class_317::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_317::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_317::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_317::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_317::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_317::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_317::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_317::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_317::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_317::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_317::mem_fn)>::class_type, class_317>);
struct class_318 { volatile int * volatile & mem_fn(volatile std::string * &&, const volatile std::string * &&) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_318::mem_fn)>::result_type, volatile int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_318::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_318::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_318::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_318::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_318::mem_fn)>::arg0_type, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_318::mem_fn)>::arg_type<0>, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_318::mem_fn)>::arg1_type, const volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_318::mem_fn)>::arg_type<1>, const volatile std::string * &&>);
static_assert(callable_traits<decltype(&class_318::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_318::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_318::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_318::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_318::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_318::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_318::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_318::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_318::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_318::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_318::mem_fn)>::class_type, class_318>);
struct class_319 { const volatile int * volatile & mem_fn(std::string * const &&, const std::string * const &&, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_319::mem_fn)>::result_type, const volatile int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_319::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_319::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_319::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_319::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_319::mem_fn)>::arg0_type, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_319::mem_fn)>::arg_type<0>, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_319::mem_fn)>::arg1_type, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_319::mem_fn)>::arg_type<1>, const std::string * const &&>);
static_assert(callable_traits<decltype(&class_319::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_319::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_319::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_319::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_319::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_319::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_319::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_319::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_319::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_319::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_319::mem_fn)>::class_type, class_319>);
struct class_320 { int * const volatile & mem_fn(volatile std::string * const &&, const volatile std::string * const &&) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_320::mem_fn)>::result_type, int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_320::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_320::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_320::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_320::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_320::mem_fn)>::arg0_type, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_320::mem_fn)>::arg_type<0>, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_320::mem_fn)>::arg1_type, const volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_320::mem_fn)>::arg_type<1>, const volatile std::string * const &&>);
static_assert(callable_traits<decltype(&class_320::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_320::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_320::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_320::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_320::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_320::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_320::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_320::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_320::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_320::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_320::mem_fn)>::class_type, class_320>);
struct class_321 { const int * const volatile & mem_fn(std::string * volatile &&, const std::string * volatile &&, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_321::mem_fn)>::result_type, const int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_321::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_321::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_321::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_321::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_321::mem_fn)>::arg0_type, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_321::mem_fn)>::arg_type<0>, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_321::mem_fn)>::arg1_type, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_321::mem_fn)>::arg_type<1>, const std::string * volatile &&>);
static_assert(callable_traits<decltype(&class_321::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_321::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_321::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_321::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_321::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_321::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_321::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_321::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_321::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_321::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_321::mem_fn)>::class_type, class_321>);
struct class_322 { volatile int * const volatile & mem_fn(volatile std::string * volatile &&, const volatile std::string * volatile &&) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_322::mem_fn)>::result_type, volatile int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_322::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_322::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_322::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_322::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_322::mem_fn)>::arg0_type, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_322::mem_fn)>::arg_type<0>, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_322::mem_fn)>::arg1_type, const volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_322::mem_fn)>::arg_type<1>, const volatile std::string * volatile &&>);
static_assert(callable_traits<decltype(&class_322::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_322::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_322::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_322::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_322::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_322::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_322::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_322::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_322::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_322::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_322::mem_fn)>::class_type, class_322>);
struct class_323 { const volatile int * const volatile & mem_fn(std::string * const volatile &&, const std::string * const volatile &&, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_323::mem_fn)>::result_type, const volatile int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_323::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_323::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_323::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_323::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_323::mem_fn)>::arg0_type, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_323::mem_fn)>::arg_type<0>, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_323::mem_fn)>::arg1_type, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_323::mem_fn)>::arg_type<1>, const std::string * const volatile &&>);
static_assert(callable_traits<decltype(&class_323::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_323::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_323::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_323::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_323::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_323::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_323::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_323::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_323::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_323::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_323::mem_fn)>::class_type, class_323>);
struct class_324 { int && mem_fn(volatile std::string * const volatile &&, const volatile std::string * const volatile &&) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_324::mem_fn)>::result_type, int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_324::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_324::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_324::mem_fn)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_324::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_324::mem_fn)>::arg0_type, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_324::mem_fn)>::arg_type<0>, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_324::mem_fn)>::arg1_type, const volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_324::mem_fn)>::arg_type<1>, const volatile std::string * const volatile &&>);
static_assert(callable_traits<decltype(&class_324::mem_fn)>::arity == 2);
static_assert(callable_traits<decltype(&class_324::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_324::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_324::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_324::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_324::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_324::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_324::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_324::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_324::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_324::mem_fn)>::class_type, class_324>);
struct class_325 { const int && mem_fn(void *, const void *, volatile void *, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_325::mem_fn)>::result_type, const int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_325::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_325::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_325::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_325::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_325::mem_fn)>::arg0_type, void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_325::mem_fn)>::arg_type<0>, void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_325::mem_fn)>::arg1_type, const void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_325::mem_fn)>::arg_type<1>, const void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_325::mem_fn)>::arg2_type, volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_325::mem_fn)>::arg_type<2>, volatile void *>);
static_assert(callable_traits<decltype(&class_325::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_325::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_325::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_325::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_325::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_325::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_325::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_325::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_325::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_325::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_325::mem_fn)>::class_type, class_325>);
struct class_326 { volatile int && mem_fn(const volatile void *, void * &, const void * &) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_326::mem_fn)>::result_type, volatile int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_326::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_326::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_326::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_326::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_326::mem_fn)>::arg0_type, const volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_326::mem_fn)>::arg_type<0>, const volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_326::mem_fn)>::arg1_type, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_326::mem_fn)>::arg_type<1>, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_326::mem_fn)>::arg2_type, const void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_326::mem_fn)>::arg_type<2>, const void * &>);
static_assert(callable_traits<decltype(&class_326::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_326::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_326::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_326::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_326::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_326::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_326::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_326::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_326::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_326::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_326::mem_fn)>::class_type, class_326>);
struct class_327 { const volatile int && mem_fn(volatile void * &, const volatile void * &, void * const &, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_327::mem_fn)>::result_type, const volatile int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_327::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_327::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_327::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_327::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_327::mem_fn)>::arg0_type, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_327::mem_fn)>::arg_type<0>, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_327::mem_fn)>::arg1_type, const volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_327::mem_fn)>::arg_type<1>, const volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_327::mem_fn)>::arg2_type, void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_327::mem_fn)>::arg_type<2>, void * const &>);
static_assert(callable_traits<decltype(&class_327::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_327::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_327::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_327::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_327::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_327::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_327::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_327::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_327::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_327::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_327::mem_fn)>::class_type, class_327>);
struct class_328 { int * && mem_fn(const void * const &, volatile void * const &, const volatile void * const &) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_328::mem_fn)>::result_type, int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_328::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_328::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_328::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_328::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_328::mem_fn)>::arg0_type, const void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_328::mem_fn)>::arg_type<0>, const void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_328::mem_fn)>::arg1_type, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_328::mem_fn)>::arg_type<1>, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_328::mem_fn)>::arg2_type, const volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_328::mem_fn)>::arg_type<2>, const volatile void * const &>);
static_assert(callable_traits<decltype(&class_328::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_328::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_328::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_328::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_328::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_328::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_328::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_328::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_328::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_328::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_328::mem_fn)>::class_type, class_328>);
struct class_329 { const int * && mem_fn(void * volatile &, const void * volatile &, volatile void * volatile &, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_329::mem_fn)>::result_type, const int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_329::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_329::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_329::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_329::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_329::mem_fn)>::arg0_type, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_329::mem_fn)>::arg_type<0>, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_329::mem_fn)>::arg1_type, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_329::mem_fn)>::arg_type<1>, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_329::mem_fn)>::arg2_type, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_329::mem_fn)>::arg_type<2>, volatile void * volatile &>);
static_assert(callable_traits<decltype(&class_329::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_329::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_329::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_329::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_329::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_329::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_329::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_329::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_329::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_329::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_329::mem_fn)>::class_type, class_329>);
struct class_330 { volatile int * && mem_fn(const volatile void * volatile &, void * const volatile &, const void * const volatile &) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_330::mem_fn)>::result_type, volatile int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_330::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_330::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_330::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_330::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_330::mem_fn)>::arg0_type, const volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_330::mem_fn)>::arg_type<0>, const volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_330::mem_fn)>::arg1_type, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_330::mem_fn)>::arg_type<1>, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_330::mem_fn)>::arg2_type, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_330::mem_fn)>::arg_type<2>, const void * const volatile &>);
static_assert(callable_traits<decltype(&class_330::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_330::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_330::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_330::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_330::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_330::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_330::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_330::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_330::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_330::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_330::mem_fn)>::class_type, class_330>);
struct class_331 { const volatile int * && mem_fn(volatile void * const volatile &, const volatile void * const volatile &, void * &&, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_331::mem_fn)>::result_type, const volatile int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_331::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_331::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_331::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_331::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_331::mem_fn)>::arg0_type, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_331::mem_fn)>::arg_type<0>, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_331::mem_fn)>::arg1_type, const volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_331::mem_fn)>::arg_type<1>, const volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_331::mem_fn)>::arg2_type, void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_331::mem_fn)>::arg_type<2>, void * &&>);
static_assert(callable_traits<decltype(&class_331::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_331::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_331::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_331::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_331::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_331::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_331::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_331::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_331::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_331::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_331::mem_fn)>::class_type, class_331>);
struct class_332 { int * const && mem_fn(const void * &&, volatile void * &&, const volatile void * &&) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_332::mem_fn)>::result_type, int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_332::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_332::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_332::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_332::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_332::mem_fn)>::arg0_type, const void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_332::mem_fn)>::arg_type<0>, const void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_332::mem_fn)>::arg1_type, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_332::mem_fn)>::arg_type<1>, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_332::mem_fn)>::arg2_type, const volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_332::mem_fn)>::arg_type<2>, const volatile void * &&>);
static_assert(callable_traits<decltype(&class_332::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_332::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_332::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_332::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_332::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_332::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_332::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_332::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_332::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_332::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_332::mem_fn)>::class_type, class_332>);
struct class_333 { const int * const && mem_fn(void * const &&, const void * const &&, volatile void * const &&, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_333::mem_fn)>::result_type, const int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_333::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_333::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_333::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_333::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_333::mem_fn)>::arg0_type, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_333::mem_fn)>::arg_type<0>, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_333::mem_fn)>::arg1_type, const void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_333::mem_fn)>::arg_type<1>, const void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_333::mem_fn)>::arg2_type, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_333::mem_fn)>::arg_type<2>, volatile void * const &&>);
static_assert(callable_traits<decltype(&class_333::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_333::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_333::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_333::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_333::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_333::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_333::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_333::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_333::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_333::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_333::mem_fn)>::class_type, class_333>);
struct class_334 { volatile int * const && mem_fn(const volatile void * const &&, void * volatile &&, const void * volatile &&) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_334::mem_fn)>::result_type, volatile int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_334::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_334::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_334::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_334::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_334::mem_fn)>::arg0_type, const volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_334::mem_fn)>::arg_type<0>, const volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_334::mem_fn)>::arg1_type, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_334::mem_fn)>::arg_type<1>, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_334::mem_fn)>::arg2_type, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_334::mem_fn)>::arg_type<2>, const void * volatile &&>);
static_assert(callable_traits<decltype(&class_334::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_334::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_334::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_334::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_334::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_334::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_334::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_334::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_334::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_334::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_334::mem_fn)>::class_type, class_334>);
struct class_335 { const volatile int * const && mem_fn(volatile void * volatile &&, const volatile void * volatile &&, void * const volatile &&, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_335::mem_fn)>::result_type, const volatile int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_335::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_335::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_335::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_335::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_335::mem_fn)>::arg0_type, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_335::mem_fn)>::arg_type<0>, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_335::mem_fn)>::arg1_type, const volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_335::mem_fn)>::arg_type<1>, const volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_335::mem_fn)>::arg2_type, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_335::mem_fn)>::arg_type<2>, void * const volatile &&>);
static_assert(callable_traits<decltype(&class_335::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_335::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_335::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_335::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_335::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_335::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_335::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_335::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_335::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_335::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_335::mem_fn)>::class_type, class_335>);
struct class_336 { int * volatile && mem_fn(const void * const volatile &&, volatile void * const volatile &&, const volatile void * const volatile &&); };
static_assert(std::is_same_v<callable_traits<decltype(&class_336::mem_fn)>::result_type, int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_336::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_336::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_336::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_336::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_336::mem_fn)>::arg0_type, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_336::mem_fn)>::arg_type<0>, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_336::mem_fn)>::arg1_type, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_336::mem_fn)>::arg_type<1>, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_336::mem_fn)>::arg2_type, const volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_336::mem_fn)>::arg_type<2>, const volatile void * const volatile &&>);
static_assert(callable_traits<decltype(&class_336::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_336::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_336::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_336::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_336::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_336::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_336::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_336::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_336::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_336::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_336::mem_fn)>::class_type, class_336>);
struct class_337 { const int * volatile && mem_fn(bool, bool *, const bool *, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_337::mem_fn)>::result_type, const int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_337::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_337::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_337::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_337::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_337::mem_fn)>::arg0_type, bool>);
static_assert(std::is_same_v<callable_traits<decltype(&class_337::mem_fn)>::arg_type<0>, bool>);
static_assert(std::is_same_v<callable_traits<decltype(&class_337::mem_fn)>::arg1_type, bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_337::mem_fn)>::arg_type<1>, bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_337::mem_fn)>::arg2_type, const bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_337::mem_fn)>::arg_type<2>, const bool *>);
static_assert(callable_traits<decltype(&class_337::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_337::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_337::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_337::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_337::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_337::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_337::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_337::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_337::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_337::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_337::mem_fn)>::class_type, class_337>);
struct class_338 { volatile int * volatile && mem_fn(volatile bool *, const volatile bool *, bool &) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_338::mem_fn)>::result_type, volatile int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_338::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_338::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_338::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_338::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_338::mem_fn)>::arg0_type, volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_338::mem_fn)>::arg_type<0>, volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_338::mem_fn)>::arg1_type, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_338::mem_fn)>::arg_type<1>, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_338::mem_fn)>::arg2_type, bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_338::mem_fn)>::arg_type<2>, bool &>);
static_assert(callable_traits<decltype(&class_338::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_338::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_338::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_338::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_338::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_338::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_338::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_338::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_338::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_338::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_338::mem_fn)>::class_type, class_338>);
struct class_339 { const volatile int * volatile && mem_fn(const bool &, volatile bool &, const volatile bool &, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_339::mem_fn)>::result_type, const volatile int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_339::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_339::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_339::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_339::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_339::mem_fn)>::arg0_type, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_339::mem_fn)>::arg_type<0>, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_339::mem_fn)>::arg1_type, volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_339::mem_fn)>::arg_type<1>, volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_339::mem_fn)>::arg2_type, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_339::mem_fn)>::arg_type<2>, const volatile bool &>);
static_assert(callable_traits<decltype(&class_339::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_339::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_339::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_339::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_339::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_339::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_339::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_339::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_339::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_339::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_339::mem_fn)>::class_type, class_339>);
struct class_340 { int * const volatile && mem_fn(bool * &, const bool * &, volatile bool * &) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_340::mem_fn)>::result_type, int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_340::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_340::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_340::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_340::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_340::mem_fn)>::arg0_type, bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_340::mem_fn)>::arg_type<0>, bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_340::mem_fn)>::arg1_type, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_340::mem_fn)>::arg_type<1>, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_340::mem_fn)>::arg2_type, volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_340::mem_fn)>::arg_type<2>, volatile bool * &>);
static_assert(callable_traits<decltype(&class_340::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_340::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_340::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_340::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_340::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_340::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_340::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_340::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_340::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_340::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_340::mem_fn)>::class_type, class_340>);
struct class_341 { const int * const volatile && mem_fn(const volatile bool * &, bool * const &, const bool * const &, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_341::mem_fn)>::result_type, const int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_341::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_341::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_341::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_341::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_341::mem_fn)>::arg0_type, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_341::mem_fn)>::arg_type<0>, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_341::mem_fn)>::arg1_type, bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_341::mem_fn)>::arg_type<1>, bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_341::mem_fn)>::arg2_type, const bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_341::mem_fn)>::arg_type<2>, const bool * const &>);
static_assert(callable_traits<decltype(&class_341::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_341::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_341::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_341::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_341::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_341::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_341::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_341::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_341::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_341::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_341::mem_fn)>::class_type, class_341>);
struct class_342 { volatile int * const volatile && mem_fn(volatile bool * const &, const volatile bool * const &, bool * volatile &) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_342::mem_fn)>::result_type, volatile int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_342::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_342::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_342::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_342::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_342::mem_fn)>::arg0_type, volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_342::mem_fn)>::arg_type<0>, volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_342::mem_fn)>::arg1_type, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_342::mem_fn)>::arg_type<1>, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_342::mem_fn)>::arg2_type, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_342::mem_fn)>::arg_type<2>, bool * volatile &>);
static_assert(callable_traits<decltype(&class_342::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_342::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_342::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_342::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_342::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_342::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_342::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_342::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_342::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_342::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_342::mem_fn)>::class_type, class_342>);
struct class_343 { const volatile int * const volatile && mem_fn(const bool * volatile &, volatile bool * volatile &, const volatile bool * volatile &, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_343::mem_fn)>::result_type, const volatile int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_343::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_343::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_343::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_343::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_343::mem_fn)>::arg0_type, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_343::mem_fn)>::arg_type<0>, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_343::mem_fn)>::arg1_type, volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_343::mem_fn)>::arg_type<1>, volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_343::mem_fn)>::arg2_type, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_343::mem_fn)>::arg_type<2>, const volatile bool * volatile &>);
static_assert(callable_traits<decltype(&class_343::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_343::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_343::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_343::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_343::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_343::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_343::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_343::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_343::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_343::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_343::mem_fn)>::class_type, class_343>);
struct class_344 { float mem_fn(bool * const volatile &, const bool * const volatile &, volatile bool * const volatile &) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_344::mem_fn)>::result_type, float>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_344::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_344::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_344::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_344::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_344::mem_fn)>::arg0_type, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_344::mem_fn)>::arg_type<0>, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_344::mem_fn)>::arg1_type, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_344::mem_fn)>::arg_type<1>, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_344::mem_fn)>::arg2_type, volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_344::mem_fn)>::arg_type<2>, volatile bool * const volatile &>);
static_assert(callable_traits<decltype(&class_344::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_344::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_344::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_344::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_344::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_344::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_344::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_344::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_344::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_344::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_344::mem_fn)>::class_type, class_344>);
struct class_345 { float * mem_fn(const volatile bool * const volatile &, bool &&, const bool &&, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_345::mem_fn)>::result_type, float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_345::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_345::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_345::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_345::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_345::mem_fn)>::arg0_type, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_345::mem_fn)>::arg_type<0>, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_345::mem_fn)>::arg1_type, bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_345::mem_fn)>::arg_type<1>, bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_345::mem_fn)>::arg2_type, const bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_345::mem_fn)>::arg_type<2>, const bool &&>);
static_assert(callable_traits<decltype(&class_345::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_345::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_345::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_345::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_345::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_345::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_345::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_345::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_345::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_345::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_345::mem_fn)>::class_type, class_345>);
struct class_346 { const float * mem_fn(volatile bool &&, const volatile bool &&, bool * &&) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_346::mem_fn)>::result_type, const float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_346::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_346::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_346::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_346::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_346::mem_fn)>::arg0_type, volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_346::mem_fn)>::arg_type<0>, volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_346::mem_fn)>::arg1_type, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_346::mem_fn)>::arg_type<1>, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_346::mem_fn)>::arg2_type, bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_346::mem_fn)>::arg_type<2>, bool * &&>);
static_assert(callable_traits<decltype(&class_346::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_346::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_346::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_346::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_346::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_346::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_346::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_346::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_346::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_346::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_346::mem_fn)>::class_type, class_346>);
struct class_347 { volatile float * mem_fn(const bool * &&, volatile bool * &&, const volatile bool * &&, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_347::mem_fn)>::result_type, volatile float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_347::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_347::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_347::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_347::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_347::mem_fn)>::arg0_type, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_347::mem_fn)>::arg_type<0>, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_347::mem_fn)>::arg1_type, volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_347::mem_fn)>::arg_type<1>, volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_347::mem_fn)>::arg2_type, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_347::mem_fn)>::arg_type<2>, const volatile bool * &&>);
static_assert(callable_traits<decltype(&class_347::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_347::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_347::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_347::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_347::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_347::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_347::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_347::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_347::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_347::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_347::mem_fn)>::class_type, class_347>);
struct class_348 { const volatile float * mem_fn(bool * const &&, const bool * const &&, volatile bool * const &&) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_348::mem_fn)>::result_type, const volatile float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_348::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_348::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_348::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_348::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_348::mem_fn)>::arg0_type, bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_348::mem_fn)>::arg_type<0>, bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_348::mem_fn)>::arg1_type, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_348::mem_fn)>::arg_type<1>, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_348::mem_fn)>::arg2_type, volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_348::mem_fn)>::arg_type<2>, volatile bool * const &&>);
static_assert(callable_traits<decltype(&class_348::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_348::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_348::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_348::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_348::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_348::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_348::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_348::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_348::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_348::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_348::mem_fn)>::class_type, class_348>);
struct class_349 { float & mem_fn(const volatile bool * const &&, bool * volatile &&, const bool * volatile &&, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_349::mem_fn)>::result_type, float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_349::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_349::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_349::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_349::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_349::mem_fn)>::arg0_type, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_349::mem_fn)>::arg_type<0>, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_349::mem_fn)>::arg1_type, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_349::mem_fn)>::arg_type<1>, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_349::mem_fn)>::arg2_type, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_349::mem_fn)>::arg_type<2>, const bool * volatile &&>);
static_assert(callable_traits<decltype(&class_349::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_349::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_349::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_349::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_349::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_349::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_349::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_349::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_349::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_349::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_349::mem_fn)>::class_type, class_349>);
struct class_350 { const float & mem_fn(volatile bool * volatile &&, const volatile bool * volatile &&, bool * const volatile &&) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_350::mem_fn)>::result_type, const float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_350::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_350::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_350::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_350::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_350::mem_fn)>::arg0_type, volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_350::mem_fn)>::arg_type<0>, volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_350::mem_fn)>::arg1_type, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_350::mem_fn)>::arg_type<1>, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_350::mem_fn)>::arg2_type, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_350::mem_fn)>::arg_type<2>, bool * const volatile &&>);
static_assert(callable_traits<decltype(&class_350::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_350::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_350::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_350::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_350::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_350::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_350::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_350::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_350::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_350::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_350::mem_fn)>::class_type, class_350>);
struct class_351 { volatile float & mem_fn(const bool * const volatile &&, volatile bool * const volatile &&, const volatile bool * const volatile &&, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_351::mem_fn)>::result_type, volatile float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_351::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_351::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_351::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_351::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_351::mem_fn)>::arg0_type, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_351::mem_fn)>::arg_type<0>, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_351::mem_fn)>::arg1_type, volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_351::mem_fn)>::arg_type<1>, volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_351::mem_fn)>::arg2_type, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_351::mem_fn)>::arg_type<2>, const volatile bool * const volatile &&>);
static_assert(callable_traits<decltype(&class_351::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_351::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_351::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_351::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_351::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_351::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_351::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_351::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_351::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_351::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_351::mem_fn)>::class_type, class_351>);
struct class_352 { const volatile float & mem_fn(int, int *, const int *) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_352::mem_fn)>::result_type, const volatile float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_352::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_352::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_352::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_352::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_352::mem_fn)>::arg0_type, int>);
static_assert(std::is_same_v<callable_traits<decltype(&class_352::mem_fn)>::arg_type<0>, int>);
static_assert(std::is_same_v<callable_traits<decltype(&class_352::mem_fn)>::arg1_type, int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_352::mem_fn)>::arg_type<1>, int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_352::mem_fn)>::arg2_type, const int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_352::mem_fn)>::arg_type<2>, const int *>);
static_assert(callable_traits<decltype(&class_352::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_352::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_352::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_352::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_352::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_352::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_352::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_352::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_352::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_352::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_352::mem_fn)>::class_type, class_352>);
struct class_353 { float * & mem_fn(volatile int *, const volatile int *, int &, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_353::mem_fn)>::result_type, float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_353::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_353::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_353::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_353::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_353::mem_fn)>::arg0_type, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_353::mem_fn)>::arg_type<0>, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_353::mem_fn)>::arg1_type, const volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_353::mem_fn)>::arg_type<1>, const volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_353::mem_fn)>::arg2_type, int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_353::mem_fn)>::arg_type<2>, int &>);
static_assert(callable_traits<decltype(&class_353::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_353::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_353::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_353::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_353::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_353::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_353::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_353::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_353::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_353::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_353::mem_fn)>::class_type, class_353>);
struct class_354 { const float * & mem_fn(const int &, volatile int &, const volatile int &) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_354::mem_fn)>::result_type, const float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_354::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_354::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_354::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_354::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_354::mem_fn)>::arg0_type, const int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_354::mem_fn)>::arg_type<0>, const int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_354::mem_fn)>::arg1_type, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_354::mem_fn)>::arg_type<1>, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_354::mem_fn)>::arg2_type, const volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_354::mem_fn)>::arg_type<2>, const volatile int &>);
static_assert(callable_traits<decltype(&class_354::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_354::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_354::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_354::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_354::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_354::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_354::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_354::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_354::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_354::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_354::mem_fn)>::class_type, class_354>);
struct class_355 { volatile float * & mem_fn(int * &, const int * &, volatile int * &, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_355::mem_fn)>::result_type, volatile float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_355::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_355::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_355::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_355::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_355::mem_fn)>::arg0_type, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_355::mem_fn)>::arg_type<0>, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_355::mem_fn)>::arg1_type, const int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_355::mem_fn)>::arg_type<1>, const int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_355::mem_fn)>::arg2_type, volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_355::mem_fn)>::arg_type<2>, volatile int * &>);
static_assert(callable_traits<decltype(&class_355::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_355::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_355::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_355::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_355::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_355::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_355::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_355::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_355::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_355::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_355::mem_fn)>::class_type, class_355>);
struct class_356 { const volatile float * & mem_fn(const volatile int * &, int * const &, const int * const &) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_356::mem_fn)>::result_type, const volatile float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_356::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_356::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_356::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_356::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_356::mem_fn)>::arg0_type, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_356::mem_fn)>::arg_type<0>, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_356::mem_fn)>::arg1_type, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_356::mem_fn)>::arg_type<1>, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_356::mem_fn)>::arg2_type, const int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_356::mem_fn)>::arg_type<2>, const int * const &>);
static_assert(callable_traits<decltype(&class_356::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_356::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_356::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_356::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_356::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_356::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_356::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_356::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_356::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_356::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_356::mem_fn)>::class_type, class_356>);
struct class_357 { float * const & mem_fn(volatile int * const &, const volatile int * const &, int * volatile &, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_357::mem_fn)>::result_type, float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_357::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_357::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_357::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_357::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_357::mem_fn)>::arg0_type, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_357::mem_fn)>::arg_type<0>, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_357::mem_fn)>::arg1_type, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_357::mem_fn)>::arg_type<1>, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_357::mem_fn)>::arg2_type, int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_357::mem_fn)>::arg_type<2>, int * volatile &>);
static_assert(callable_traits<decltype(&class_357::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_357::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_357::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_357::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_357::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_357::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_357::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_357::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_357::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_357::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_357::mem_fn)>::class_type, class_357>);
struct class_358 { const float * const & mem_fn(const int * volatile &, volatile int * volatile &, const volatile int * volatile &) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_358::mem_fn)>::result_type, const float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_358::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_358::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_358::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_358::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_358::mem_fn)>::arg0_type, const int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_358::mem_fn)>::arg_type<0>, const int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_358::mem_fn)>::arg1_type, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_358::mem_fn)>::arg_type<1>, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_358::mem_fn)>::arg2_type, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_358::mem_fn)>::arg_type<2>, const volatile int * volatile &>);
static_assert(callable_traits<decltype(&class_358::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_358::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_358::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_358::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_358::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_358::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_358::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_358::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_358::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_358::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_358::mem_fn)>::class_type, class_358>);
struct class_359 { volatile float * const & mem_fn(int * const volatile &, const int * const volatile &, volatile int * const volatile &, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_359::mem_fn)>::result_type, volatile float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_359::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_359::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_359::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_359::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_359::mem_fn)>::arg0_type, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_359::mem_fn)>::arg_type<0>, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_359::mem_fn)>::arg1_type, const int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_359::mem_fn)>::arg_type<1>, const int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_359::mem_fn)>::arg2_type, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_359::mem_fn)>::arg_type<2>, volatile int * const volatile &>);
static_assert(callable_traits<decltype(&class_359::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_359::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_359::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_359::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_359::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_359::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_359::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_359::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_359::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_359::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_359::mem_fn)>::class_type, class_359>);
struct class_360 { const volatile float * const & mem_fn(const volatile int * const volatile &, int &&, const int &&); };
static_assert(std::is_same_v<callable_traits<decltype(&class_360::mem_fn)>::result_type, const volatile float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_360::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_360::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_360::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_360::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_360::mem_fn)>::arg0_type, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_360::mem_fn)>::arg_type<0>, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_360::mem_fn)>::arg1_type, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_360::mem_fn)>::arg_type<1>, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_360::mem_fn)>::arg2_type, const int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_360::mem_fn)>::arg_type<2>, const int &&>);
static_assert(callable_traits<decltype(&class_360::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_360::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_360::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_360::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_360::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_360::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_360::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_360::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_360::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_360::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_360::mem_fn)>::class_type, class_360>);
struct class_361 { float * volatile & mem_fn(volatile int &&, const volatile int &&, int * &&, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_361::mem_fn)>::result_type, float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_361::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_361::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_361::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_361::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_361::mem_fn)>::arg0_type, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_361::mem_fn)>::arg_type<0>, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_361::mem_fn)>::arg1_type, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_361::mem_fn)>::arg_type<1>, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_361::mem_fn)>::arg2_type, int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_361::mem_fn)>::arg_type<2>, int * &&>);
static_assert(callable_traits<decltype(&class_361::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_361::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_361::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_361::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_361::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_361::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_361::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_361::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_361::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_361::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_361::mem_fn)>::class_type, class_361>);
struct class_362 { const float * volatile & mem_fn(const int * &&, volatile int * &&, const volatile int * &&) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_362::mem_fn)>::result_type, const float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_362::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_362::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_362::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_362::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_362::mem_fn)>::arg0_type, const int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_362::mem_fn)>::arg_type<0>, const int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_362::mem_fn)>::arg1_type, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_362::mem_fn)>::arg_type<1>, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_362::mem_fn)>::arg2_type, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_362::mem_fn)>::arg_type<2>, const volatile int * &&>);
static_assert(callable_traits<decltype(&class_362::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_362::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_362::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_362::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_362::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_362::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_362::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_362::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_362::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_362::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_362::mem_fn)>::class_type, class_362>);
struct class_363 { volatile float * volatile & mem_fn(int * const &&, const int * const &&, volatile int * const &&, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_363::mem_fn)>::result_type, volatile float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_363::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_363::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_363::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_363::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_363::mem_fn)>::arg0_type, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_363::mem_fn)>::arg_type<0>, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_363::mem_fn)>::arg1_type, const int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_363::mem_fn)>::arg_type<1>, const int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_363::mem_fn)>::arg2_type, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_363::mem_fn)>::arg_type<2>, volatile int * const &&>);
static_assert(callable_traits<decltype(&class_363::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_363::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_363::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_363::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_363::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_363::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_363::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_363::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_363::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_363::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_363::mem_fn)>::class_type, class_363>);
struct class_364 { const volatile float * volatile & mem_fn(const volatile int * const &&, int * volatile &&, const int * volatile &&) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_364::mem_fn)>::result_type, const volatile float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_364::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_364::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_364::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_364::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_364::mem_fn)>::arg0_type, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_364::mem_fn)>::arg_type<0>, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_364::mem_fn)>::arg1_type, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_364::mem_fn)>::arg_type<1>, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_364::mem_fn)>::arg2_type, const int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_364::mem_fn)>::arg_type<2>, const int * volatile &&>);
static_assert(callable_traits<decltype(&class_364::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_364::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_364::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_364::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_364::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_364::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_364::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_364::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_364::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_364::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_364::mem_fn)>::class_type, class_364>);
struct class_365 { float * const volatile & mem_fn(volatile int * volatile &&, const volatile int * volatile &&, int * const volatile &&, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_365::mem_fn)>::result_type, float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_365::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_365::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_365::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_365::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_365::mem_fn)>::arg0_type, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_365::mem_fn)>::arg_type<0>, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_365::mem_fn)>::arg1_type, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_365::mem_fn)>::arg_type<1>, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_365::mem_fn)>::arg2_type, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_365::mem_fn)>::arg_type<2>, int * const volatile &&>);
static_assert(callable_traits<decltype(&class_365::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_365::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_365::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_365::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_365::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_365::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_365::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_365::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_365::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_365::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_365::mem_fn)>::class_type, class_365>);
struct class_366 { const float * const volatile & mem_fn(const int * const volatile &&, volatile int * const volatile &&, const volatile int * const volatile &&) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_366::mem_fn)>::result_type, const float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_366::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_366::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_366::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_366::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_366::mem_fn)>::arg0_type, const int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_366::mem_fn)>::arg_type<0>, const int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_366::mem_fn)>::arg1_type, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_366::mem_fn)>::arg_type<1>, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_366::mem_fn)>::arg2_type, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_366::mem_fn)>::arg_type<2>, const volatile int * const volatile &&>);
static_assert(callable_traits<decltype(&class_366::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_366::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_366::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_366::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_366::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_366::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_366::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_366::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_366::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_366::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_366::mem_fn)>::class_type, class_366>);
struct class_367 { volatile float * const volatile & mem_fn(float, float *, const float *, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_367::mem_fn)>::result_type, volatile float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_367::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_367::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_367::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_367::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_367::mem_fn)>::arg0_type, float>);
static_assert(std::is_same_v<callable_traits<decltype(&class_367::mem_fn)>::arg_type<0>, float>);
static_assert(std::is_same_v<callable_traits<decltype(&class_367::mem_fn)>::arg1_type, float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_367::mem_fn)>::arg_type<1>, float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_367::mem_fn)>::arg2_type, const float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_367::mem_fn)>::arg_type<2>, const float *>);
static_assert(callable_traits<decltype(&class_367::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_367::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_367::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_367::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_367::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_367::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_367::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_367::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_367::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_367::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_367::mem_fn)>::class_type, class_367>);
struct class_368 { const volatile float * const volatile & mem_fn(volatile float *, const volatile float *, float &) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_368::mem_fn)>::result_type, const volatile float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_368::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_368::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_368::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_368::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_368::mem_fn)>::arg0_type, volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_368::mem_fn)>::arg_type<0>, volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_368::mem_fn)>::arg1_type, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_368::mem_fn)>::arg_type<1>, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_368::mem_fn)>::arg2_type, float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_368::mem_fn)>::arg_type<2>, float &>);
static_assert(callable_traits<decltype(&class_368::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_368::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_368::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_368::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_368::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_368::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_368::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_368::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_368::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_368::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_368::mem_fn)>::class_type, class_368>);
struct class_369 { float && mem_fn(const float &, volatile float &, const volatile float &, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_369::mem_fn)>::result_type, float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_369::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_369::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_369::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_369::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_369::mem_fn)>::arg0_type, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_369::mem_fn)>::arg_type<0>, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_369::mem_fn)>::arg1_type, volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_369::mem_fn)>::arg_type<1>, volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_369::mem_fn)>::arg2_type, const volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_369::mem_fn)>::arg_type<2>, const volatile float &>);
static_assert(callable_traits<decltype(&class_369::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_369::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_369::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_369::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_369::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_369::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_369::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_369::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_369::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_369::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_369::mem_fn)>::class_type, class_369>);
struct class_370 { const float && mem_fn(float * &, const float * &, volatile float * &) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_370::mem_fn)>::result_type, const float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_370::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_370::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_370::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_370::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_370::mem_fn)>::arg0_type, float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_370::mem_fn)>::arg_type<0>, float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_370::mem_fn)>::arg1_type, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_370::mem_fn)>::arg_type<1>, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_370::mem_fn)>::arg2_type, volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_370::mem_fn)>::arg_type<2>, volatile float * &>);
static_assert(callable_traits<decltype(&class_370::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_370::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_370::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_370::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_370::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_370::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_370::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_370::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_370::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_370::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_370::mem_fn)>::class_type, class_370>);
struct class_371 { volatile float && mem_fn(const volatile float * &, float * const &, const float * const &, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_371::mem_fn)>::result_type, volatile float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_371::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_371::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_371::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_371::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_371::mem_fn)>::arg0_type, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_371::mem_fn)>::arg_type<0>, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_371::mem_fn)>::arg1_type, float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_371::mem_fn)>::arg_type<1>, float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_371::mem_fn)>::arg2_type, const float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_371::mem_fn)>::arg_type<2>, const float * const &>);
static_assert(callable_traits<decltype(&class_371::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_371::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_371::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_371::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_371::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_371::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_371::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_371::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_371::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_371::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_371::mem_fn)>::class_type, class_371>);
struct class_372 { const volatile float && mem_fn(volatile float * const &, const volatile float * const &, float * volatile &) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_372::mem_fn)>::result_type, const volatile float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_372::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_372::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_372::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_372::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_372::mem_fn)>::arg0_type, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_372::mem_fn)>::arg_type<0>, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_372::mem_fn)>::arg1_type, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_372::mem_fn)>::arg_type<1>, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_372::mem_fn)>::arg2_type, float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_372::mem_fn)>::arg_type<2>, float * volatile &>);
static_assert(callable_traits<decltype(&class_372::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_372::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_372::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_372::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_372::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_372::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_372::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_372::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_372::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_372::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_372::mem_fn)>::class_type, class_372>);
struct class_373 { float * && mem_fn(const float * volatile &, volatile float * volatile &, const volatile float * volatile &, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_373::mem_fn)>::result_type, float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_373::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_373::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_373::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_373::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_373::mem_fn)>::arg0_type, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_373::mem_fn)>::arg_type<0>, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_373::mem_fn)>::arg1_type, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_373::mem_fn)>::arg_type<1>, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_373::mem_fn)>::arg2_type, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_373::mem_fn)>::arg_type<2>, const volatile float * volatile &>);
static_assert(callable_traits<decltype(&class_373::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_373::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_373::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_373::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_373::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_373::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_373::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_373::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_373::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_373::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_373::mem_fn)>::class_type, class_373>);
struct class_374 { const float * && mem_fn(float * const volatile &, const float * const volatile &, volatile float * const volatile &) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_374::mem_fn)>::result_type, const float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_374::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_374::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_374::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_374::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_374::mem_fn)>::arg0_type, float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_374::mem_fn)>::arg_type<0>, float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_374::mem_fn)>::arg1_type, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_374::mem_fn)>::arg_type<1>, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_374::mem_fn)>::arg2_type, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_374::mem_fn)>::arg_type<2>, volatile float * const volatile &>);
static_assert(callable_traits<decltype(&class_374::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_374::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_374::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_374::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_374::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_374::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_374::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_374::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_374::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_374::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_374::mem_fn)>::class_type, class_374>);
struct class_375 { volatile float * && mem_fn(const volatile float * const volatile &, float &&, const float &&, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_375::mem_fn)>::result_type, volatile float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_375::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_375::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_375::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_375::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_375::mem_fn)>::arg0_type, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_375::mem_fn)>::arg_type<0>, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_375::mem_fn)>::arg1_type, float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_375::mem_fn)>::arg_type<1>, float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_375::mem_fn)>::arg2_type, const float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_375::mem_fn)>::arg_type<2>, const float &&>);
static_assert(callable_traits<decltype(&class_375::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_375::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_375::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_375::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_375::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_375::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_375::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_375::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_375::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_375::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_375::mem_fn)>::class_type, class_375>);
struct class_376 { const volatile float * && mem_fn(volatile float &&, const volatile float &&, float * &&) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_376::mem_fn)>::result_type, const volatile float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_376::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_376::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_376::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_376::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_376::mem_fn)>::arg0_type, volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_376::mem_fn)>::arg_type<0>, volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_376::mem_fn)>::arg1_type, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_376::mem_fn)>::arg_type<1>, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_376::mem_fn)>::arg2_type, float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_376::mem_fn)>::arg_type<2>, float * &&>);
static_assert(callable_traits<decltype(&class_376::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_376::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_376::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_376::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_376::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_376::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_376::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_376::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_376::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_376::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_376::mem_fn)>::class_type, class_376>);
struct class_377 { float * const && mem_fn(const float * &&, volatile float * &&, const volatile float * &&, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_377::mem_fn)>::result_type, float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_377::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_377::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_377::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_377::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_377::mem_fn)>::arg0_type, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_377::mem_fn)>::arg_type<0>, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_377::mem_fn)>::arg1_type, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_377::mem_fn)>::arg_type<1>, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_377::mem_fn)>::arg2_type, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_377::mem_fn)>::arg_type<2>, const volatile float * &&>);
static_assert(callable_traits<decltype(&class_377::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_377::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_377::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_377::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_377::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_377::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_377::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_377::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_377::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_377::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_377::mem_fn)>::class_type, class_377>);
struct class_378 { const float * const && mem_fn(float * const &&, const float * const &&, volatile float * const &&) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_378::mem_fn)>::result_type, const float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_378::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_378::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_378::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_378::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_378::mem_fn)>::arg0_type, float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_378::mem_fn)>::arg_type<0>, float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_378::mem_fn)>::arg1_type, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_378::mem_fn)>::arg_type<1>, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_378::mem_fn)>::arg2_type, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_378::mem_fn)>::arg_type<2>, volatile float * const &&>);
static_assert(callable_traits<decltype(&class_378::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_378::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_378::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_378::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_378::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_378::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_378::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_378::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_378::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_378::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_378::mem_fn)>::class_type, class_378>);
struct class_379 { volatile float * const && mem_fn(const volatile float * const &&, float * volatile &&, const float * volatile &&, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_379::mem_fn)>::result_type, volatile float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_379::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_379::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_379::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_379::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_379::mem_fn)>::arg0_type, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_379::mem_fn)>::arg_type<0>, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_379::mem_fn)>::arg1_type, float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_379::mem_fn)>::arg_type<1>, float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_379::mem_fn)>::arg2_type, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_379::mem_fn)>::arg_type<2>, const float * volatile &&>);
static_assert(callable_traits<decltype(&class_379::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_379::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_379::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_379::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_379::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_379::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_379::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_379::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_379::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_379::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_379::mem_fn)>::class_type, class_379>);
struct class_380 { const volatile float * const && mem_fn(volatile float * volatile &&, const volatile float * volatile &&, float * const volatile &&) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_380::mem_fn)>::result_type, const volatile float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_380::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_380::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_380::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_380::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_380::mem_fn)>::arg0_type, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_380::mem_fn)>::arg_type<0>, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_380::mem_fn)>::arg1_type, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_380::mem_fn)>::arg_type<1>, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_380::mem_fn)>::arg2_type, float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_380::mem_fn)>::arg_type<2>, float * const volatile &&>);
static_assert(callable_traits<decltype(&class_380::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_380::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_380::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_380::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_380::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_380::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_380::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_380::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_380::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_380::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_380::mem_fn)>::class_type, class_380>);
struct class_381 { float * volatile && mem_fn(const float * const volatile &&, volatile float * const volatile &&, const volatile float * const volatile &&, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_381::mem_fn)>::result_type, float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_381::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_381::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_381::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_381::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_381::mem_fn)>::arg0_type, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_381::mem_fn)>::arg_type<0>, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_381::mem_fn)>::arg1_type, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_381::mem_fn)>::arg_type<1>, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_381::mem_fn)>::arg2_type, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_381::mem_fn)>::arg_type<2>, const volatile float * const volatile &&>);
static_assert(callable_traits<decltype(&class_381::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_381::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_381::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_381::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_381::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_381::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_381::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_381::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_381::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_381::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_381::mem_fn)>::class_type, class_381>);
struct class_382 { const float * volatile && mem_fn(std::string, std::string *, const std::string *) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_382::mem_fn)>::result_type, const float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_382::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_382::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_382::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_382::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_382::mem_fn)>::arg0_type, std::string>);
static_assert(std::is_same_v<callable_traits<decltype(&class_382::mem_fn)>::arg_type<0>, std::string>);
static_assert(std::is_same_v<callable_traits<decltype(&class_382::mem_fn)>::arg1_type, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_382::mem_fn)>::arg_type<1>, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_382::mem_fn)>::arg2_type, const std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_382::mem_fn)>::arg_type<2>, const std::string *>);
static_assert(callable_traits<decltype(&class_382::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_382::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_382::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_382::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_382::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_382::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_382::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_382::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_382::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_382::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_382::mem_fn)>::class_type, class_382>);
struct class_383 { volatile float * volatile && mem_fn(volatile std::string *, const volatile std::string *, std::string &, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_383::mem_fn)>::result_type, volatile float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_383::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_383::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_383::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_383::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_383::mem_fn)>::arg0_type, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_383::mem_fn)>::arg_type<0>, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_383::mem_fn)>::arg1_type, const volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_383::mem_fn)>::arg_type<1>, const volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_383::mem_fn)>::arg2_type, std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_383::mem_fn)>::arg_type<2>, std::string &>);
static_assert(callable_traits<decltype(&class_383::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_383::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_383::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_383::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_383::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_383::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_383::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_383::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_383::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_383::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_383::mem_fn)>::class_type, class_383>);
struct class_384 { const volatile float * volatile && mem_fn(const std::string &, volatile std::string &, const volatile std::string &); };
static_assert(std::is_same_v<callable_traits<decltype(&class_384::mem_fn)>::result_type, const volatile float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_384::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_384::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_384::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_384::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_384::mem_fn)>::arg0_type, const std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_384::mem_fn)>::arg_type<0>, const std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_384::mem_fn)>::arg1_type, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_384::mem_fn)>::arg_type<1>, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_384::mem_fn)>::arg2_type, const volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_384::mem_fn)>::arg_type<2>, const volatile std::string &>);
static_assert(callable_traits<decltype(&class_384::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_384::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_384::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_384::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_384::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_384::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_384::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_384::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_384::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_384::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_384::mem_fn)>::class_type, class_384>);
struct class_385 { float * const volatile && mem_fn(std::string * &, const std::string * &, volatile std::string * &, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_385::mem_fn)>::result_type, float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_385::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_385::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_385::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_385::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_385::mem_fn)>::arg0_type, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_385::mem_fn)>::arg_type<0>, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_385::mem_fn)>::arg1_type, const std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_385::mem_fn)>::arg_type<1>, const std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_385::mem_fn)>::arg2_type, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_385::mem_fn)>::arg_type<2>, volatile std::string * &>);
static_assert(callable_traits<decltype(&class_385::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_385::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_385::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_385::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_385::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_385::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_385::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_385::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_385::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_385::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_385::mem_fn)>::class_type, class_385>);
struct class_386 { const float * const volatile && mem_fn(const volatile std::string * &, std::string * const &, const std::string * const &) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_386::mem_fn)>::result_type, const float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_386::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_386::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_386::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_386::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_386::mem_fn)>::arg0_type, const volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_386::mem_fn)>::arg_type<0>, const volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_386::mem_fn)>::arg1_type, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_386::mem_fn)>::arg_type<1>, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_386::mem_fn)>::arg2_type, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_386::mem_fn)>::arg_type<2>, const std::string * const &>);
static_assert(callable_traits<decltype(&class_386::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_386::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_386::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_386::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_386::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_386::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_386::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_386::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_386::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_386::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_386::mem_fn)>::class_type, class_386>);
struct class_387 { volatile float * const volatile && mem_fn(volatile std::string * const &, const volatile std::string * const &, std::string * volatile &, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_387::mem_fn)>::result_type, volatile float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_387::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_387::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_387::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_387::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_387::mem_fn)>::arg0_type, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_387::mem_fn)>::arg_type<0>, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_387::mem_fn)>::arg1_type, const volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_387::mem_fn)>::arg_type<1>, const volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_387::mem_fn)>::arg2_type, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_387::mem_fn)>::arg_type<2>, std::string * volatile &>);
static_assert(callable_traits<decltype(&class_387::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_387::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_387::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_387::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_387::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_387::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_387::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_387::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_387::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_387::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_387::mem_fn)>::class_type, class_387>);
struct class_388 { const volatile float * const volatile && mem_fn(const std::string * volatile &, volatile std::string * volatile &, const volatile std::string * volatile &) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_388::mem_fn)>::result_type, const volatile float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_388::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_388::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_388::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_388::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_388::mem_fn)>::arg0_type, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_388::mem_fn)>::arg_type<0>, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_388::mem_fn)>::arg1_type, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_388::mem_fn)>::arg_type<1>, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_388::mem_fn)>::arg2_type, const volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_388::mem_fn)>::arg_type<2>, const volatile std::string * volatile &>);
static_assert(callable_traits<decltype(&class_388::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_388::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_388::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_388::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_388::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_388::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_388::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_388::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_388::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_388::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_388::mem_fn)>::class_type, class_388>);
struct class_389 { std::string mem_fn(std::string * const volatile &, const std::string * const volatile &, volatile std::string * const volatile &, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_389::mem_fn)>::result_type, std::string>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_389::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_389::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_389::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_389::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_389::mem_fn)>::arg0_type, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_389::mem_fn)>::arg_type<0>, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_389::mem_fn)>::arg1_type, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_389::mem_fn)>::arg_type<1>, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_389::mem_fn)>::arg2_type, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_389::mem_fn)>::arg_type<2>, volatile std::string * const volatile &>);
static_assert(callable_traits<decltype(&class_389::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_389::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_389::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_389::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_389::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_389::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_389::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_389::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_389::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_389::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_389::mem_fn)>::class_type, class_389>);
struct class_390 { std::string * mem_fn(const volatile std::string * const volatile &, std::string &&, const std::string &&) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_390::mem_fn)>::result_type, std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_390::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_390::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_390::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_390::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_390::mem_fn)>::arg0_type, const volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_390::mem_fn)>::arg_type<0>, const volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_390::mem_fn)>::arg1_type, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_390::mem_fn)>::arg_type<1>, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_390::mem_fn)>::arg2_type, const std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_390::mem_fn)>::arg_type<2>, const std::string &&>);
static_assert(callable_traits<decltype(&class_390::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_390::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_390::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_390::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_390::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_390::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_390::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_390::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_390::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_390::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_390::mem_fn)>::class_type, class_390>);
struct class_391 { const std::string * mem_fn(volatile std::string &&, const volatile std::string &&, std::string * &&, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_391::mem_fn)>::result_type, const std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_391::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_391::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_391::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_391::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_391::mem_fn)>::arg0_type, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_391::mem_fn)>::arg_type<0>, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_391::mem_fn)>::arg1_type, const volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_391::mem_fn)>::arg_type<1>, const volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_391::mem_fn)>::arg2_type, std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_391::mem_fn)>::arg_type<2>, std::string * &&>);
static_assert(callable_traits<decltype(&class_391::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_391::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_391::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_391::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_391::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_391::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_391::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_391::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_391::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_391::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_391::mem_fn)>::class_type, class_391>);
struct class_392 { volatile std::string * mem_fn(const std::string * &&, volatile std::string * &&, const volatile std::string * &&) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_392::mem_fn)>::result_type, volatile std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_392::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_392::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_392::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_392::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_392::mem_fn)>::arg0_type, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_392::mem_fn)>::arg_type<0>, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_392::mem_fn)>::arg1_type, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_392::mem_fn)>::arg_type<1>, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_392::mem_fn)>::arg2_type, const volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_392::mem_fn)>::arg_type<2>, const volatile std::string * &&>);
static_assert(callable_traits<decltype(&class_392::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_392::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_392::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_392::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_392::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_392::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_392::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_392::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_392::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_392::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_392::mem_fn)>::class_type, class_392>);
struct class_393 { const volatile std::string * mem_fn(std::string * const &&, const std::string * const &&, volatile std::string * const &&, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_393::mem_fn)>::result_type, const volatile std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_393::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_393::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_393::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_393::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_393::mem_fn)>::arg0_type, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_393::mem_fn)>::arg_type<0>, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_393::mem_fn)>::arg1_type, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_393::mem_fn)>::arg_type<1>, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_393::mem_fn)>::arg2_type, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_393::mem_fn)>::arg_type<2>, volatile std::string * const &&>);
static_assert(callable_traits<decltype(&class_393::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_393::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_393::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_393::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_393::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_393::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_393::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_393::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_393::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_393::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_393::mem_fn)>::class_type, class_393>);
struct class_394 { std::string & mem_fn(const volatile std::string * const &&, std::string * volatile &&, const std::string * volatile &&) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_394::mem_fn)>::result_type, std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_394::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_394::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_394::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_394::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_394::mem_fn)>::arg0_type, const volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_394::mem_fn)>::arg_type<0>, const volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_394::mem_fn)>::arg1_type, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_394::mem_fn)>::arg_type<1>, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_394::mem_fn)>::arg2_type, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_394::mem_fn)>::arg_type<2>, const std::string * volatile &&>);
static_assert(callable_traits<decltype(&class_394::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_394::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_394::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_394::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_394::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_394::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_394::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_394::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_394::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_394::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_394::mem_fn)>::class_type, class_394>);
struct class_395 { const std::string & mem_fn(volatile std::string * volatile &&, const volatile std::string * volatile &&, std::string * const volatile &&, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_395::mem_fn)>::result_type, const std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_395::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_395::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_395::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_395::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_395::mem_fn)>::arg0_type, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_395::mem_fn)>::arg_type<0>, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_395::mem_fn)>::arg1_type, const volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_395::mem_fn)>::arg_type<1>, const volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_395::mem_fn)>::arg2_type, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_395::mem_fn)>::arg_type<2>, std::string * const volatile &&>);
static_assert(callable_traits<decltype(&class_395::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_395::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_395::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_395::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_395::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_395::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_395::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_395::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_395::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_395::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_395::mem_fn)>::class_type, class_395>);
struct class_396 { volatile std::string & mem_fn(const std::string * const volatile &&, volatile std::string * const volatile &&, const volatile std::string * const volatile &&) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_396::mem_fn)>::result_type, volatile std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_396::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_396::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_396::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_396::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_396::mem_fn)>::arg0_type, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_396::mem_fn)>::arg_type<0>, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_396::mem_fn)>::arg1_type, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_396::mem_fn)>::arg_type<1>, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_396::mem_fn)>::arg2_type, const volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_396::mem_fn)>::arg_type<2>, const volatile std::string * const volatile &&>);
static_assert(callable_traits<decltype(&class_396::mem_fn)>::arity == 3);
static_assert(callable_traits<decltype(&class_396::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_396::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_396::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_396::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_396::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_396::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_396::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_396::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_396::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_396::mem_fn)>::class_type, class_396>);
struct class_397 { const volatile std::string & mem_fn(void *, const void *, volatile void *, const volatile void *, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_397::mem_fn)>::result_type, const volatile std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_397::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_397::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_397::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_397::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_397::mem_fn)>::arg0_type, void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_397::mem_fn)>::arg_type<0>, void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_397::mem_fn)>::arg1_type, const void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_397::mem_fn)>::arg_type<1>, const void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_397::mem_fn)>::arg2_type, volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_397::mem_fn)>::arg_type<2>, volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_397::mem_fn)>::arg_type<3>, const volatile void *>);
static_assert(callable_traits<decltype(&class_397::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_397::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_397::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_397::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_397::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_397::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_397::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_397::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_397::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_397::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_397::mem_fn)>::class_type, class_397>);
struct class_398 { std::string * & mem_fn(void * &, const void * &, volatile void * &, const volatile void * &) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_398::mem_fn)>::result_type, std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_398::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_398::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_398::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_398::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_398::mem_fn)>::arg0_type, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_398::mem_fn)>::arg_type<0>, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_398::mem_fn)>::arg1_type, const void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_398::mem_fn)>::arg_type<1>, const void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_398::mem_fn)>::arg2_type, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_398::mem_fn)>::arg_type<2>, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_398::mem_fn)>::arg_type<3>, const volatile void * &>);
static_assert(callable_traits<decltype(&class_398::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_398::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_398::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_398::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_398::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_398::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_398::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_398::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_398::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_398::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_398::mem_fn)>::class_type, class_398>);
struct class_399 { const std::string * & mem_fn(void * const &, const void * const &, volatile void * const &, const volatile void * const &, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_399::mem_fn)>::result_type, const std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_399::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_399::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_399::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_399::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_399::mem_fn)>::arg0_type, void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_399::mem_fn)>::arg_type<0>, void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_399::mem_fn)>::arg1_type, const void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_399::mem_fn)>::arg_type<1>, const void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_399::mem_fn)>::arg2_type, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_399::mem_fn)>::arg_type<2>, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_399::mem_fn)>::arg_type<3>, const volatile void * const &>);
static_assert(callable_traits<decltype(&class_399::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_399::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_399::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_399::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_399::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_399::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_399::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_399::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_399::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_399::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_399::mem_fn)>::class_type, class_399>);
struct class_400 { volatile std::string * & mem_fn(void * volatile &, const void * volatile &, volatile void * volatile &, const volatile void * volatile &) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_400::mem_fn)>::result_type, volatile std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_400::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_400::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_400::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_400::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_400::mem_fn)>::arg0_type, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_400::mem_fn)>::arg_type<0>, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_400::mem_fn)>::arg1_type, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_400::mem_fn)>::arg_type<1>, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_400::mem_fn)>::arg2_type, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_400::mem_fn)>::arg_type<2>, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_400::mem_fn)>::arg_type<3>, const volatile void * volatile &>);
static_assert(callable_traits<decltype(&class_400::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_400::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_400::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_400::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_400::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_400::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_400::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_400::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_400::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_400::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_400::mem_fn)>::class_type, class_400>);
struct class_401 { const volatile std::string * & mem_fn(void * const volatile &, const void * const volatile &, volatile void * const volatile &, const volatile void * const volatile &, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_401::mem_fn)>::result_type, const volatile std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_401::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_401::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_401::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_401::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_401::mem_fn)>::arg0_type, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_401::mem_fn)>::arg_type<0>, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_401::mem_fn)>::arg1_type, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_401::mem_fn)>::arg_type<1>, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_401::mem_fn)>::arg2_type, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_401::mem_fn)>::arg_type<2>, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_401::mem_fn)>::arg_type<3>, const volatile void * const volatile &>);
static_assert(callable_traits<decltype(&class_401::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_401::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_401::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_401::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_401::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_401::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_401::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_401::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_401::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_401::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_401::mem_fn)>::class_type, class_401>);
struct class_402 { std::string * const & mem_fn(void * &&, const void * &&, volatile void * &&, const volatile void * &&) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_402::mem_fn)>::result_type, std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_402::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_402::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_402::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_402::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_402::mem_fn)>::arg0_type, void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_402::mem_fn)>::arg_type<0>, void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_402::mem_fn)>::arg1_type, const void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_402::mem_fn)>::arg_type<1>, const void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_402::mem_fn)>::arg2_type, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_402::mem_fn)>::arg_type<2>, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_402::mem_fn)>::arg_type<3>, const volatile void * &&>);
static_assert(callable_traits<decltype(&class_402::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_402::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_402::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_402::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_402::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_402::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_402::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_402::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_402::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_402::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_402::mem_fn)>::class_type, class_402>);
struct class_403 { const std::string * const & mem_fn(void * const &&, const void * const &&, volatile void * const &&, const volatile void * const &&, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_403::mem_fn)>::result_type, const std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_403::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_403::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_403::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_403::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_403::mem_fn)>::arg0_type, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_403::mem_fn)>::arg_type<0>, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_403::mem_fn)>::arg1_type, const void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_403::mem_fn)>::arg_type<1>, const void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_403::mem_fn)>::arg2_type, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_403::mem_fn)>::arg_type<2>, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_403::mem_fn)>::arg_type<3>, const volatile void * const &&>);
static_assert(callable_traits<decltype(&class_403::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_403::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_403::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_403::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_403::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_403::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_403::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_403::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_403::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_403::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_403::mem_fn)>::class_type, class_403>);
struct class_404 { volatile std::string * const & mem_fn(void * volatile &&, const void * volatile &&, volatile void * volatile &&, const volatile void * volatile &&) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_404::mem_fn)>::result_type, volatile std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_404::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_404::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_404::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_404::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_404::mem_fn)>::arg0_type, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_404::mem_fn)>::arg_type<0>, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_404::mem_fn)>::arg1_type, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_404::mem_fn)>::arg_type<1>, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_404::mem_fn)>::arg2_type, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_404::mem_fn)>::arg_type<2>, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_404::mem_fn)>::arg_type<3>, const volatile void * volatile &&>);
static_assert(callable_traits<decltype(&class_404::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_404::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_404::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_404::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_404::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_404::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_404::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_404::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_404::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_404::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_404::mem_fn)>::class_type, class_404>);
struct class_405 { const volatile std::string * const & mem_fn(void * const volatile &&, const void * const volatile &&, volatile void * const volatile &&, const volatile void * const volatile &&, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_405::mem_fn)>::result_type, const volatile std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_405::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_405::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_405::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_405::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_405::mem_fn)>::arg0_type, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_405::mem_fn)>::arg_type<0>, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_405::mem_fn)>::arg1_type, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_405::mem_fn)>::arg_type<1>, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_405::mem_fn)>::arg2_type, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_405::mem_fn)>::arg_type<2>, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_405::mem_fn)>::arg_type<3>, const volatile void * const volatile &&>);
static_assert(callable_traits<decltype(&class_405::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_405::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_405::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_405::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_405::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_405::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_405::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_405::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_405::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_405::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_405::mem_fn)>::class_type, class_405>);
struct class_406 { std::string * volatile & mem_fn(bool, bool *, const bool *, volatile bool *) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_406::mem_fn)>::result_type, std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_406::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_406::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_406::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_406::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_406::mem_fn)>::arg0_type, bool>);
static_assert(std::is_same_v<callable_traits<decltype(&class_406::mem_fn)>::arg_type<0>, bool>);
static_assert(std::is_same_v<callable_traits<decltype(&class_406::mem_fn)>::arg1_type, bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_406::mem_fn)>::arg_type<1>, bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_406::mem_fn)>::arg2_type, const bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_406::mem_fn)>::arg_type<2>, const bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_406::mem_fn)>::arg_type<3>, volatile bool *>);
static_assert(callable_traits<decltype(&class_406::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_406::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_406::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_406::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_406::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_406::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_406::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_406::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_406::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_406::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_406::mem_fn)>::class_type, class_406>);
struct class_407 { const std::string * volatile & mem_fn(const volatile bool *, bool &, const bool &, volatile bool &, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_407::mem_fn)>::result_type, const std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_407::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_407::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_407::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_407::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_407::mem_fn)>::arg0_type, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_407::mem_fn)>::arg_type<0>, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_407::mem_fn)>::arg1_type, bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_407::mem_fn)>::arg_type<1>, bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_407::mem_fn)>::arg2_type, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_407::mem_fn)>::arg_type<2>, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_407::mem_fn)>::arg_type<3>, volatile bool &>);
static_assert(callable_traits<decltype(&class_407::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_407::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_407::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_407::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_407::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_407::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_407::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_407::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_407::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_407::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_407::mem_fn)>::class_type, class_407>);
struct class_408 { volatile std::string * volatile & mem_fn(const volatile bool &, bool * &, const bool * &, volatile bool * &); };
static_assert(std::is_same_v<callable_traits<decltype(&class_408::mem_fn)>::result_type, volatile std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_408::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_408::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_408::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_408::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_408::mem_fn)>::arg0_type, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_408::mem_fn)>::arg_type<0>, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_408::mem_fn)>::arg1_type, bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_408::mem_fn)>::arg_type<1>, bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_408::mem_fn)>::arg2_type, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_408::mem_fn)>::arg_type<2>, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_408::mem_fn)>::arg_type<3>, volatile bool * &>);
static_assert(callable_traits<decltype(&class_408::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_408::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_408::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_408::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_408::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_408::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_408::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_408::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_408::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_408::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_408::mem_fn)>::class_type, class_408>);
struct class_409 { const volatile std::string * volatile & mem_fn(const volatile bool * &, bool * const &, const bool * const &, volatile bool * const &, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_409::mem_fn)>::result_type, const volatile std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_409::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_409::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_409::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_409::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_409::mem_fn)>::arg0_type, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_409::mem_fn)>::arg_type<0>, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_409::mem_fn)>::arg1_type, bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_409::mem_fn)>::arg_type<1>, bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_409::mem_fn)>::arg2_type, const bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_409::mem_fn)>::arg_type<2>, const bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_409::mem_fn)>::arg_type<3>, volatile bool * const &>);
static_assert(callable_traits<decltype(&class_409::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_409::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_409::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_409::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_409::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_409::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_409::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_409::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_409::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_409::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_409::mem_fn)>::class_type, class_409>);
struct class_410 { std::string * const volatile & mem_fn(const volatile bool * const &, bool * volatile &, const bool * volatile &, volatile bool * volatile &) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_410::mem_fn)>::result_type, std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_410::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_410::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_410::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_410::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_410::mem_fn)>::arg0_type, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_410::mem_fn)>::arg_type<0>, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_410::mem_fn)>::arg1_type, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_410::mem_fn)>::arg_type<1>, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_410::mem_fn)>::arg2_type, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_410::mem_fn)>::arg_type<2>, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_410::mem_fn)>::arg_type<3>, volatile bool * volatile &>);
static_assert(callable_traits<decltype(&class_410::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_410::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_410::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_410::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_410::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_410::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_410::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_410::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_410::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_410::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_410::mem_fn)>::class_type, class_410>);
struct class_411 { const std::string * const volatile & mem_fn(const volatile bool * volatile &, bool * const volatile &, const bool * const volatile &, volatile bool * const volatile &, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_411::mem_fn)>::result_type, const std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_411::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_411::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_411::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_411::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_411::mem_fn)>::arg0_type, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_411::mem_fn)>::arg_type<0>, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_411::mem_fn)>::arg1_type, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_411::mem_fn)>::arg_type<1>, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_411::mem_fn)>::arg2_type, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_411::mem_fn)>::arg_type<2>, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_411::mem_fn)>::arg_type<3>, volatile bool * const volatile &>);
static_assert(callable_traits<decltype(&class_411::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_411::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_411::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_411::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_411::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_411::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_411::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_411::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_411::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_411::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_411::mem_fn)>::class_type, class_411>);
struct class_412 { volatile std::string * const volatile & mem_fn(const volatile bool * const volatile &, bool &&, const bool &&, volatile bool &&) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_412::mem_fn)>::result_type, volatile std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_412::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_412::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_412::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_412::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_412::mem_fn)>::arg0_type, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_412::mem_fn)>::arg_type<0>, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_412::mem_fn)>::arg1_type, bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_412::mem_fn)>::arg_type<1>, bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_412::mem_fn)>::arg2_type, const bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_412::mem_fn)>::arg_type<2>, const bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_412::mem_fn)>::arg_type<3>, volatile bool &&>);
static_assert(callable_traits<decltype(&class_412::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_412::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_412::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_412::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_412::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_412::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_412::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_412::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_412::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_412::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_412::mem_fn)>::class_type, class_412>);
struct class_413 { const volatile std::string * const volatile & mem_fn(const volatile bool &&, bool * &&, const bool * &&, volatile bool * &&, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_413::mem_fn)>::result_type, const volatile std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_413::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_413::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_413::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_413::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_413::mem_fn)>::arg0_type, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_413::mem_fn)>::arg_type<0>, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_413::mem_fn)>::arg1_type, bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_413::mem_fn)>::arg_type<1>, bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_413::mem_fn)>::arg2_type, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_413::mem_fn)>::arg_type<2>, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_413::mem_fn)>::arg_type<3>, volatile bool * &&>);
static_assert(callable_traits<decltype(&class_413::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_413::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_413::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_413::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_413::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_413::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_413::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_413::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_413::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_413::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_413::mem_fn)>::class_type, class_413>);
struct class_414 { std::string && mem_fn(const volatile bool * &&, bool * const &&, const bool * const &&, volatile bool * const &&) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_414::mem_fn)>::result_type, std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_414::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_414::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_414::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_414::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_414::mem_fn)>::arg0_type, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_414::mem_fn)>::arg_type<0>, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_414::mem_fn)>::arg1_type, bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_414::mem_fn)>::arg_type<1>, bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_414::mem_fn)>::arg2_type, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_414::mem_fn)>::arg_type<2>, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_414::mem_fn)>::arg_type<3>, volatile bool * const &&>);
static_assert(callable_traits<decltype(&class_414::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_414::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_414::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_414::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_414::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_414::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_414::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_414::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_414::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_414::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_414::mem_fn)>::class_type, class_414>);
struct class_415 { const std::string && mem_fn(const volatile bool * const &&, bool * volatile &&, const bool * volatile &&, volatile bool * volatile &&, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_415::mem_fn)>::result_type, const std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_415::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_415::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_415::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_415::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_415::mem_fn)>::arg0_type, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_415::mem_fn)>::arg_type<0>, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_415::mem_fn)>::arg1_type, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_415::mem_fn)>::arg_type<1>, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_415::mem_fn)>::arg2_type, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_415::mem_fn)>::arg_type<2>, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_415::mem_fn)>::arg_type<3>, volatile bool * volatile &&>);
static_assert(callable_traits<decltype(&class_415::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_415::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_415::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_415::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_415::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_415::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_415::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_415::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_415::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_415::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_415::mem_fn)>::class_type, class_415>);
struct class_416 { volatile std::string && mem_fn(const volatile bool * volatile &&, bool * const volatile &&, const bool * const volatile &&, volatile bool * const volatile &&) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_416::mem_fn)>::result_type, volatile std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_416::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_416::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_416::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_416::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_416::mem_fn)>::arg0_type, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_416::mem_fn)>::arg_type<0>, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_416::mem_fn)>::arg1_type, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_416::mem_fn)>::arg_type<1>, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_416::mem_fn)>::arg2_type, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_416::mem_fn)>::arg_type<2>, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_416::mem_fn)>::arg_type<3>, volatile bool * const volatile &&>);
static_assert(callable_traits<decltype(&class_416::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_416::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_416::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_416::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_416::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_416::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_416::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_416::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_416::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_416::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_416::mem_fn)>::class_type, class_416>);
struct class_417 { const volatile std::string && mem_fn(const volatile bool * const volatile &&, int, int *, const int *, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_417::mem_fn)>::result_type, const volatile std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_417::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_417::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_417::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_417::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_417::mem_fn)>::arg0_type, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_417::mem_fn)>::arg_type<0>, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_417::mem_fn)>::arg1_type, int>);
static_assert(std::is_same_v<callable_traits<decltype(&class_417::mem_fn)>::arg_type<1>, int>);
static_assert(std::is_same_v<callable_traits<decltype(&class_417::mem_fn)>::arg2_type, int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_417::mem_fn)>::arg_type<2>, int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_417::mem_fn)>::arg_type<3>, const int *>);
static_assert(callable_traits<decltype(&class_417::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_417::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_417::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_417::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_417::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_417::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_417::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_417::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_417::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_417::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_417::mem_fn)>::class_type, class_417>);
struct class_418 { std::string * && mem_fn(volatile int *, const volatile int *, int &, const int &) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_418::mem_fn)>::result_type, std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_418::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_418::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_418::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_418::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_418::mem_fn)>::arg0_type, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_418::mem_fn)>::arg_type<0>, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_418::mem_fn)>::arg1_type, const volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_418::mem_fn)>::arg_type<1>, const volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_418::mem_fn)>::arg2_type, int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_418::mem_fn)>::arg_type<2>, int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_418::mem_fn)>::arg_type<3>, const int &>);
static_assert(callable_traits<decltype(&class_418::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_418::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_418::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_418::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_418::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_418::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_418::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_418::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_418::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_418::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_418::mem_fn)>::class_type, class_418>);
struct class_419 { const std::string * && mem_fn(volatile int &, const volatile int &, int * &, const int * &, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_419::mem_fn)>::result_type, const std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_419::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_419::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_419::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_419::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_419::mem_fn)>::arg0_type, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_419::mem_fn)>::arg_type<0>, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_419::mem_fn)>::arg1_type, const volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_419::mem_fn)>::arg_type<1>, const volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_419::mem_fn)>::arg2_type, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_419::mem_fn)>::arg_type<2>, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_419::mem_fn)>::arg_type<3>, const int * &>);
static_assert(callable_traits<decltype(&class_419::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_419::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_419::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_419::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_419::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_419::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_419::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_419::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_419::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_419::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_419::mem_fn)>::class_type, class_419>);
struct class_420 { volatile std::string * && mem_fn(volatile int * &, const volatile int * &, int * const &, const int * const &) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_420::mem_fn)>::result_type, volatile std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_420::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_420::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_420::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_420::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_420::mem_fn)>::arg0_type, volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_420::mem_fn)>::arg_type<0>, volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_420::mem_fn)>::arg1_type, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_420::mem_fn)>::arg_type<1>, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_420::mem_fn)>::arg2_type, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_420::mem_fn)>::arg_type<2>, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_420::mem_fn)>::arg_type<3>, const int * const &>);
static_assert(callable_traits<decltype(&class_420::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_420::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_420::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_420::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_420::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_420::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_420::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_420::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_420::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_420::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_420::mem_fn)>::class_type, class_420>);
struct class_421 { const volatile std::string * && mem_fn(volatile int * const &, const volatile int * const &, int * volatile &, const int * volatile &, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_421::mem_fn)>::result_type, const volatile std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_421::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_421::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_421::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_421::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_421::mem_fn)>::arg0_type, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_421::mem_fn)>::arg_type<0>, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_421::mem_fn)>::arg1_type, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_421::mem_fn)>::arg_type<1>, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_421::mem_fn)>::arg2_type, int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_421::mem_fn)>::arg_type<2>, int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_421::mem_fn)>::arg_type<3>, const int * volatile &>);
static_assert(callable_traits<decltype(&class_421::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_421::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_421::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_421::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_421::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_421::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_421::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_421::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_421::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_421::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_421::mem_fn)>::class_type, class_421>);
struct class_422 { std::string * const && mem_fn(volatile int * volatile &, const volatile int * volatile &, int * const volatile &, const int * const volatile &) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_422::mem_fn)>::result_type, std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_422::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_422::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_422::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_422::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_422::mem_fn)>::arg0_type, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_422::mem_fn)>::arg_type<0>, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_422::mem_fn)>::arg1_type, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_422::mem_fn)>::arg_type<1>, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_422::mem_fn)>::arg2_type, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_422::mem_fn)>::arg_type<2>, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_422::mem_fn)>::arg_type<3>, const int * const volatile &>);
static_assert(callable_traits<decltype(&class_422::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_422::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_422::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_422::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_422::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_422::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_422::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_422::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_422::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_422::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_422::mem_fn)>::class_type, class_422>);
struct class_423 { const std::string * const && mem_fn(volatile int * const volatile &, const volatile int * const volatile &, int &&, const int &&, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_423::mem_fn)>::result_type, const std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_423::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_423::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_423::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_423::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_423::mem_fn)>::arg0_type, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_423::mem_fn)>::arg_type<0>, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_423::mem_fn)>::arg1_type, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_423::mem_fn)>::arg_type<1>, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_423::mem_fn)>::arg2_type, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_423::mem_fn)>::arg_type<2>, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_423::mem_fn)>::arg_type<3>, const int &&>);
static_assert(callable_traits<decltype(&class_423::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_423::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_423::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_423::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_423::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_423::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_423::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_423::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_423::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_423::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_423::mem_fn)>::class_type, class_423>);
struct class_424 { volatile std::string * const && mem_fn(volatile int &&, const volatile int &&, int * &&, const int * &&) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_424::mem_fn)>::result_type, volatile std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_424::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_424::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_424::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_424::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_424::mem_fn)>::arg0_type, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_424::mem_fn)>::arg_type<0>, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_424::mem_fn)>::arg1_type, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_424::mem_fn)>::arg_type<1>, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_424::mem_fn)>::arg2_type, int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_424::mem_fn)>::arg_type<2>, int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_424::mem_fn)>::arg_type<3>, const int * &&>);
static_assert(callable_traits<decltype(&class_424::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_424::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_424::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_424::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_424::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_424::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_424::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_424::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_424::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_424::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_424::mem_fn)>::class_type, class_424>);
struct class_425 { const volatile std::string * const && mem_fn(volatile int * &&, const volatile int * &&, int * const &&, const int * const &&, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_425::mem_fn)>::result_type, const volatile std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_425::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_425::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_425::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_425::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_425::mem_fn)>::arg0_type, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_425::mem_fn)>::arg_type<0>, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_425::mem_fn)>::arg1_type, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_425::mem_fn)>::arg_type<1>, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_425::mem_fn)>::arg2_type, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_425::mem_fn)>::arg_type<2>, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_425::mem_fn)>::arg_type<3>, const int * const &&>);
static_assert(callable_traits<decltype(&class_425::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_425::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_425::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_425::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_425::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_425::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_425::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_425::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_425::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_425::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_425::mem_fn)>::class_type, class_425>);
struct class_426 { std::string * volatile && mem_fn(volatile int * const &&, const volatile int * const &&, int * volatile &&, const int * volatile &&) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_426::mem_fn)>::result_type, std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_426::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_426::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_426::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_426::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_426::mem_fn)>::arg0_type, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_426::mem_fn)>::arg_type<0>, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_426::mem_fn)>::arg1_type, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_426::mem_fn)>::arg_type<1>, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_426::mem_fn)>::arg2_type, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_426::mem_fn)>::arg_type<2>, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_426::mem_fn)>::arg_type<3>, const int * volatile &&>);
static_assert(callable_traits<decltype(&class_426::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_426::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_426::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_426::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_426::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_426::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_426::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_426::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_426::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_426::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_426::mem_fn)>::class_type, class_426>);
struct class_427 { const std::string * volatile && mem_fn(volatile int * volatile &&, const volatile int * volatile &&, int * const volatile &&, const int * const volatile &&, ...) const volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_427::mem_fn)>::result_type, const std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_427::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_427::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_427::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_427::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_427::mem_fn)>::arg0_type, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_427::mem_fn)>::arg_type<0>, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_427::mem_fn)>::arg1_type, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_427::mem_fn)>::arg_type<1>, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_427::mem_fn)>::arg2_type, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_427::mem_fn)>::arg_type<2>, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_427::mem_fn)>::arg_type<3>, const int * const volatile &&>);
static_assert(callable_traits<decltype(&class_427::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_427::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_427::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_427::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_427::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_427::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_427::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_427::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_427::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_427::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_427::mem_fn)>::class_type, class_427>);
struct class_428 { volatile std::string * volatile && mem_fn(volatile int * const volatile &&, const volatile int * const volatile &&, float, float *) && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_428::mem_fn)>::result_type, volatile std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_428::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_428::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_428::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_428::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_428::mem_fn)>::arg0_type, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_428::mem_fn)>::arg_type<0>, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_428::mem_fn)>::arg1_type, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_428::mem_fn)>::arg_type<1>, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_428::mem_fn)>::arg2_type, float>);
static_assert(std::is_same_v<callable_traits<decltype(&class_428::mem_fn)>::arg_type<2>, float>);
static_assert(std::is_same_v<callable_traits<decltype(&class_428::mem_fn)>::arg_type<3>, float *>);
static_assert(callable_traits<decltype(&class_428::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_428::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_428::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_428::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_428::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_428::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_428::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_428::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_428::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_428::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_428::mem_fn)>::class_type, class_428>);
struct class_429 { const volatile std::string * volatile && mem_fn(const float *, volatile float *, const volatile float *, float &, ...) const && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_429::mem_fn)>::result_type, const volatile std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_429::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_429::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_429::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_429::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_429::mem_fn)>::arg0_type, const float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_429::mem_fn)>::arg_type<0>, const float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_429::mem_fn)>::arg1_type, volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_429::mem_fn)>::arg_type<1>, volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_429::mem_fn)>::arg2_type, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_429::mem_fn)>::arg_type<2>, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_429::mem_fn)>::arg_type<3>, float &>);
static_assert(callable_traits<decltype(&class_429::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_429::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_429::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_429::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_429::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_429::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_429::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_429::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_429::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_429::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_429::mem_fn)>::class_type, class_429>);
struct class_430 { std::string * const volatile && mem_fn(const float &, volatile float &, const volatile float &, float * &) volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_430::mem_fn)>::result_type, std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_430::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_430::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_430::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_430::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_430::mem_fn)>::arg0_type, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_430::mem_fn)>::arg_type<0>, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_430::mem_fn)>::arg1_type, volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_430::mem_fn)>::arg_type<1>, volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_430::mem_fn)>::arg2_type, const volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_430::mem_fn)>::arg_type<2>, const volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_430::mem_fn)>::arg_type<3>, float * &>);
static_assert(callable_traits<decltype(&class_430::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_430::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_430::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_430::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_430::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_430::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_430::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_430::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_430::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_430::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_430::mem_fn)>::class_type, class_430>);
struct class_431 { const std::string * const volatile && mem_fn(const float * &, volatile float * &, const volatile float * &, float * const &, ...) const volatile && noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_431::mem_fn)>::result_type, const std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_431::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_431::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_431::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_431::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_431::mem_fn)>::arg0_type, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_431::mem_fn)>::arg_type<0>, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_431::mem_fn)>::arg1_type, volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_431::mem_fn)>::arg_type<1>, volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_431::mem_fn)>::arg2_type, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_431::mem_fn)>::arg_type<2>, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_431::mem_fn)>::arg_type<3>, float * const &>);
static_assert(callable_traits<decltype(&class_431::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_431::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_431::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_431::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_431::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_431::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_431::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_431::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_431::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_431::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_431::mem_fn)>::class_type, class_431>);
struct class_432 { volatile std::string * const volatile && mem_fn(const float * const &, volatile float * const &, const volatile float * const &, float * volatile &); };
static_assert(std::is_same_v<callable_traits<decltype(&class_432::mem_fn)>::result_type, volatile std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_432::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_432::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_432::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_432::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_432::mem_fn)>::arg0_type, const float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_432::mem_fn)>::arg_type<0>, const float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_432::mem_fn)>::arg1_type, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_432::mem_fn)>::arg_type<1>, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_432::mem_fn)>::arg2_type, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_432::mem_fn)>::arg_type<2>, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_432::mem_fn)>::arg_type<3>, float * volatile &>);
static_assert(callable_traits<decltype(&class_432::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_432::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_432::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_432::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_432::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_432::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_432::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_432::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_432::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_432::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_432::mem_fn)>::class_type, class_432>);
struct class_433 { const volatile std::string * const volatile && mem_fn(const float * volatile &, volatile float * volatile &, const volatile float * volatile &, float * const volatile &, ...) const; };
static_assert(std::is_same_v<callable_traits<decltype(&class_433::mem_fn)>::result_type, const volatile std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_433::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_433::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_433::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_433::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_433::mem_fn)>::arg0_type, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_433::mem_fn)>::arg_type<0>, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_433::mem_fn)>::arg1_type, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_433::mem_fn)>::arg_type<1>, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_433::mem_fn)>::arg2_type, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_433::mem_fn)>::arg_type<2>, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_433::mem_fn)>::arg_type<3>, float * const volatile &>);
static_assert(callable_traits<decltype(&class_433::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_433::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_433::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_433::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_433::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_433::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_433::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_433::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_433::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_433::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_433::mem_fn)>::class_type, class_433>);
struct class_434 { void mem_fn(const float * const volatile &, volatile float * const volatile &, const volatile float * const volatile &, float &&) volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_434::mem_fn)>::result_type, void>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_434::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_434::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_434::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_434::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_434::mem_fn)>::arg0_type, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_434::mem_fn)>::arg_type<0>, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_434::mem_fn)>::arg1_type, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_434::mem_fn)>::arg_type<1>, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_434::mem_fn)>::arg2_type, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_434::mem_fn)>::arg_type<2>, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_434::mem_fn)>::arg_type<3>, float &&>);
static_assert(callable_traits<decltype(&class_434::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_434::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_434::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_434::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_434::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_434::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_434::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_434::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_434::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_434::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_434::mem_fn)>::class_type, class_434>);
struct class_435 { void * mem_fn(const float &&, volatile float &&, const volatile float &&, float * &&, ...) const volatile; };
static_assert(std::is_same_v<callable_traits<decltype(&class_435::mem_fn)>::result_type, void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_435::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_435::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_435::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_435::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_435::mem_fn)>::arg0_type, const float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_435::mem_fn)>::arg_type<0>, const float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_435::mem_fn)>::arg1_type, volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_435::mem_fn)>::arg_type<1>, volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_435::mem_fn)>::arg2_type, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_435::mem_fn)>::arg_type<2>, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_435::mem_fn)>::arg_type<3>, float * &&>);
static_assert(callable_traits<decltype(&class_435::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_435::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_435::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_435::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_435::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_435::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_435::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_435::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_435::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_435::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_435::mem_fn)>::class_type, class_435>);
struct class_436 { const void * mem_fn(const float * &&, volatile float * &&, const volatile float * &&, float * const &&) &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_436::mem_fn)>::result_type, const void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_436::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_436::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_436::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_436::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_436::mem_fn)>::arg0_type, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_436::mem_fn)>::arg_type<0>, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_436::mem_fn)>::arg1_type, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_436::mem_fn)>::arg_type<1>, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_436::mem_fn)>::arg2_type, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_436::mem_fn)>::arg_type<2>, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_436::mem_fn)>::arg_type<3>, float * const &&>);
static_assert(callable_traits<decltype(&class_436::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_436::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_436::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_436::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_436::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_436::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_436::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_436::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_436::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_436::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_436::mem_fn)>::class_type, class_436>);
struct class_437 { volatile void * mem_fn(const float * const &&, volatile float * const &&, const volatile float * const &&, float * volatile &&, ...) const &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_437::mem_fn)>::result_type, volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_437::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_437::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_437::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_437::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_437::mem_fn)>::arg0_type, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_437::mem_fn)>::arg_type<0>, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_437::mem_fn)>::arg1_type, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_437::mem_fn)>::arg_type<1>, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_437::mem_fn)>::arg2_type, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_437::mem_fn)>::arg_type<2>, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_437::mem_fn)>::arg_type<3>, float * volatile &&>);
static_assert(callable_traits<decltype(&class_437::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_437::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_437::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_437::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_437::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_437::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_437::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_437::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_437::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_437::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_437::mem_fn)>::class_type, class_437>);
struct class_438 { const volatile void * mem_fn(const float * volatile &&, volatile float * volatile &&, const volatile float * volatile &&, float * const volatile &&) volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_438::mem_fn)>::result_type, const volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_438::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_438::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_438::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_438::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_438::mem_fn)>::arg0_type, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_438::mem_fn)>::arg_type<0>, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_438::mem_fn)>::arg1_type, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_438::mem_fn)>::arg_type<1>, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_438::mem_fn)>::arg2_type, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_438::mem_fn)>::arg_type<2>, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_438::mem_fn)>::arg_type<3>, float * const volatile &&>);
static_assert(callable_traits<decltype(&class_438::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_438::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_438::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_438::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_438::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_438::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_438::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_438::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_438::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_438::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_438::mem_fn)>::class_type, class_438>);
struct class_439 { void * & mem_fn(const float * const volatile &&, volatile float * const volatile &&, const volatile float * const volatile &&, std::string, ...) const volatile &; };
static_assert(std::is_same_v<callable_traits<decltype(&class_439::mem_fn)>::result_type, void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_439::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_439::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_439::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_439::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_439::mem_fn)>::arg0_type, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_439::mem_fn)>::arg_type<0>, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_439::mem_fn)>::arg1_type, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_439::mem_fn)>::arg_type<1>, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_439::mem_fn)>::arg2_type, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_439::mem_fn)>::arg_type<2>, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_439::mem_fn)>::arg_type<3>, std::string>);
static_assert(callable_traits<decltype(&class_439::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_439::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_439::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_439::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_439::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_439::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_439::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_439::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_439::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_439::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_439::mem_fn)>::class_type, class_439>);
struct class_440 { const void * & mem_fn(std::string *, const std::string *, volatile std::string *, const volatile std::string *) &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_440::mem_fn)>::result_type, const void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_440::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_440::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_440::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_440::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_440::mem_fn)>::arg0_type, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_440::mem_fn)>::arg_type<0>, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_440::mem_fn)>::arg1_type, const std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_440::mem_fn)>::arg_type<1>, const std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_440::mem_fn)>::arg2_type, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_440::mem_fn)>::arg_type<2>, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(&class_440::mem_fn)>::arg_type<3>, const volatile std::string *>);
static_assert(callable_traits<decltype(&class_440::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_440::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_440::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_440::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_440::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_440::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_440::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_440::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_440::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_440::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_440::mem_fn)>::class_type, class_440>);
struct class_441 { volatile void * & mem_fn(std::string &, const std::string &, volatile std::string &, const volatile std::string &, ...) const &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_441::mem_fn)>::result_type, volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_441::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_441::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_441::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_441::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_441::mem_fn)>::arg0_type, std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_441::mem_fn)>::arg_type<0>, std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_441::mem_fn)>::arg1_type, const std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_441::mem_fn)>::arg_type<1>, const std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_441::mem_fn)>::arg2_type, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_441::mem_fn)>::arg_type<2>, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_441::mem_fn)>::arg_type<3>, const volatile std::string &>);
static_assert(callable_traits<decltype(&class_441::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_441::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_441::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_441::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_441::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_441::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_441::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_441::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_441::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_441::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_441::mem_fn)>::class_type, class_441>);
struct class_442 { const volatile void * & mem_fn(std::string * &, const std::string * &, volatile std::string * &, const volatile std::string * &) volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_442::mem_fn)>::result_type, const volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_442::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_442::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_442::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_442::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_442::mem_fn)>::arg0_type, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_442::mem_fn)>::arg_type<0>, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_442::mem_fn)>::arg1_type, const std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_442::mem_fn)>::arg_type<1>, const std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_442::mem_fn)>::arg2_type, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_442::mem_fn)>::arg_type<2>, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_442::mem_fn)>::arg_type<3>, const volatile std::string * &>);
static_assert(callable_traits<decltype(&class_442::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_442::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_442::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_442::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_442::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_442::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_442::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_442::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_442::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_442::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_442::mem_fn)>::class_type, class_442>);
struct class_443 { void * const & mem_fn(std::string * const &, const std::string * const &, volatile std::string * const &, const volatile std::string * const &, ...) const volatile &&; };
static_assert(std::is_same_v<callable_traits<decltype(&class_443::mem_fn)>::result_type, void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_443::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_443::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_443::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_443::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_443::mem_fn)>::arg0_type, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_443::mem_fn)>::arg_type<0>, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_443::mem_fn)>::arg1_type, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_443::mem_fn)>::arg_type<1>, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_443::mem_fn)>::arg2_type, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_443::mem_fn)>::arg_type<2>, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_443::mem_fn)>::arg_type<3>, const volatile std::string * const &>);
static_assert(callable_traits<decltype(&class_443::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_443::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_443::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_443::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_443::mem_fn)>::is_noexcept == false);
static_assert(callable_traits<decltype(&class_443::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_443::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_443::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_443::mem_fn)>::is_rvalue_reference == true);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_443::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_443::mem_fn)>::class_type, class_443>);
struct class_444 { const void * const & mem_fn(std::string * volatile &, const std::string * volatile &, volatile std::string * volatile &, const volatile std::string * volatile &) noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_444::mem_fn)>::result_type, const void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_444::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_444::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_444::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_444::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_444::mem_fn)>::arg0_type, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_444::mem_fn)>::arg_type<0>, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_444::mem_fn)>::arg1_type, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_444::mem_fn)>::arg_type<1>, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_444::mem_fn)>::arg2_type, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_444::mem_fn)>::arg_type<2>, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_444::mem_fn)>::arg_type<3>, const volatile std::string * volatile &>);
static_assert(callable_traits<decltype(&class_444::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_444::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_444::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_444::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_444::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_444::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_444::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_444::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_444::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_444::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_444::mem_fn)>::class_type, class_444>);
struct class_445 { volatile void * const & mem_fn(std::string * const volatile &, const std::string * const volatile &, volatile std::string * const volatile &, const volatile std::string * const volatile &, ...) const noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_445::mem_fn)>::result_type, volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_445::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_445::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_445::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_445::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_445::mem_fn)>::arg0_type, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_445::mem_fn)>::arg_type<0>, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_445::mem_fn)>::arg1_type, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_445::mem_fn)>::arg_type<1>, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_445::mem_fn)>::arg2_type, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_445::mem_fn)>::arg_type<2>, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(&class_445::mem_fn)>::arg_type<3>, const volatile std::string * const volatile &>);
static_assert(callable_traits<decltype(&class_445::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_445::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_445::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_445::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_445::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_445::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_445::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_445::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_445::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_445::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_445::mem_fn)>::class_type, class_445>);
struct class_446 { const volatile void * const & mem_fn(std::string &&, const std::string &&, volatile std::string &&, const volatile std::string &&) volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_446::mem_fn)>::result_type, const volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_446::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_446::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_446::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_446::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_446::mem_fn)>::arg0_type, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_446::mem_fn)>::arg_type<0>, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_446::mem_fn)>::arg1_type, const std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_446::mem_fn)>::arg_type<1>, const std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_446::mem_fn)>::arg2_type, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_446::mem_fn)>::arg_type<2>, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_446::mem_fn)>::arg_type<3>, const volatile std::string &&>);
static_assert(callable_traits<decltype(&class_446::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_446::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_446::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_446::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_446::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_446::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_446::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_446::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_446::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_446::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_446::mem_fn)>::class_type, class_446>);
struct class_447 { void * volatile & mem_fn(std::string * &&, const std::string * &&, volatile std::string * &&, const volatile std::string * &&, ...) const volatile noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_447::mem_fn)>::result_type, void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_447::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_447::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_447::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_447::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_447::mem_fn)>::arg0_type, std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_447::mem_fn)>::arg_type<0>, std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_447::mem_fn)>::arg1_type, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_447::mem_fn)>::arg_type<1>, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_447::mem_fn)>::arg2_type, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_447::mem_fn)>::arg_type<2>, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_447::mem_fn)>::arg_type<3>, const volatile std::string * &&>);
static_assert(callable_traits<decltype(&class_447::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_447::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_447::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_447::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_447::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_447::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_447::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_447::mem_fn)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(&class_447::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_447::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_447::mem_fn)>::class_type, class_447>);
struct class_448 { const void * volatile & mem_fn(std::string * const &&, const std::string * const &&, volatile std::string * const &&, const volatile std::string * const &&) & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_448::mem_fn)>::result_type, const void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_448::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_448::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_448::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_448::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_448::mem_fn)>::arg0_type, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_448::mem_fn)>::arg_type<0>, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_448::mem_fn)>::arg1_type, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_448::mem_fn)>::arg_type<1>, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_448::mem_fn)>::arg2_type, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_448::mem_fn)>::arg_type<2>, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_448::mem_fn)>::arg_type<3>, const volatile std::string * const &&>);
static_assert(callable_traits<decltype(&class_448::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_448::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_448::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_448::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_448::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_448::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_448::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_448::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_448::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_448::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_448::mem_fn)>::class_type, class_448>);
struct class_449 { volatile void * volatile & mem_fn(std::string * volatile &&, const std::string * volatile &&, volatile std::string * volatile &&, const volatile std::string * volatile &&, ...) const & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_449::mem_fn)>::result_type, volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_449::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_449::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_449::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_449::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_449::mem_fn)>::arg0_type, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_449::mem_fn)>::arg_type<0>, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_449::mem_fn)>::arg1_type, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_449::mem_fn)>::arg_type<1>, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_449::mem_fn)>::arg2_type, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_449::mem_fn)>::arg_type<2>, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_449::mem_fn)>::arg_type<3>, const volatile std::string * volatile &&>);
static_assert(callable_traits<decltype(&class_449::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_449::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_449::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_449::mem_fn)>::is_variadic == true);
static_assert(callable_traits<decltype(&class_449::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_449::mem_fn)>::is_const == true);
static_assert(callable_traits<decltype(&class_449::mem_fn)>::is_volatile == false);
static_assert(callable_traits<decltype(&class_449::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_449::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_449::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_449::mem_fn)>::class_type, class_449>);
struct class_450 { const volatile void * volatile & mem_fn(std::string * const volatile &&, const std::string * const volatile &&, volatile std::string * const volatile &&, const volatile std::string * const volatile &&) volatile & noexcept; };
static_assert(std::is_same_v<callable_traits<decltype(&class_450::mem_fn)>::result_type, const volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(&class_450::mem_fn)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(&class_450::mem_fn)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(&class_450::mem_fn)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(&class_450::mem_fn)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(&class_450::mem_fn)>::arg0_type, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_450::mem_fn)>::arg_type<0>, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_450::mem_fn)>::arg1_type, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_450::mem_fn)>::arg_type<1>, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_450::mem_fn)>::arg2_type, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_450::mem_fn)>::arg_type<2>, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(&class_450::mem_fn)>::arg_type<3>, const volatile std::string * const volatile &&>);
static_assert(callable_traits<decltype(&class_450::mem_fn)>::arity == 4);
static_assert(callable_traits<decltype(&class_450::mem_fn)>::is_functor == false);
static_assert(callable_traits<decltype(&class_450::mem_fn)>::is_member_function == true);
static_assert(callable_traits<decltype(&class_450::mem_fn)>::is_variadic == false);
static_assert(callable_traits<decltype(&class_450::mem_fn)>::is_noexcept == true);
static_assert(callable_traits<decltype(&class_450::mem_fn)>::is_const == false);
static_assert(callable_traits<decltype(&class_450::mem_fn)>::is_volatile == true);
static_assert(callable_traits<decltype(&class_450::mem_fn)>::is_lvalue_reference == true);
static_assert(callable_traits<decltype(&class_450::mem_fn)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(&class_450::mem_fn)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(&class_450::mem_fn)>::class_type, class_450>);
[[maybe_unused]] const auto lambda_0 = []() -> void {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_0)>::result_type, void>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_0)>> == false);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_0)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_0)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_0)>> == false);
static_assert(callable_traits<decltype(lambda_0)>::arity == 0);
static_assert(callable_traits<decltype(lambda_0)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_0)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_0)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_0)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_0)>::is_const == true);
static_assert(callable_traits<decltype(lambda_0)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_0)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_0)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_0)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_0)>::class_type, std::remove_const_t<decltype(lambda_0)>>);
[[maybe_unused]] const auto lambda_1 = [](void *, ...) mutable -> void * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_1)>::result_type, void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_1)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_1)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_1)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_1)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_1)>::arg0_type, void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_1)>::arg_type<0>, void *>);
static_assert(callable_traits<decltype(lambda_1)>::arity == 1);
static_assert(callable_traits<decltype(lambda_1)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_1)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_1)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_1)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_1)>::is_const == false);
static_assert(callable_traits<decltype(lambda_1)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_1)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_1)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_1)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_1)>::class_type, std::remove_const_t<decltype(lambda_1)>>);
[[maybe_unused]] const auto lambda_2 = [](const void *) noexcept -> const void * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_2)>::result_type, const void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_2)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_2)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_2)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_2)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_2)>::arg0_type, const void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_2)>::arg_type<0>, const void *>);
static_assert(callable_traits<decltype(lambda_2)>::arity == 1);
static_assert(callable_traits<decltype(lambda_2)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_2)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_2)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_2)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_2)>::is_const == true);
static_assert(callable_traits<decltype(lambda_2)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_2)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_2)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_2)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_2)>::class_type, std::remove_const_t<decltype(lambda_2)>>);
[[maybe_unused]] const auto lambda_3 = [](volatile void *, ...) mutable noexcept -> volatile void * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_3)>::result_type, volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_3)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_3)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_3)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_3)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_3)>::arg0_type, volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_3)>::arg_type<0>, volatile void *>);
static_assert(callable_traits<decltype(lambda_3)>::arity == 1);
static_assert(callable_traits<decltype(lambda_3)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_3)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_3)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_3)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_3)>::is_const == false);
static_assert(callable_traits<decltype(lambda_3)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_3)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_3)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_3)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_3)>::class_type, std::remove_const_t<decltype(lambda_3)>>);
[[maybe_unused]] const auto lambda_4 = [](const volatile void *) -> const volatile void * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_4)>::result_type, const volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_4)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_4)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_4)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_4)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_4)>::arg0_type, const volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_4)>::arg_type<0>, const volatile void *>);
static_assert(callable_traits<decltype(lambda_4)>::arity == 1);
static_assert(callable_traits<decltype(lambda_4)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_4)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_4)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_4)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_4)>::is_const == true);
static_assert(callable_traits<decltype(lambda_4)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_4)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_4)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_4)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_4)>::class_type, std::remove_const_t<decltype(lambda_4)>>);
[[maybe_unused]] const auto lambda_5 = [](void * &, ...) mutable -> void * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_5)>::result_type, void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_5)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_5)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_5)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_5)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_5)>::arg0_type, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_5)>::arg_type<0>, void * &>);
static_assert(callable_traits<decltype(lambda_5)>::arity == 1);
static_assert(callable_traits<decltype(lambda_5)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_5)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_5)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_5)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_5)>::is_const == false);
static_assert(callable_traits<decltype(lambda_5)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_5)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_5)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_5)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_5)>::class_type, std::remove_const_t<decltype(lambda_5)>>);
[[maybe_unused]] const auto lambda_6 = [](const void * &) noexcept -> const void * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_6)>::result_type, const void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_6)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_6)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_6)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_6)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_6)>::arg0_type, const void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_6)>::arg_type<0>, const void * &>);
static_assert(callable_traits<decltype(lambda_6)>::arity == 1);
static_assert(callable_traits<decltype(lambda_6)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_6)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_6)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_6)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_6)>::is_const == true);
static_assert(callable_traits<decltype(lambda_6)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_6)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_6)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_6)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_6)>::class_type, std::remove_const_t<decltype(lambda_6)>>);
[[maybe_unused]] const auto lambda_7 = [](volatile void * &, ...) mutable noexcept -> volatile void * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_7)>::result_type, volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_7)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_7)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_7)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_7)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_7)>::arg0_type, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_7)>::arg_type<0>, volatile void * &>);
static_assert(callable_traits<decltype(lambda_7)>::arity == 1);
static_assert(callable_traits<decltype(lambda_7)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_7)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_7)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_7)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_7)>::is_const == false);
static_assert(callable_traits<decltype(lambda_7)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_7)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_7)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_7)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_7)>::class_type, std::remove_const_t<decltype(lambda_7)>>);
[[maybe_unused]] const auto lambda_8 = [](const volatile void * &) -> const volatile void * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_8)>::result_type, const volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_8)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_8)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_8)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_8)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_8)>::arg0_type, const volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_8)>::arg_type<0>, const volatile void * &>);
static_assert(callable_traits<decltype(lambda_8)>::arity == 1);
static_assert(callable_traits<decltype(lambda_8)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_8)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_8)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_8)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_8)>::is_const == true);
static_assert(callable_traits<decltype(lambda_8)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_8)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_8)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_8)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_8)>::class_type, std::remove_const_t<decltype(lambda_8)>>);
[[maybe_unused]] const auto lambda_9 = [](void * const &, ...) mutable -> void * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_9)>::result_type, void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_9)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_9)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_9)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_9)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_9)>::arg0_type, void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_9)>::arg_type<0>, void * const &>);
static_assert(callable_traits<decltype(lambda_9)>::arity == 1);
static_assert(callable_traits<decltype(lambda_9)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_9)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_9)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_9)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_9)>::is_const == false);
static_assert(callable_traits<decltype(lambda_9)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_9)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_9)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_9)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_9)>::class_type, std::remove_const_t<decltype(lambda_9)>>);
[[maybe_unused]] const auto lambda_10 = [](const void * const &) noexcept -> const void * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_10)>::result_type, const void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_10)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_10)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_10)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_10)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_10)>::arg0_type, const void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_10)>::arg_type<0>, const void * const &>);
static_assert(callable_traits<decltype(lambda_10)>::arity == 1);
static_assert(callable_traits<decltype(lambda_10)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_10)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_10)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_10)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_10)>::is_const == true);
static_assert(callable_traits<decltype(lambda_10)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_10)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_10)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_10)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_10)>::class_type, std::remove_const_t<decltype(lambda_10)>>);
[[maybe_unused]] const auto lambda_11 = [](volatile void * const &, ...) mutable noexcept -> volatile void * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_11)>::result_type, volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_11)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_11)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_11)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_11)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_11)>::arg0_type, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_11)>::arg_type<0>, volatile void * const &>);
static_assert(callable_traits<decltype(lambda_11)>::arity == 1);
static_assert(callable_traits<decltype(lambda_11)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_11)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_11)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_11)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_11)>::is_const == false);
static_assert(callable_traits<decltype(lambda_11)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_11)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_11)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_11)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_11)>::class_type, std::remove_const_t<decltype(lambda_11)>>);
[[maybe_unused]] const auto lambda_12 = [](const volatile void * const &) -> const volatile void * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_12)>::result_type, const volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_12)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_12)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_12)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_12)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_12)>::arg0_type, const volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_12)>::arg_type<0>, const volatile void * const &>);
static_assert(callable_traits<decltype(lambda_12)>::arity == 1);
static_assert(callable_traits<decltype(lambda_12)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_12)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_12)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_12)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_12)>::is_const == true);
static_assert(callable_traits<decltype(lambda_12)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_12)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_12)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_12)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_12)>::class_type, std::remove_const_t<decltype(lambda_12)>>);
[[maybe_unused]] const auto lambda_13 = [](void * volatile &, ...) mutable -> void * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_13)>::result_type, void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_13)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_13)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_13)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_13)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_13)>::arg0_type, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_13)>::arg_type<0>, void * volatile &>);
static_assert(callable_traits<decltype(lambda_13)>::arity == 1);
static_assert(callable_traits<decltype(lambda_13)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_13)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_13)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_13)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_13)>::is_const == false);
static_assert(callable_traits<decltype(lambda_13)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_13)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_13)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_13)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_13)>::class_type, std::remove_const_t<decltype(lambda_13)>>);
[[maybe_unused]] const auto lambda_14 = [](const void * volatile &) noexcept -> const void * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_14)>::result_type, const void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_14)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_14)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_14)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_14)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_14)>::arg0_type, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_14)>::arg_type<0>, const void * volatile &>);
static_assert(callable_traits<decltype(lambda_14)>::arity == 1);
static_assert(callable_traits<decltype(lambda_14)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_14)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_14)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_14)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_14)>::is_const == true);
static_assert(callable_traits<decltype(lambda_14)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_14)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_14)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_14)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_14)>::class_type, std::remove_const_t<decltype(lambda_14)>>);
[[maybe_unused]] const auto lambda_15 = [](volatile void * volatile &, ...) mutable noexcept -> volatile void * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_15)>::result_type, volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_15)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_15)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_15)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_15)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_15)>::arg0_type, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_15)>::arg_type<0>, volatile void * volatile &>);
static_assert(callable_traits<decltype(lambda_15)>::arity == 1);
static_assert(callable_traits<decltype(lambda_15)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_15)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_15)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_15)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_15)>::is_const == false);
static_assert(callable_traits<decltype(lambda_15)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_15)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_15)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_15)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_15)>::class_type, std::remove_const_t<decltype(lambda_15)>>);
[[maybe_unused]] const auto lambda_16 = [](const volatile void * volatile &) -> const volatile void * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_16)>::result_type, const volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_16)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_16)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_16)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_16)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_16)>::arg0_type, const volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_16)>::arg_type<0>, const volatile void * volatile &>);
static_assert(callable_traits<decltype(lambda_16)>::arity == 1);
static_assert(callable_traits<decltype(lambda_16)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_16)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_16)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_16)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_16)>::is_const == true);
static_assert(callable_traits<decltype(lambda_16)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_16)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_16)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_16)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_16)>::class_type, std::remove_const_t<decltype(lambda_16)>>);
[[maybe_unused]] const auto lambda_17 = [](void * const volatile &, ...) mutable -> void * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_17)>::result_type, void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_17)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_17)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_17)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_17)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_17)>::arg0_type, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_17)>::arg_type<0>, void * const volatile &>);
static_assert(callable_traits<decltype(lambda_17)>::arity == 1);
static_assert(callable_traits<decltype(lambda_17)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_17)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_17)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_17)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_17)>::is_const == false);
static_assert(callable_traits<decltype(lambda_17)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_17)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_17)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_17)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_17)>::class_type, std::remove_const_t<decltype(lambda_17)>>);
[[maybe_unused]] const auto lambda_18 = [](const void * const volatile &) noexcept -> const void * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_18)>::result_type, const void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_18)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_18)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_18)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_18)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_18)>::arg0_type, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_18)>::arg_type<0>, const void * const volatile &>);
static_assert(callable_traits<decltype(lambda_18)>::arity == 1);
static_assert(callable_traits<decltype(lambda_18)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_18)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_18)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_18)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_18)>::is_const == true);
static_assert(callable_traits<decltype(lambda_18)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_18)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_18)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_18)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_18)>::class_type, std::remove_const_t<decltype(lambda_18)>>);
[[maybe_unused]] const auto lambda_19 = [](volatile void * const volatile &, ...) mutable noexcept -> volatile void * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_19)>::result_type, volatile void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_19)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_19)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_19)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_19)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_19)>::arg0_type, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_19)>::arg_type<0>, volatile void * const volatile &>);
static_assert(callable_traits<decltype(lambda_19)>::arity == 1);
static_assert(callable_traits<decltype(lambda_19)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_19)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_19)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_19)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_19)>::is_const == false);
static_assert(callable_traits<decltype(lambda_19)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_19)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_19)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_19)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_19)>::class_type, std::remove_const_t<decltype(lambda_19)>>);
[[maybe_unused]] const auto lambda_20 = [](const volatile void * const volatile &) -> const volatile void * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_20)>::result_type, const volatile void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_20)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_20)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_20)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_20)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_20)>::arg0_type, const volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_20)>::arg_type<0>, const volatile void * const volatile &>);
static_assert(callable_traits<decltype(lambda_20)>::arity == 1);
static_assert(callable_traits<decltype(lambda_20)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_20)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_20)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_20)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_20)>::is_const == true);
static_assert(callable_traits<decltype(lambda_20)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_20)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_20)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_20)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_20)>::class_type, std::remove_const_t<decltype(lambda_20)>>);
[[maybe_unused]] const auto lambda_21 = [](void * &&, ...) mutable -> void * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_21)>::result_type, void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_21)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_21)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_21)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_21)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_21)>::arg0_type, void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_21)>::arg_type<0>, void * &&>);
static_assert(callable_traits<decltype(lambda_21)>::arity == 1);
static_assert(callable_traits<decltype(lambda_21)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_21)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_21)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_21)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_21)>::is_const == false);
static_assert(callable_traits<decltype(lambda_21)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_21)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_21)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_21)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_21)>::class_type, std::remove_const_t<decltype(lambda_21)>>);
[[maybe_unused]] const auto lambda_22 = [](const void * &&) noexcept -> const void * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_22)>::result_type, const void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_22)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_22)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_22)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_22)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_22)>::arg0_type, const void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_22)>::arg_type<0>, const void * &&>);
static_assert(callable_traits<decltype(lambda_22)>::arity == 1);
static_assert(callable_traits<decltype(lambda_22)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_22)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_22)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_22)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_22)>::is_const == true);
static_assert(callable_traits<decltype(lambda_22)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_22)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_22)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_22)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_22)>::class_type, std::remove_const_t<decltype(lambda_22)>>);
[[maybe_unused]] const auto lambda_23 = [](volatile void * &&, ...) mutable noexcept -> volatile void * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_23)>::result_type, volatile void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_23)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_23)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_23)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_23)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_23)>::arg0_type, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_23)>::arg_type<0>, volatile void * &&>);
static_assert(callable_traits<decltype(lambda_23)>::arity == 1);
static_assert(callable_traits<decltype(lambda_23)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_23)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_23)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_23)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_23)>::is_const == false);
static_assert(callable_traits<decltype(lambda_23)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_23)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_23)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_23)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_23)>::class_type, std::remove_const_t<decltype(lambda_23)>>);
[[maybe_unused]] const auto lambda_24 = [](const volatile void * &&) -> const volatile void * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_24)>::result_type, const volatile void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_24)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_24)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_24)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_24)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_24)>::arg0_type, const volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_24)>::arg_type<0>, const volatile void * &&>);
static_assert(callable_traits<decltype(lambda_24)>::arity == 1);
static_assert(callable_traits<decltype(lambda_24)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_24)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_24)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_24)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_24)>::is_const == true);
static_assert(callable_traits<decltype(lambda_24)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_24)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_24)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_24)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_24)>::class_type, std::remove_const_t<decltype(lambda_24)>>);
[[maybe_unused]] const auto lambda_25 = [](void * const &&, ...) mutable -> void * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_25)>::result_type, void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_25)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_25)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_25)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_25)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_25)>::arg0_type, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_25)>::arg_type<0>, void * const &&>);
static_assert(callable_traits<decltype(lambda_25)>::arity == 1);
static_assert(callable_traits<decltype(lambda_25)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_25)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_25)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_25)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_25)>::is_const == false);
static_assert(callable_traits<decltype(lambda_25)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_25)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_25)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_25)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_25)>::class_type, std::remove_const_t<decltype(lambda_25)>>);
[[maybe_unused]] const auto lambda_26 = [](const void * const &&) noexcept -> const void * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_26)>::result_type, const void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_26)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_26)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_26)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_26)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_26)>::arg0_type, const void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_26)>::arg_type<0>, const void * const &&>);
static_assert(callable_traits<decltype(lambda_26)>::arity == 1);
static_assert(callable_traits<decltype(lambda_26)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_26)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_26)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_26)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_26)>::is_const == true);
static_assert(callable_traits<decltype(lambda_26)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_26)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_26)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_26)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_26)>::class_type, std::remove_const_t<decltype(lambda_26)>>);
[[maybe_unused]] const auto lambda_27 = [](volatile void * const &&, ...) mutable noexcept -> volatile void * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_27)>::result_type, volatile void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_27)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_27)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_27)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_27)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_27)>::arg0_type, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_27)>::arg_type<0>, volatile void * const &&>);
static_assert(callable_traits<decltype(lambda_27)>::arity == 1);
static_assert(callable_traits<decltype(lambda_27)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_27)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_27)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_27)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_27)>::is_const == false);
static_assert(callable_traits<decltype(lambda_27)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_27)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_27)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_27)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_27)>::class_type, std::remove_const_t<decltype(lambda_27)>>);
[[maybe_unused]] const auto lambda_28 = [](const volatile void * const &&) -> const volatile void * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_28)>::result_type, const volatile void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_28)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_28)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_28)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_28)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_28)>::arg0_type, const volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_28)>::arg_type<0>, const volatile void * const &&>);
static_assert(callable_traits<decltype(lambda_28)>::arity == 1);
static_assert(callable_traits<decltype(lambda_28)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_28)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_28)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_28)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_28)>::is_const == true);
static_assert(callable_traits<decltype(lambda_28)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_28)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_28)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_28)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_28)>::class_type, std::remove_const_t<decltype(lambda_28)>>);
[[maybe_unused]] const auto lambda_29 = [](void * volatile &&, ...) mutable -> void * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_29)>::result_type, void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_29)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_29)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_29)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_29)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_29)>::arg0_type, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_29)>::arg_type<0>, void * volatile &&>);
static_assert(callable_traits<decltype(lambda_29)>::arity == 1);
static_assert(callable_traits<decltype(lambda_29)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_29)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_29)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_29)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_29)>::is_const == false);
static_assert(callable_traits<decltype(lambda_29)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_29)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_29)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_29)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_29)>::class_type, std::remove_const_t<decltype(lambda_29)>>);
[[maybe_unused]] const auto lambda_30 = [](const void * volatile &&) noexcept -> const void * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_30)>::result_type, const void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_30)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_30)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_30)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_30)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_30)>::arg0_type, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_30)>::arg_type<0>, const void * volatile &&>);
static_assert(callable_traits<decltype(lambda_30)>::arity == 1);
static_assert(callable_traits<decltype(lambda_30)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_30)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_30)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_30)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_30)>::is_const == true);
static_assert(callable_traits<decltype(lambda_30)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_30)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_30)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_30)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_30)>::class_type, std::remove_const_t<decltype(lambda_30)>>);
[[maybe_unused]] const auto lambda_31 = [](volatile void * volatile &&, ...) mutable noexcept -> volatile void * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_31)>::result_type, volatile void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_31)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_31)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_31)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_31)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_31)>::arg0_type, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_31)>::arg_type<0>, volatile void * volatile &&>);
static_assert(callable_traits<decltype(lambda_31)>::arity == 1);
static_assert(callable_traits<decltype(lambda_31)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_31)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_31)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_31)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_31)>::is_const == false);
static_assert(callable_traits<decltype(lambda_31)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_31)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_31)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_31)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_31)>::class_type, std::remove_const_t<decltype(lambda_31)>>);
[[maybe_unused]] const auto lambda_32 = [](const volatile void * volatile &&) -> const volatile void * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_32)>::result_type, const volatile void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_32)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_32)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_32)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_32)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_32)>::arg0_type, const volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_32)>::arg_type<0>, const volatile void * volatile &&>);
static_assert(callable_traits<decltype(lambda_32)>::arity == 1);
static_assert(callable_traits<decltype(lambda_32)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_32)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_32)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_32)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_32)>::is_const == true);
static_assert(callable_traits<decltype(lambda_32)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_32)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_32)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_32)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_32)>::class_type, std::remove_const_t<decltype(lambda_32)>>);
[[maybe_unused]] const auto lambda_33 = [](void * const volatile &&, ...) mutable -> void * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_33)>::result_type, void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_33)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_33)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_33)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_33)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_33)>::arg0_type, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_33)>::arg_type<0>, void * const volatile &&>);
static_assert(callable_traits<decltype(lambda_33)>::arity == 1);
static_assert(callable_traits<decltype(lambda_33)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_33)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_33)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_33)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_33)>::is_const == false);
static_assert(callable_traits<decltype(lambda_33)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_33)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_33)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_33)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_33)>::class_type, std::remove_const_t<decltype(lambda_33)>>);
[[maybe_unused]] const auto lambda_34 = [](const void * const volatile &&) noexcept -> const void * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_34)>::result_type, const void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_34)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_34)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_34)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_34)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_34)>::arg0_type, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_34)>::arg_type<0>, const void * const volatile &&>);
static_assert(callable_traits<decltype(lambda_34)>::arity == 1);
static_assert(callable_traits<decltype(lambda_34)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_34)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_34)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_34)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_34)>::is_const == true);
static_assert(callable_traits<decltype(lambda_34)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_34)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_34)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_34)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_34)>::class_type, std::remove_const_t<decltype(lambda_34)>>);
[[maybe_unused]] const auto lambda_35 = [](volatile void * const volatile &&, ...) mutable noexcept -> volatile void * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_35)>::result_type, volatile void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_35)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_35)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_35)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_35)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_35)>::arg0_type, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_35)>::arg_type<0>, volatile void * const volatile &&>);
static_assert(callable_traits<decltype(lambda_35)>::arity == 1);
static_assert(callable_traits<decltype(lambda_35)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_35)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_35)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_35)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_35)>::is_const == false);
static_assert(callable_traits<decltype(lambda_35)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_35)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_35)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_35)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_35)>::class_type, std::remove_const_t<decltype(lambda_35)>>);
[[maybe_unused]] const auto lambda_36 = [](const volatile void * const volatile &&) -> const volatile void * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_36)>::result_type, const volatile void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_36)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_36)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_36)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_36)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_36)>::arg0_type, const volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_36)>::arg_type<0>, const volatile void * const volatile &&>);
static_assert(callable_traits<decltype(lambda_36)>::arity == 1);
static_assert(callable_traits<decltype(lambda_36)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_36)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_36)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_36)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_36)>::is_const == true);
static_assert(callable_traits<decltype(lambda_36)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_36)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_36)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_36)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_36)>::class_type, std::remove_const_t<decltype(lambda_36)>>);
[[maybe_unused]] const auto lambda_37 = [](bool, ...) mutable -> bool {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_37)>::result_type, bool>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_37)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_37)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_37)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_37)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_37)>::arg0_type, bool>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_37)>::arg_type<0>, bool>);
static_assert(callable_traits<decltype(lambda_37)>::arity == 1);
static_assert(callable_traits<decltype(lambda_37)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_37)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_37)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_37)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_37)>::is_const == false);
static_assert(callable_traits<decltype(lambda_37)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_37)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_37)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_37)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_37)>::class_type, std::remove_const_t<decltype(lambda_37)>>);
[[maybe_unused]] const auto lambda_38 = [](bool *) noexcept -> bool * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_38)>::result_type, bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_38)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_38)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_38)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_38)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_38)>::arg0_type, bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_38)>::arg_type<0>, bool *>);
static_assert(callable_traits<decltype(lambda_38)>::arity == 1);
static_assert(callable_traits<decltype(lambda_38)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_38)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_38)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_38)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_38)>::is_const == true);
static_assert(callable_traits<decltype(lambda_38)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_38)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_38)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_38)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_38)>::class_type, std::remove_const_t<decltype(lambda_38)>>);
[[maybe_unused]] const auto lambda_39 = [](const bool *, ...) mutable noexcept -> const bool * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_39)>::result_type, const bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_39)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_39)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_39)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_39)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_39)>::arg0_type, const bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_39)>::arg_type<0>, const bool *>);
static_assert(callable_traits<decltype(lambda_39)>::arity == 1);
static_assert(callable_traits<decltype(lambda_39)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_39)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_39)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_39)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_39)>::is_const == false);
static_assert(callable_traits<decltype(lambda_39)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_39)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_39)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_39)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_39)>::class_type, std::remove_const_t<decltype(lambda_39)>>);
[[maybe_unused]] const auto lambda_40 = [](volatile bool *) -> volatile bool * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_40)>::result_type, volatile bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_40)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_40)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_40)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_40)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_40)>::arg0_type, volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_40)>::arg_type<0>, volatile bool *>);
static_assert(callable_traits<decltype(lambda_40)>::arity == 1);
static_assert(callable_traits<decltype(lambda_40)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_40)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_40)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_40)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_40)>::is_const == true);
static_assert(callable_traits<decltype(lambda_40)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_40)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_40)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_40)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_40)>::class_type, std::remove_const_t<decltype(lambda_40)>>);
[[maybe_unused]] const auto lambda_41 = [](const volatile bool *, ...) mutable -> const volatile bool * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_41)>::result_type, const volatile bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_41)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_41)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_41)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_41)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_41)>::arg0_type, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_41)>::arg_type<0>, const volatile bool *>);
static_assert(callable_traits<decltype(lambda_41)>::arity == 1);
static_assert(callable_traits<decltype(lambda_41)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_41)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_41)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_41)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_41)>::is_const == false);
static_assert(callable_traits<decltype(lambda_41)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_41)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_41)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_41)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_41)>::class_type, std::remove_const_t<decltype(lambda_41)>>);
[[maybe_unused]] const auto lambda_42 = [](bool &) noexcept -> bool & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_42)>::result_type, bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_42)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_42)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_42)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_42)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_42)>::arg0_type, bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_42)>::arg_type<0>, bool &>);
static_assert(callable_traits<decltype(lambda_42)>::arity == 1);
static_assert(callable_traits<decltype(lambda_42)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_42)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_42)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_42)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_42)>::is_const == true);
static_assert(callable_traits<decltype(lambda_42)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_42)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_42)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_42)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_42)>::class_type, std::remove_const_t<decltype(lambda_42)>>);
[[maybe_unused]] const auto lambda_43 = [](const bool &, ...) mutable noexcept -> const bool & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_43)>::result_type, const bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_43)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_43)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_43)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_43)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_43)>::arg0_type, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_43)>::arg_type<0>, const bool &>);
static_assert(callable_traits<decltype(lambda_43)>::arity == 1);
static_assert(callable_traits<decltype(lambda_43)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_43)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_43)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_43)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_43)>::is_const == false);
static_assert(callable_traits<decltype(lambda_43)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_43)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_43)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_43)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_43)>::class_type, std::remove_const_t<decltype(lambda_43)>>);
[[maybe_unused]] const auto lambda_44 = [](volatile bool &) -> volatile bool & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_44)>::result_type, volatile bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_44)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_44)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_44)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_44)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_44)>::arg0_type, volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_44)>::arg_type<0>, volatile bool &>);
static_assert(callable_traits<decltype(lambda_44)>::arity == 1);
static_assert(callable_traits<decltype(lambda_44)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_44)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_44)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_44)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_44)>::is_const == true);
static_assert(callable_traits<decltype(lambda_44)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_44)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_44)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_44)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_44)>::class_type, std::remove_const_t<decltype(lambda_44)>>);
[[maybe_unused]] const auto lambda_45 = [](const volatile bool &, ...) mutable -> const volatile bool & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_45)>::result_type, const volatile bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_45)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_45)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_45)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_45)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_45)>::arg0_type, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_45)>::arg_type<0>, const volatile bool &>);
static_assert(callable_traits<decltype(lambda_45)>::arity == 1);
static_assert(callable_traits<decltype(lambda_45)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_45)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_45)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_45)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_45)>::is_const == false);
static_assert(callable_traits<decltype(lambda_45)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_45)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_45)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_45)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_45)>::class_type, std::remove_const_t<decltype(lambda_45)>>);
[[maybe_unused]] const auto lambda_46 = [](bool * &) noexcept -> bool * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_46)>::result_type, bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_46)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_46)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_46)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_46)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_46)>::arg0_type, bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_46)>::arg_type<0>, bool * &>);
static_assert(callable_traits<decltype(lambda_46)>::arity == 1);
static_assert(callable_traits<decltype(lambda_46)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_46)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_46)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_46)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_46)>::is_const == true);
static_assert(callable_traits<decltype(lambda_46)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_46)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_46)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_46)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_46)>::class_type, std::remove_const_t<decltype(lambda_46)>>);
[[maybe_unused]] const auto lambda_47 = [](const bool * &, ...) mutable noexcept -> const bool * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_47)>::result_type, const bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_47)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_47)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_47)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_47)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_47)>::arg0_type, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_47)>::arg_type<0>, const bool * &>);
static_assert(callable_traits<decltype(lambda_47)>::arity == 1);
static_assert(callable_traits<decltype(lambda_47)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_47)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_47)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_47)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_47)>::is_const == false);
static_assert(callable_traits<decltype(lambda_47)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_47)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_47)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_47)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_47)>::class_type, std::remove_const_t<decltype(lambda_47)>>);
[[maybe_unused]] const auto lambda_48 = [](volatile bool * &) -> volatile bool * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_48)>::result_type, volatile bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_48)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_48)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_48)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_48)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_48)>::arg0_type, volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_48)>::arg_type<0>, volatile bool * &>);
static_assert(callable_traits<decltype(lambda_48)>::arity == 1);
static_assert(callable_traits<decltype(lambda_48)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_48)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_48)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_48)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_48)>::is_const == true);
static_assert(callable_traits<decltype(lambda_48)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_48)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_48)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_48)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_48)>::class_type, std::remove_const_t<decltype(lambda_48)>>);
[[maybe_unused]] const auto lambda_49 = [](const volatile bool * &, ...) mutable -> const volatile bool * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_49)>::result_type, const volatile bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_49)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_49)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_49)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_49)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_49)>::arg0_type, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_49)>::arg_type<0>, const volatile bool * &>);
static_assert(callable_traits<decltype(lambda_49)>::arity == 1);
static_assert(callable_traits<decltype(lambda_49)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_49)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_49)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_49)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_49)>::is_const == false);
static_assert(callable_traits<decltype(lambda_49)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_49)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_49)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_49)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_49)>::class_type, std::remove_const_t<decltype(lambda_49)>>);
[[maybe_unused]] const auto lambda_50 = [](bool * const &) noexcept -> bool * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_50)>::result_type, bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_50)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_50)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_50)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_50)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_50)>::arg0_type, bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_50)>::arg_type<0>, bool * const &>);
static_assert(callable_traits<decltype(lambda_50)>::arity == 1);
static_assert(callable_traits<decltype(lambda_50)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_50)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_50)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_50)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_50)>::is_const == true);
static_assert(callable_traits<decltype(lambda_50)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_50)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_50)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_50)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_50)>::class_type, std::remove_const_t<decltype(lambda_50)>>);
[[maybe_unused]] const auto lambda_51 = [](const bool * const &, ...) mutable noexcept -> const bool * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_51)>::result_type, const bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_51)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_51)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_51)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_51)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_51)>::arg0_type, const bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_51)>::arg_type<0>, const bool * const &>);
static_assert(callable_traits<decltype(lambda_51)>::arity == 1);
static_assert(callable_traits<decltype(lambda_51)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_51)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_51)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_51)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_51)>::is_const == false);
static_assert(callable_traits<decltype(lambda_51)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_51)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_51)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_51)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_51)>::class_type, std::remove_const_t<decltype(lambda_51)>>);
[[maybe_unused]] const auto lambda_52 = [](volatile bool * const &) -> volatile bool * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_52)>::result_type, volatile bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_52)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_52)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_52)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_52)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_52)>::arg0_type, volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_52)>::arg_type<0>, volatile bool * const &>);
static_assert(callable_traits<decltype(lambda_52)>::arity == 1);
static_assert(callable_traits<decltype(lambda_52)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_52)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_52)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_52)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_52)>::is_const == true);
static_assert(callable_traits<decltype(lambda_52)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_52)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_52)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_52)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_52)>::class_type, std::remove_const_t<decltype(lambda_52)>>);
[[maybe_unused]] const auto lambda_53 = [](const volatile bool * const &, ...) mutable -> const volatile bool * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_53)>::result_type, const volatile bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_53)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_53)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_53)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_53)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_53)>::arg0_type, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_53)>::arg_type<0>, const volatile bool * const &>);
static_assert(callable_traits<decltype(lambda_53)>::arity == 1);
static_assert(callable_traits<decltype(lambda_53)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_53)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_53)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_53)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_53)>::is_const == false);
static_assert(callable_traits<decltype(lambda_53)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_53)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_53)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_53)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_53)>::class_type, std::remove_const_t<decltype(lambda_53)>>);
[[maybe_unused]] const auto lambda_54 = [](bool * volatile &) noexcept -> bool * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_54)>::result_type, bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_54)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_54)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_54)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_54)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_54)>::arg0_type, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_54)>::arg_type<0>, bool * volatile &>);
static_assert(callable_traits<decltype(lambda_54)>::arity == 1);
static_assert(callable_traits<decltype(lambda_54)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_54)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_54)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_54)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_54)>::is_const == true);
static_assert(callable_traits<decltype(lambda_54)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_54)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_54)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_54)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_54)>::class_type, std::remove_const_t<decltype(lambda_54)>>);
[[maybe_unused]] const auto lambda_55 = [](const bool * volatile &, ...) mutable noexcept -> const bool * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_55)>::result_type, const bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_55)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_55)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_55)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_55)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_55)>::arg0_type, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_55)>::arg_type<0>, const bool * volatile &>);
static_assert(callable_traits<decltype(lambda_55)>::arity == 1);
static_assert(callable_traits<decltype(lambda_55)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_55)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_55)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_55)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_55)>::is_const == false);
static_assert(callable_traits<decltype(lambda_55)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_55)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_55)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_55)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_55)>::class_type, std::remove_const_t<decltype(lambda_55)>>);
[[maybe_unused]] const auto lambda_56 = [](volatile bool * volatile &) -> volatile bool * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_56)>::result_type, volatile bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_56)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_56)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_56)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_56)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_56)>::arg0_type, volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_56)>::arg_type<0>, volatile bool * volatile &>);
static_assert(callable_traits<decltype(lambda_56)>::arity == 1);
static_assert(callable_traits<decltype(lambda_56)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_56)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_56)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_56)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_56)>::is_const == true);
static_assert(callable_traits<decltype(lambda_56)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_56)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_56)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_56)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_56)>::class_type, std::remove_const_t<decltype(lambda_56)>>);
[[maybe_unused]] const auto lambda_57 = [](const volatile bool * volatile &, ...) mutable -> const volatile bool * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_57)>::result_type, const volatile bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_57)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_57)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_57)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_57)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_57)>::arg0_type, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_57)>::arg_type<0>, const volatile bool * volatile &>);
static_assert(callable_traits<decltype(lambda_57)>::arity == 1);
static_assert(callable_traits<decltype(lambda_57)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_57)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_57)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_57)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_57)>::is_const == false);
static_assert(callable_traits<decltype(lambda_57)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_57)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_57)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_57)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_57)>::class_type, std::remove_const_t<decltype(lambda_57)>>);
[[maybe_unused]] const auto lambda_58 = [](bool * const volatile &) noexcept -> bool * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_58)>::result_type, bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_58)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_58)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_58)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_58)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_58)>::arg0_type, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_58)>::arg_type<0>, bool * const volatile &>);
static_assert(callable_traits<decltype(lambda_58)>::arity == 1);
static_assert(callable_traits<decltype(lambda_58)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_58)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_58)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_58)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_58)>::is_const == true);
static_assert(callable_traits<decltype(lambda_58)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_58)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_58)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_58)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_58)>::class_type, std::remove_const_t<decltype(lambda_58)>>);
[[maybe_unused]] const auto lambda_59 = [](const bool * const volatile &, ...) mutable noexcept -> const bool * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_59)>::result_type, const bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_59)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_59)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_59)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_59)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_59)>::arg0_type, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_59)>::arg_type<0>, const bool * const volatile &>);
static_assert(callable_traits<decltype(lambda_59)>::arity == 1);
static_assert(callable_traits<decltype(lambda_59)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_59)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_59)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_59)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_59)>::is_const == false);
static_assert(callable_traits<decltype(lambda_59)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_59)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_59)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_59)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_59)>::class_type, std::remove_const_t<decltype(lambda_59)>>);
[[maybe_unused]] const auto lambda_60 = [](volatile bool * const volatile &) -> volatile bool * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_60)>::result_type, volatile bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_60)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_60)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_60)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_60)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_60)>::arg0_type, volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_60)>::arg_type<0>, volatile bool * const volatile &>);
static_assert(callable_traits<decltype(lambda_60)>::arity == 1);
static_assert(callable_traits<decltype(lambda_60)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_60)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_60)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_60)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_60)>::is_const == true);
static_assert(callable_traits<decltype(lambda_60)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_60)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_60)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_60)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_60)>::class_type, std::remove_const_t<decltype(lambda_60)>>);
[[maybe_unused]] const auto lambda_61 = [](const volatile bool * const volatile &, ...) mutable -> const volatile bool * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_61)>::result_type, const volatile bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_61)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_61)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_61)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_61)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_61)>::arg0_type, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_61)>::arg_type<0>, const volatile bool * const volatile &>);
static_assert(callable_traits<decltype(lambda_61)>::arity == 1);
static_assert(callable_traits<decltype(lambda_61)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_61)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_61)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_61)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_61)>::is_const == false);
static_assert(callable_traits<decltype(lambda_61)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_61)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_61)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_61)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_61)>::class_type, std::remove_const_t<decltype(lambda_61)>>);
[[maybe_unused]] const auto lambda_62 = [](bool &&) noexcept -> bool && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_62)>::result_type, bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_62)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_62)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_62)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_62)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_62)>::arg0_type, bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_62)>::arg_type<0>, bool &&>);
static_assert(callable_traits<decltype(lambda_62)>::arity == 1);
static_assert(callable_traits<decltype(lambda_62)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_62)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_62)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_62)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_62)>::is_const == true);
static_assert(callable_traits<decltype(lambda_62)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_62)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_62)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_62)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_62)>::class_type, std::remove_const_t<decltype(lambda_62)>>);
[[maybe_unused]] const auto lambda_63 = [](const bool &&, ...) mutable noexcept -> const bool && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_63)>::result_type, const bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_63)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_63)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_63)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_63)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_63)>::arg0_type, const bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_63)>::arg_type<0>, const bool &&>);
static_assert(callable_traits<decltype(lambda_63)>::arity == 1);
static_assert(callable_traits<decltype(lambda_63)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_63)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_63)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_63)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_63)>::is_const == false);
static_assert(callable_traits<decltype(lambda_63)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_63)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_63)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_63)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_63)>::class_type, std::remove_const_t<decltype(lambda_63)>>);
[[maybe_unused]] const auto lambda_64 = [](volatile bool &&) -> volatile bool && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_64)>::result_type, volatile bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_64)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_64)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_64)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_64)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_64)>::arg0_type, volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_64)>::arg_type<0>, volatile bool &&>);
static_assert(callable_traits<decltype(lambda_64)>::arity == 1);
static_assert(callable_traits<decltype(lambda_64)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_64)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_64)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_64)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_64)>::is_const == true);
static_assert(callable_traits<decltype(lambda_64)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_64)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_64)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_64)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_64)>::class_type, std::remove_const_t<decltype(lambda_64)>>);
[[maybe_unused]] const auto lambda_65 = [](const volatile bool &&, ...) mutable -> const volatile bool && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_65)>::result_type, const volatile bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_65)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_65)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_65)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_65)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_65)>::arg0_type, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_65)>::arg_type<0>, const volatile bool &&>);
static_assert(callable_traits<decltype(lambda_65)>::arity == 1);
static_assert(callable_traits<decltype(lambda_65)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_65)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_65)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_65)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_65)>::is_const == false);
static_assert(callable_traits<decltype(lambda_65)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_65)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_65)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_65)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_65)>::class_type, std::remove_const_t<decltype(lambda_65)>>);
[[maybe_unused]] const auto lambda_66 = [](bool * &&) noexcept -> bool * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_66)>::result_type, bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_66)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_66)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_66)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_66)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_66)>::arg0_type, bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_66)>::arg_type<0>, bool * &&>);
static_assert(callable_traits<decltype(lambda_66)>::arity == 1);
static_assert(callable_traits<decltype(lambda_66)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_66)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_66)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_66)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_66)>::is_const == true);
static_assert(callable_traits<decltype(lambda_66)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_66)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_66)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_66)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_66)>::class_type, std::remove_const_t<decltype(lambda_66)>>);
[[maybe_unused]] const auto lambda_67 = [](const bool * &&, ...) mutable noexcept -> const bool * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_67)>::result_type, const bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_67)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_67)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_67)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_67)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_67)>::arg0_type, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_67)>::arg_type<0>, const bool * &&>);
static_assert(callable_traits<decltype(lambda_67)>::arity == 1);
static_assert(callable_traits<decltype(lambda_67)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_67)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_67)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_67)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_67)>::is_const == false);
static_assert(callable_traits<decltype(lambda_67)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_67)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_67)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_67)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_67)>::class_type, std::remove_const_t<decltype(lambda_67)>>);
[[maybe_unused]] const auto lambda_68 = [](volatile bool * &&) -> volatile bool * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_68)>::result_type, volatile bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_68)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_68)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_68)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_68)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_68)>::arg0_type, volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_68)>::arg_type<0>, volatile bool * &&>);
static_assert(callable_traits<decltype(lambda_68)>::arity == 1);
static_assert(callable_traits<decltype(lambda_68)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_68)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_68)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_68)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_68)>::is_const == true);
static_assert(callable_traits<decltype(lambda_68)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_68)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_68)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_68)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_68)>::class_type, std::remove_const_t<decltype(lambda_68)>>);
[[maybe_unused]] const auto lambda_69 = [](const volatile bool * &&, ...) mutable -> const volatile bool * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_69)>::result_type, const volatile bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_69)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_69)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_69)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_69)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_69)>::arg0_type, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_69)>::arg_type<0>, const volatile bool * &&>);
static_assert(callable_traits<decltype(lambda_69)>::arity == 1);
static_assert(callable_traits<decltype(lambda_69)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_69)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_69)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_69)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_69)>::is_const == false);
static_assert(callable_traits<decltype(lambda_69)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_69)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_69)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_69)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_69)>::class_type, std::remove_const_t<decltype(lambda_69)>>);
[[maybe_unused]] const auto lambda_70 = [](bool * const &&) noexcept -> bool * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_70)>::result_type, bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_70)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_70)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_70)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_70)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_70)>::arg0_type, bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_70)>::arg_type<0>, bool * const &&>);
static_assert(callable_traits<decltype(lambda_70)>::arity == 1);
static_assert(callable_traits<decltype(lambda_70)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_70)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_70)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_70)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_70)>::is_const == true);
static_assert(callable_traits<decltype(lambda_70)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_70)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_70)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_70)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_70)>::class_type, std::remove_const_t<decltype(lambda_70)>>);
[[maybe_unused]] const auto lambda_71 = [](const bool * const &&, ...) mutable noexcept -> const bool * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_71)>::result_type, const bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_71)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_71)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_71)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_71)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_71)>::arg0_type, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_71)>::arg_type<0>, const bool * const &&>);
static_assert(callable_traits<decltype(lambda_71)>::arity == 1);
static_assert(callable_traits<decltype(lambda_71)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_71)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_71)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_71)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_71)>::is_const == false);
static_assert(callable_traits<decltype(lambda_71)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_71)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_71)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_71)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_71)>::class_type, std::remove_const_t<decltype(lambda_71)>>);
[[maybe_unused]] const auto lambda_72 = [](volatile bool * const &&) -> volatile bool * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_72)>::result_type, volatile bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_72)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_72)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_72)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_72)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_72)>::arg0_type, volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_72)>::arg_type<0>, volatile bool * const &&>);
static_assert(callable_traits<decltype(lambda_72)>::arity == 1);
static_assert(callable_traits<decltype(lambda_72)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_72)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_72)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_72)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_72)>::is_const == true);
static_assert(callable_traits<decltype(lambda_72)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_72)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_72)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_72)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_72)>::class_type, std::remove_const_t<decltype(lambda_72)>>);
[[maybe_unused]] const auto lambda_73 = [](const volatile bool * const &&, ...) mutable -> const volatile bool * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_73)>::result_type, const volatile bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_73)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_73)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_73)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_73)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_73)>::arg0_type, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_73)>::arg_type<0>, const volatile bool * const &&>);
static_assert(callable_traits<decltype(lambda_73)>::arity == 1);
static_assert(callable_traits<decltype(lambda_73)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_73)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_73)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_73)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_73)>::is_const == false);
static_assert(callable_traits<decltype(lambda_73)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_73)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_73)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_73)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_73)>::class_type, std::remove_const_t<decltype(lambda_73)>>);
[[maybe_unused]] const auto lambda_74 = [](bool * volatile &&) noexcept -> bool * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_74)>::result_type, bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_74)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_74)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_74)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_74)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_74)>::arg0_type, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_74)>::arg_type<0>, bool * volatile &&>);
static_assert(callable_traits<decltype(lambda_74)>::arity == 1);
static_assert(callable_traits<decltype(lambda_74)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_74)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_74)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_74)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_74)>::is_const == true);
static_assert(callable_traits<decltype(lambda_74)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_74)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_74)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_74)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_74)>::class_type, std::remove_const_t<decltype(lambda_74)>>);
[[maybe_unused]] const auto lambda_75 = [](const bool * volatile &&, ...) mutable noexcept -> const bool * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_75)>::result_type, const bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_75)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_75)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_75)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_75)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_75)>::arg0_type, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_75)>::arg_type<0>, const bool * volatile &&>);
static_assert(callable_traits<decltype(lambda_75)>::arity == 1);
static_assert(callable_traits<decltype(lambda_75)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_75)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_75)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_75)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_75)>::is_const == false);
static_assert(callable_traits<decltype(lambda_75)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_75)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_75)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_75)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_75)>::class_type, std::remove_const_t<decltype(lambda_75)>>);
[[maybe_unused]] const auto lambda_76 = [](volatile bool * volatile &&) -> volatile bool * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_76)>::result_type, volatile bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_76)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_76)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_76)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_76)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_76)>::arg0_type, volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_76)>::arg_type<0>, volatile bool * volatile &&>);
static_assert(callable_traits<decltype(lambda_76)>::arity == 1);
static_assert(callable_traits<decltype(lambda_76)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_76)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_76)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_76)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_76)>::is_const == true);
static_assert(callable_traits<decltype(lambda_76)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_76)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_76)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_76)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_76)>::class_type, std::remove_const_t<decltype(lambda_76)>>);
[[maybe_unused]] const auto lambda_77 = [](const volatile bool * volatile &&, ...) mutable -> const volatile bool * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_77)>::result_type, const volatile bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_77)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_77)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_77)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_77)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_77)>::arg0_type, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_77)>::arg_type<0>, const volatile bool * volatile &&>);
static_assert(callable_traits<decltype(lambda_77)>::arity == 1);
static_assert(callable_traits<decltype(lambda_77)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_77)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_77)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_77)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_77)>::is_const == false);
static_assert(callable_traits<decltype(lambda_77)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_77)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_77)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_77)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_77)>::class_type, std::remove_const_t<decltype(lambda_77)>>);
[[maybe_unused]] const auto lambda_78 = [](bool * const volatile &&) noexcept -> bool * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_78)>::result_type, bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_78)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_78)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_78)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_78)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_78)>::arg0_type, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_78)>::arg_type<0>, bool * const volatile &&>);
static_assert(callable_traits<decltype(lambda_78)>::arity == 1);
static_assert(callable_traits<decltype(lambda_78)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_78)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_78)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_78)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_78)>::is_const == true);
static_assert(callable_traits<decltype(lambda_78)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_78)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_78)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_78)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_78)>::class_type, std::remove_const_t<decltype(lambda_78)>>);
[[maybe_unused]] const auto lambda_79 = [](const bool * const volatile &&, ...) mutable noexcept -> const bool * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_79)>::result_type, const bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_79)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_79)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_79)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_79)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_79)>::arg0_type, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_79)>::arg_type<0>, const bool * const volatile &&>);
static_assert(callable_traits<decltype(lambda_79)>::arity == 1);
static_assert(callable_traits<decltype(lambda_79)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_79)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_79)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_79)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_79)>::is_const == false);
static_assert(callable_traits<decltype(lambda_79)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_79)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_79)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_79)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_79)>::class_type, std::remove_const_t<decltype(lambda_79)>>);
[[maybe_unused]] const auto lambda_80 = [](volatile bool * const volatile &&) -> volatile bool * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_80)>::result_type, volatile bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_80)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_80)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_80)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_80)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_80)>::arg0_type, volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_80)>::arg_type<0>, volatile bool * const volatile &&>);
static_assert(callable_traits<decltype(lambda_80)>::arity == 1);
static_assert(callable_traits<decltype(lambda_80)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_80)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_80)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_80)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_80)>::is_const == true);
static_assert(callable_traits<decltype(lambda_80)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_80)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_80)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_80)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_80)>::class_type, std::remove_const_t<decltype(lambda_80)>>);
[[maybe_unused]] const auto lambda_81 = [](const volatile bool * const volatile &&, ...) mutable -> const volatile bool * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_81)>::result_type, const volatile bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_81)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_81)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_81)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_81)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_81)>::arg0_type, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_81)>::arg_type<0>, const volatile bool * const volatile &&>);
static_assert(callable_traits<decltype(lambda_81)>::arity == 1);
static_assert(callable_traits<decltype(lambda_81)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_81)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_81)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_81)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_81)>::is_const == false);
static_assert(callable_traits<decltype(lambda_81)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_81)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_81)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_81)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_81)>::class_type, std::remove_const_t<decltype(lambda_81)>>);
[[maybe_unused]] const auto lambda_82 = [](int) noexcept -> int {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_82)>::result_type, int>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_82)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_82)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_82)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_82)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_82)>::arg0_type, int>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_82)>::arg_type<0>, int>);
static_assert(callable_traits<decltype(lambda_82)>::arity == 1);
static_assert(callable_traits<decltype(lambda_82)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_82)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_82)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_82)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_82)>::is_const == true);
static_assert(callable_traits<decltype(lambda_82)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_82)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_82)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_82)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_82)>::class_type, std::remove_const_t<decltype(lambda_82)>>);
[[maybe_unused]] const auto lambda_83 = [](int *, ...) mutable noexcept -> int * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_83)>::result_type, int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_83)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_83)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_83)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_83)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_83)>::arg0_type, int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_83)>::arg_type<0>, int *>);
static_assert(callable_traits<decltype(lambda_83)>::arity == 1);
static_assert(callable_traits<decltype(lambda_83)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_83)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_83)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_83)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_83)>::is_const == false);
static_assert(callable_traits<decltype(lambda_83)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_83)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_83)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_83)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_83)>::class_type, std::remove_const_t<decltype(lambda_83)>>);
[[maybe_unused]] const auto lambda_84 = [](const int *) -> const int * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_84)>::result_type, const int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_84)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_84)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_84)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_84)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_84)>::arg0_type, const int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_84)>::arg_type<0>, const int *>);
static_assert(callable_traits<decltype(lambda_84)>::arity == 1);
static_assert(callable_traits<decltype(lambda_84)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_84)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_84)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_84)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_84)>::is_const == true);
static_assert(callable_traits<decltype(lambda_84)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_84)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_84)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_84)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_84)>::class_type, std::remove_const_t<decltype(lambda_84)>>);
[[maybe_unused]] const auto lambda_85 = [](volatile int *, ...) mutable -> volatile int * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_85)>::result_type, volatile int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_85)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_85)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_85)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_85)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_85)>::arg0_type, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_85)>::arg_type<0>, volatile int *>);
static_assert(callable_traits<decltype(lambda_85)>::arity == 1);
static_assert(callable_traits<decltype(lambda_85)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_85)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_85)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_85)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_85)>::is_const == false);
static_assert(callable_traits<decltype(lambda_85)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_85)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_85)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_85)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_85)>::class_type, std::remove_const_t<decltype(lambda_85)>>);
[[maybe_unused]] const auto lambda_86 = [](const volatile int *) noexcept -> const volatile int * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_86)>::result_type, const volatile int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_86)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_86)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_86)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_86)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_86)>::arg0_type, const volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_86)>::arg_type<0>, const volatile int *>);
static_assert(callable_traits<decltype(lambda_86)>::arity == 1);
static_assert(callable_traits<decltype(lambda_86)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_86)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_86)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_86)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_86)>::is_const == true);
static_assert(callable_traits<decltype(lambda_86)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_86)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_86)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_86)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_86)>::class_type, std::remove_const_t<decltype(lambda_86)>>);
[[maybe_unused]] const auto lambda_87 = [](int &, ...) mutable noexcept -> int & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_87)>::result_type, int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_87)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_87)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_87)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_87)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_87)>::arg0_type, int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_87)>::arg_type<0>, int &>);
static_assert(callable_traits<decltype(lambda_87)>::arity == 1);
static_assert(callable_traits<decltype(lambda_87)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_87)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_87)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_87)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_87)>::is_const == false);
static_assert(callable_traits<decltype(lambda_87)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_87)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_87)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_87)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_87)>::class_type, std::remove_const_t<decltype(lambda_87)>>);
[[maybe_unused]] const auto lambda_88 = [](const int &) -> const int & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_88)>::result_type, const int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_88)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_88)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_88)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_88)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_88)>::arg0_type, const int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_88)>::arg_type<0>, const int &>);
static_assert(callable_traits<decltype(lambda_88)>::arity == 1);
static_assert(callable_traits<decltype(lambda_88)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_88)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_88)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_88)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_88)>::is_const == true);
static_assert(callable_traits<decltype(lambda_88)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_88)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_88)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_88)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_88)>::class_type, std::remove_const_t<decltype(lambda_88)>>);
[[maybe_unused]] const auto lambda_89 = [](volatile int &, ...) mutable -> volatile int & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_89)>::result_type, volatile int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_89)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_89)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_89)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_89)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_89)>::arg0_type, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_89)>::arg_type<0>, volatile int &>);
static_assert(callable_traits<decltype(lambda_89)>::arity == 1);
static_assert(callable_traits<decltype(lambda_89)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_89)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_89)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_89)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_89)>::is_const == false);
static_assert(callable_traits<decltype(lambda_89)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_89)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_89)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_89)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_89)>::class_type, std::remove_const_t<decltype(lambda_89)>>);
[[maybe_unused]] const auto lambda_90 = [](const volatile int &) noexcept -> const volatile int & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_90)>::result_type, const volatile int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_90)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_90)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_90)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_90)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_90)>::arg0_type, const volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_90)>::arg_type<0>, const volatile int &>);
static_assert(callable_traits<decltype(lambda_90)>::arity == 1);
static_assert(callable_traits<decltype(lambda_90)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_90)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_90)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_90)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_90)>::is_const == true);
static_assert(callable_traits<decltype(lambda_90)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_90)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_90)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_90)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_90)>::class_type, std::remove_const_t<decltype(lambda_90)>>);
[[maybe_unused]] const auto lambda_91 = [](int * &, ...) mutable noexcept -> int * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_91)>::result_type, int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_91)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_91)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_91)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_91)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_91)>::arg0_type, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_91)>::arg_type<0>, int * &>);
static_assert(callable_traits<decltype(lambda_91)>::arity == 1);
static_assert(callable_traits<decltype(lambda_91)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_91)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_91)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_91)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_91)>::is_const == false);
static_assert(callable_traits<decltype(lambda_91)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_91)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_91)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_91)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_91)>::class_type, std::remove_const_t<decltype(lambda_91)>>);
[[maybe_unused]] const auto lambda_92 = [](const int * &) -> const int * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_92)>::result_type, const int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_92)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_92)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_92)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_92)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_92)>::arg0_type, const int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_92)>::arg_type<0>, const int * &>);
static_assert(callable_traits<decltype(lambda_92)>::arity == 1);
static_assert(callable_traits<decltype(lambda_92)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_92)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_92)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_92)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_92)>::is_const == true);
static_assert(callable_traits<decltype(lambda_92)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_92)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_92)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_92)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_92)>::class_type, std::remove_const_t<decltype(lambda_92)>>);
[[maybe_unused]] const auto lambda_93 = [](volatile int * &, ...) mutable -> volatile int * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_93)>::result_type, volatile int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_93)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_93)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_93)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_93)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_93)>::arg0_type, volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_93)>::arg_type<0>, volatile int * &>);
static_assert(callable_traits<decltype(lambda_93)>::arity == 1);
static_assert(callable_traits<decltype(lambda_93)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_93)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_93)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_93)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_93)>::is_const == false);
static_assert(callable_traits<decltype(lambda_93)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_93)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_93)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_93)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_93)>::class_type, std::remove_const_t<decltype(lambda_93)>>);
[[maybe_unused]] const auto lambda_94 = [](const volatile int * &) noexcept -> const volatile int * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_94)>::result_type, const volatile int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_94)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_94)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_94)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_94)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_94)>::arg0_type, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_94)>::arg_type<0>, const volatile int * &>);
static_assert(callable_traits<decltype(lambda_94)>::arity == 1);
static_assert(callable_traits<decltype(lambda_94)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_94)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_94)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_94)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_94)>::is_const == true);
static_assert(callable_traits<decltype(lambda_94)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_94)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_94)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_94)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_94)>::class_type, std::remove_const_t<decltype(lambda_94)>>);
[[maybe_unused]] const auto lambda_95 = [](int * const &, ...) mutable noexcept -> int * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_95)>::result_type, int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_95)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_95)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_95)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_95)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_95)>::arg0_type, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_95)>::arg_type<0>, int * const &>);
static_assert(callable_traits<decltype(lambda_95)>::arity == 1);
static_assert(callable_traits<decltype(lambda_95)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_95)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_95)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_95)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_95)>::is_const == false);
static_assert(callable_traits<decltype(lambda_95)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_95)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_95)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_95)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_95)>::class_type, std::remove_const_t<decltype(lambda_95)>>);
[[maybe_unused]] const auto lambda_96 = [](const int * const &) -> const int * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_96)>::result_type, const int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_96)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_96)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_96)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_96)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_96)>::arg0_type, const int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_96)>::arg_type<0>, const int * const &>);
static_assert(callable_traits<decltype(lambda_96)>::arity == 1);
static_assert(callable_traits<decltype(lambda_96)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_96)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_96)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_96)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_96)>::is_const == true);
static_assert(callable_traits<decltype(lambda_96)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_96)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_96)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_96)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_96)>::class_type, std::remove_const_t<decltype(lambda_96)>>);
[[maybe_unused]] const auto lambda_97 = [](volatile int * const &, ...) mutable -> volatile int * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_97)>::result_type, volatile int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_97)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_97)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_97)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_97)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_97)>::arg0_type, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_97)>::arg_type<0>, volatile int * const &>);
static_assert(callable_traits<decltype(lambda_97)>::arity == 1);
static_assert(callable_traits<decltype(lambda_97)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_97)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_97)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_97)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_97)>::is_const == false);
static_assert(callable_traits<decltype(lambda_97)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_97)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_97)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_97)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_97)>::class_type, std::remove_const_t<decltype(lambda_97)>>);
[[maybe_unused]] const auto lambda_98 = [](const volatile int * const &) noexcept -> const volatile int * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_98)>::result_type, const volatile int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_98)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_98)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_98)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_98)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_98)>::arg0_type, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_98)>::arg_type<0>, const volatile int * const &>);
static_assert(callable_traits<decltype(lambda_98)>::arity == 1);
static_assert(callable_traits<decltype(lambda_98)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_98)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_98)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_98)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_98)>::is_const == true);
static_assert(callable_traits<decltype(lambda_98)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_98)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_98)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_98)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_98)>::class_type, std::remove_const_t<decltype(lambda_98)>>);
[[maybe_unused]] const auto lambda_99 = [](int * volatile &, ...) mutable noexcept -> int * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_99)>::result_type, int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_99)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_99)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_99)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_99)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_99)>::arg0_type, int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_99)>::arg_type<0>, int * volatile &>);
static_assert(callable_traits<decltype(lambda_99)>::arity == 1);
static_assert(callable_traits<decltype(lambda_99)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_99)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_99)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_99)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_99)>::is_const == false);
static_assert(callable_traits<decltype(lambda_99)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_99)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_99)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_99)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_99)>::class_type, std::remove_const_t<decltype(lambda_99)>>);
[[maybe_unused]] const auto lambda_100 = [](const int * volatile &) -> const int * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_100)>::result_type, const int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_100)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_100)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_100)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_100)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_100)>::arg0_type, const int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_100)>::arg_type<0>, const int * volatile &>);
static_assert(callable_traits<decltype(lambda_100)>::arity == 1);
static_assert(callable_traits<decltype(lambda_100)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_100)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_100)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_100)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_100)>::is_const == true);
static_assert(callable_traits<decltype(lambda_100)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_100)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_100)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_100)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_100)>::class_type, std::remove_const_t<decltype(lambda_100)>>);
[[maybe_unused]] const auto lambda_101 = [](volatile int * volatile &, ...) mutable -> volatile int * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_101)>::result_type, volatile int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_101)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_101)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_101)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_101)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_101)>::arg0_type, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_101)>::arg_type<0>, volatile int * volatile &>);
static_assert(callable_traits<decltype(lambda_101)>::arity == 1);
static_assert(callable_traits<decltype(lambda_101)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_101)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_101)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_101)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_101)>::is_const == false);
static_assert(callable_traits<decltype(lambda_101)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_101)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_101)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_101)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_101)>::class_type, std::remove_const_t<decltype(lambda_101)>>);
[[maybe_unused]] const auto lambda_102 = [](const volatile int * volatile &) noexcept -> const volatile int * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_102)>::result_type, const volatile int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_102)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_102)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_102)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_102)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_102)>::arg0_type, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_102)>::arg_type<0>, const volatile int * volatile &>);
static_assert(callable_traits<decltype(lambda_102)>::arity == 1);
static_assert(callable_traits<decltype(lambda_102)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_102)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_102)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_102)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_102)>::is_const == true);
static_assert(callable_traits<decltype(lambda_102)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_102)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_102)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_102)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_102)>::class_type, std::remove_const_t<decltype(lambda_102)>>);
[[maybe_unused]] const auto lambda_103 = [](int * const volatile &, ...) mutable noexcept -> int * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_103)>::result_type, int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_103)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_103)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_103)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_103)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_103)>::arg0_type, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_103)>::arg_type<0>, int * const volatile &>);
static_assert(callable_traits<decltype(lambda_103)>::arity == 1);
static_assert(callable_traits<decltype(lambda_103)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_103)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_103)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_103)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_103)>::is_const == false);
static_assert(callable_traits<decltype(lambda_103)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_103)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_103)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_103)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_103)>::class_type, std::remove_const_t<decltype(lambda_103)>>);
[[maybe_unused]] const auto lambda_104 = [](const int * const volatile &) -> const int * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_104)>::result_type, const int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_104)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_104)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_104)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_104)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_104)>::arg0_type, const int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_104)>::arg_type<0>, const int * const volatile &>);
static_assert(callable_traits<decltype(lambda_104)>::arity == 1);
static_assert(callable_traits<decltype(lambda_104)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_104)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_104)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_104)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_104)>::is_const == true);
static_assert(callable_traits<decltype(lambda_104)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_104)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_104)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_104)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_104)>::class_type, std::remove_const_t<decltype(lambda_104)>>);
[[maybe_unused]] const auto lambda_105 = [](volatile int * const volatile &, ...) mutable -> volatile int * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_105)>::result_type, volatile int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_105)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_105)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_105)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_105)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_105)>::arg0_type, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_105)>::arg_type<0>, volatile int * const volatile &>);
static_assert(callable_traits<decltype(lambda_105)>::arity == 1);
static_assert(callable_traits<decltype(lambda_105)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_105)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_105)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_105)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_105)>::is_const == false);
static_assert(callable_traits<decltype(lambda_105)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_105)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_105)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_105)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_105)>::class_type, std::remove_const_t<decltype(lambda_105)>>);
[[maybe_unused]] const auto lambda_106 = [](const volatile int * const volatile &) noexcept -> const volatile int * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_106)>::result_type, const volatile int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_106)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_106)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_106)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_106)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_106)>::arg0_type, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_106)>::arg_type<0>, const volatile int * const volatile &>);
static_assert(callable_traits<decltype(lambda_106)>::arity == 1);
static_assert(callable_traits<decltype(lambda_106)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_106)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_106)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_106)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_106)>::is_const == true);
static_assert(callable_traits<decltype(lambda_106)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_106)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_106)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_106)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_106)>::class_type, std::remove_const_t<decltype(lambda_106)>>);
[[maybe_unused]] const auto lambda_107 = [](int &&, ...) mutable noexcept -> int && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_107)>::result_type, int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_107)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_107)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_107)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_107)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_107)>::arg0_type, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_107)>::arg_type<0>, int &&>);
static_assert(callable_traits<decltype(lambda_107)>::arity == 1);
static_assert(callable_traits<decltype(lambda_107)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_107)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_107)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_107)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_107)>::is_const == false);
static_assert(callable_traits<decltype(lambda_107)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_107)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_107)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_107)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_107)>::class_type, std::remove_const_t<decltype(lambda_107)>>);
[[maybe_unused]] const auto lambda_108 = [](const int &&) -> const int && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_108)>::result_type, const int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_108)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_108)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_108)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_108)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_108)>::arg0_type, const int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_108)>::arg_type<0>, const int &&>);
static_assert(callable_traits<decltype(lambda_108)>::arity == 1);
static_assert(callable_traits<decltype(lambda_108)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_108)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_108)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_108)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_108)>::is_const == true);
static_assert(callable_traits<decltype(lambda_108)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_108)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_108)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_108)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_108)>::class_type, std::remove_const_t<decltype(lambda_108)>>);
[[maybe_unused]] const auto lambda_109 = [](volatile int &&, ...) mutable -> volatile int && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_109)>::result_type, volatile int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_109)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_109)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_109)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_109)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_109)>::arg0_type, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_109)>::arg_type<0>, volatile int &&>);
static_assert(callable_traits<decltype(lambda_109)>::arity == 1);
static_assert(callable_traits<decltype(lambda_109)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_109)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_109)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_109)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_109)>::is_const == false);
static_assert(callable_traits<decltype(lambda_109)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_109)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_109)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_109)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_109)>::class_type, std::remove_const_t<decltype(lambda_109)>>);
[[maybe_unused]] const auto lambda_110 = [](const volatile int &&) noexcept -> const volatile int && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_110)>::result_type, const volatile int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_110)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_110)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_110)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_110)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_110)>::arg0_type, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_110)>::arg_type<0>, const volatile int &&>);
static_assert(callable_traits<decltype(lambda_110)>::arity == 1);
static_assert(callable_traits<decltype(lambda_110)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_110)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_110)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_110)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_110)>::is_const == true);
static_assert(callable_traits<decltype(lambda_110)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_110)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_110)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_110)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_110)>::class_type, std::remove_const_t<decltype(lambda_110)>>);
[[maybe_unused]] const auto lambda_111 = [](int * &&, ...) mutable noexcept -> int * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_111)>::result_type, int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_111)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_111)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_111)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_111)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_111)>::arg0_type, int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_111)>::arg_type<0>, int * &&>);
static_assert(callable_traits<decltype(lambda_111)>::arity == 1);
static_assert(callable_traits<decltype(lambda_111)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_111)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_111)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_111)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_111)>::is_const == false);
static_assert(callable_traits<decltype(lambda_111)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_111)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_111)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_111)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_111)>::class_type, std::remove_const_t<decltype(lambda_111)>>);
[[maybe_unused]] const auto lambda_112 = [](const int * &&) -> const int * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_112)>::result_type, const int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_112)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_112)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_112)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_112)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_112)>::arg0_type, const int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_112)>::arg_type<0>, const int * &&>);
static_assert(callable_traits<decltype(lambda_112)>::arity == 1);
static_assert(callable_traits<decltype(lambda_112)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_112)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_112)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_112)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_112)>::is_const == true);
static_assert(callable_traits<decltype(lambda_112)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_112)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_112)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_112)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_112)>::class_type, std::remove_const_t<decltype(lambda_112)>>);
[[maybe_unused]] const auto lambda_113 = [](volatile int * &&, ...) mutable -> volatile int * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_113)>::result_type, volatile int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_113)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_113)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_113)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_113)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_113)>::arg0_type, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_113)>::arg_type<0>, volatile int * &&>);
static_assert(callable_traits<decltype(lambda_113)>::arity == 1);
static_assert(callable_traits<decltype(lambda_113)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_113)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_113)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_113)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_113)>::is_const == false);
static_assert(callable_traits<decltype(lambda_113)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_113)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_113)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_113)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_113)>::class_type, std::remove_const_t<decltype(lambda_113)>>);
[[maybe_unused]] const auto lambda_114 = [](const volatile int * &&) noexcept -> const volatile int * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_114)>::result_type, const volatile int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_114)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_114)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_114)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_114)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_114)>::arg0_type, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_114)>::arg_type<0>, const volatile int * &&>);
static_assert(callable_traits<decltype(lambda_114)>::arity == 1);
static_assert(callable_traits<decltype(lambda_114)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_114)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_114)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_114)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_114)>::is_const == true);
static_assert(callable_traits<decltype(lambda_114)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_114)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_114)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_114)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_114)>::class_type, std::remove_const_t<decltype(lambda_114)>>);
[[maybe_unused]] const auto lambda_115 = [](int * const &&, ...) mutable noexcept -> int * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_115)>::result_type, int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_115)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_115)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_115)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_115)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_115)>::arg0_type, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_115)>::arg_type<0>, int * const &&>);
static_assert(callable_traits<decltype(lambda_115)>::arity == 1);
static_assert(callable_traits<decltype(lambda_115)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_115)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_115)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_115)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_115)>::is_const == false);
static_assert(callable_traits<decltype(lambda_115)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_115)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_115)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_115)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_115)>::class_type, std::remove_const_t<decltype(lambda_115)>>);
[[maybe_unused]] const auto lambda_116 = [](const int * const &&) -> const int * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_116)>::result_type, const int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_116)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_116)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_116)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_116)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_116)>::arg0_type, const int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_116)>::arg_type<0>, const int * const &&>);
static_assert(callable_traits<decltype(lambda_116)>::arity == 1);
static_assert(callable_traits<decltype(lambda_116)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_116)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_116)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_116)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_116)>::is_const == true);
static_assert(callable_traits<decltype(lambda_116)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_116)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_116)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_116)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_116)>::class_type, std::remove_const_t<decltype(lambda_116)>>);
[[maybe_unused]] const auto lambda_117 = [](volatile int * const &&, ...) mutable -> volatile int * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_117)>::result_type, volatile int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_117)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_117)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_117)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_117)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_117)>::arg0_type, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_117)>::arg_type<0>, volatile int * const &&>);
static_assert(callable_traits<decltype(lambda_117)>::arity == 1);
static_assert(callable_traits<decltype(lambda_117)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_117)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_117)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_117)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_117)>::is_const == false);
static_assert(callable_traits<decltype(lambda_117)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_117)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_117)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_117)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_117)>::class_type, std::remove_const_t<decltype(lambda_117)>>);
[[maybe_unused]] const auto lambda_118 = [](const volatile int * const &&) noexcept -> const volatile int * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_118)>::result_type, const volatile int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_118)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_118)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_118)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_118)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_118)>::arg0_type, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_118)>::arg_type<0>, const volatile int * const &&>);
static_assert(callable_traits<decltype(lambda_118)>::arity == 1);
static_assert(callable_traits<decltype(lambda_118)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_118)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_118)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_118)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_118)>::is_const == true);
static_assert(callable_traits<decltype(lambda_118)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_118)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_118)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_118)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_118)>::class_type, std::remove_const_t<decltype(lambda_118)>>);
[[maybe_unused]] const auto lambda_119 = [](int * volatile &&, ...) mutable noexcept -> int * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_119)>::result_type, int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_119)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_119)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_119)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_119)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_119)>::arg0_type, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_119)>::arg_type<0>, int * volatile &&>);
static_assert(callable_traits<decltype(lambda_119)>::arity == 1);
static_assert(callable_traits<decltype(lambda_119)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_119)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_119)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_119)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_119)>::is_const == false);
static_assert(callable_traits<decltype(lambda_119)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_119)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_119)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_119)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_119)>::class_type, std::remove_const_t<decltype(lambda_119)>>);
[[maybe_unused]] const auto lambda_120 = [](const int * volatile &&) -> const int * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_120)>::result_type, const int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_120)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_120)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_120)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_120)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_120)>::arg0_type, const int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_120)>::arg_type<0>, const int * volatile &&>);
static_assert(callable_traits<decltype(lambda_120)>::arity == 1);
static_assert(callable_traits<decltype(lambda_120)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_120)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_120)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_120)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_120)>::is_const == true);
static_assert(callable_traits<decltype(lambda_120)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_120)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_120)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_120)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_120)>::class_type, std::remove_const_t<decltype(lambda_120)>>);
[[maybe_unused]] const auto lambda_121 = [](volatile int * volatile &&, ...) mutable -> volatile int * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_121)>::result_type, volatile int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_121)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_121)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_121)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_121)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_121)>::arg0_type, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_121)>::arg_type<0>, volatile int * volatile &&>);
static_assert(callable_traits<decltype(lambda_121)>::arity == 1);
static_assert(callable_traits<decltype(lambda_121)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_121)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_121)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_121)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_121)>::is_const == false);
static_assert(callable_traits<decltype(lambda_121)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_121)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_121)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_121)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_121)>::class_type, std::remove_const_t<decltype(lambda_121)>>);
[[maybe_unused]] const auto lambda_122 = [](const volatile int * volatile &&) noexcept -> const volatile int * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_122)>::result_type, const volatile int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_122)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_122)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_122)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_122)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_122)>::arg0_type, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_122)>::arg_type<0>, const volatile int * volatile &&>);
static_assert(callable_traits<decltype(lambda_122)>::arity == 1);
static_assert(callable_traits<decltype(lambda_122)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_122)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_122)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_122)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_122)>::is_const == true);
static_assert(callable_traits<decltype(lambda_122)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_122)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_122)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_122)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_122)>::class_type, std::remove_const_t<decltype(lambda_122)>>);
[[maybe_unused]] const auto lambda_123 = [](int * const volatile &&, ...) mutable noexcept -> int * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_123)>::result_type, int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_123)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_123)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_123)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_123)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_123)>::arg0_type, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_123)>::arg_type<0>, int * const volatile &&>);
static_assert(callable_traits<decltype(lambda_123)>::arity == 1);
static_assert(callable_traits<decltype(lambda_123)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_123)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_123)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_123)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_123)>::is_const == false);
static_assert(callable_traits<decltype(lambda_123)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_123)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_123)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_123)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_123)>::class_type, std::remove_const_t<decltype(lambda_123)>>);
[[maybe_unused]] const auto lambda_124 = [](const int * const volatile &&) -> const int * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_124)>::result_type, const int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_124)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_124)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_124)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_124)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_124)>::arg0_type, const int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_124)>::arg_type<0>, const int * const volatile &&>);
static_assert(callable_traits<decltype(lambda_124)>::arity == 1);
static_assert(callable_traits<decltype(lambda_124)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_124)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_124)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_124)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_124)>::is_const == true);
static_assert(callable_traits<decltype(lambda_124)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_124)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_124)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_124)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_124)>::class_type, std::remove_const_t<decltype(lambda_124)>>);
[[maybe_unused]] const auto lambda_125 = [](volatile int * const volatile &&, ...) mutable -> volatile int * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_125)>::result_type, volatile int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_125)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_125)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_125)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_125)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_125)>::arg0_type, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_125)>::arg_type<0>, volatile int * const volatile &&>);
static_assert(callable_traits<decltype(lambda_125)>::arity == 1);
static_assert(callable_traits<decltype(lambda_125)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_125)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_125)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_125)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_125)>::is_const == false);
static_assert(callable_traits<decltype(lambda_125)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_125)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_125)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_125)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_125)>::class_type, std::remove_const_t<decltype(lambda_125)>>);
[[maybe_unused]] const auto lambda_126 = [](const volatile int * const volatile &&) noexcept -> const volatile int * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_126)>::result_type, const volatile int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_126)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_126)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_126)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_126)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_126)>::arg0_type, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_126)>::arg_type<0>, const volatile int * const volatile &&>);
static_assert(callable_traits<decltype(lambda_126)>::arity == 1);
static_assert(callable_traits<decltype(lambda_126)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_126)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_126)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_126)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_126)>::is_const == true);
static_assert(callable_traits<decltype(lambda_126)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_126)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_126)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_126)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_126)>::class_type, std::remove_const_t<decltype(lambda_126)>>);
[[maybe_unused]] const auto lambda_127 = [](float, ...) mutable noexcept -> float {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_127)>::result_type, float>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_127)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_127)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_127)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_127)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_127)>::arg0_type, float>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_127)>::arg_type<0>, float>);
static_assert(callable_traits<decltype(lambda_127)>::arity == 1);
static_assert(callable_traits<decltype(lambda_127)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_127)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_127)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_127)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_127)>::is_const == false);
static_assert(callable_traits<decltype(lambda_127)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_127)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_127)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_127)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_127)>::class_type, std::remove_const_t<decltype(lambda_127)>>);
[[maybe_unused]] const auto lambda_128 = [](float *) -> float * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_128)>::result_type, float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_128)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_128)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_128)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_128)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_128)>::arg0_type, float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_128)>::arg_type<0>, float *>);
static_assert(callable_traits<decltype(lambda_128)>::arity == 1);
static_assert(callable_traits<decltype(lambda_128)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_128)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_128)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_128)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_128)>::is_const == true);
static_assert(callable_traits<decltype(lambda_128)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_128)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_128)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_128)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_128)>::class_type, std::remove_const_t<decltype(lambda_128)>>);
[[maybe_unused]] const auto lambda_129 = [](const float *, ...) mutable -> const float * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_129)>::result_type, const float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_129)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_129)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_129)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_129)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_129)>::arg0_type, const float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_129)>::arg_type<0>, const float *>);
static_assert(callable_traits<decltype(lambda_129)>::arity == 1);
static_assert(callable_traits<decltype(lambda_129)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_129)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_129)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_129)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_129)>::is_const == false);
static_assert(callable_traits<decltype(lambda_129)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_129)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_129)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_129)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_129)>::class_type, std::remove_const_t<decltype(lambda_129)>>);
[[maybe_unused]] const auto lambda_130 = [](volatile float *) noexcept -> volatile float * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_130)>::result_type, volatile float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_130)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_130)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_130)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_130)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_130)>::arg0_type, volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_130)>::arg_type<0>, volatile float *>);
static_assert(callable_traits<decltype(lambda_130)>::arity == 1);
static_assert(callable_traits<decltype(lambda_130)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_130)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_130)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_130)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_130)>::is_const == true);
static_assert(callable_traits<decltype(lambda_130)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_130)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_130)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_130)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_130)>::class_type, std::remove_const_t<decltype(lambda_130)>>);
[[maybe_unused]] const auto lambda_131 = [](const volatile float *, ...) mutable noexcept -> const volatile float * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_131)>::result_type, const volatile float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_131)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_131)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_131)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_131)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_131)>::arg0_type, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_131)>::arg_type<0>, const volatile float *>);
static_assert(callable_traits<decltype(lambda_131)>::arity == 1);
static_assert(callable_traits<decltype(lambda_131)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_131)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_131)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_131)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_131)>::is_const == false);
static_assert(callable_traits<decltype(lambda_131)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_131)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_131)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_131)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_131)>::class_type, std::remove_const_t<decltype(lambda_131)>>);
[[maybe_unused]] const auto lambda_132 = [](float &) -> float & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_132)>::result_type, float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_132)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_132)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_132)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_132)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_132)>::arg0_type, float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_132)>::arg_type<0>, float &>);
static_assert(callable_traits<decltype(lambda_132)>::arity == 1);
static_assert(callable_traits<decltype(lambda_132)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_132)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_132)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_132)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_132)>::is_const == true);
static_assert(callable_traits<decltype(lambda_132)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_132)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_132)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_132)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_132)>::class_type, std::remove_const_t<decltype(lambda_132)>>);
[[maybe_unused]] const auto lambda_133 = [](const float &, ...) mutable -> const float & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_133)>::result_type, const float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_133)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_133)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_133)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_133)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_133)>::arg0_type, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_133)>::arg_type<0>, const float &>);
static_assert(callable_traits<decltype(lambda_133)>::arity == 1);
static_assert(callable_traits<decltype(lambda_133)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_133)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_133)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_133)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_133)>::is_const == false);
static_assert(callable_traits<decltype(lambda_133)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_133)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_133)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_133)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_133)>::class_type, std::remove_const_t<decltype(lambda_133)>>);
[[maybe_unused]] const auto lambda_134 = [](volatile float &) noexcept -> volatile float & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_134)>::result_type, volatile float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_134)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_134)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_134)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_134)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_134)>::arg0_type, volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_134)>::arg_type<0>, volatile float &>);
static_assert(callable_traits<decltype(lambda_134)>::arity == 1);
static_assert(callable_traits<decltype(lambda_134)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_134)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_134)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_134)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_134)>::is_const == true);
static_assert(callable_traits<decltype(lambda_134)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_134)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_134)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_134)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_134)>::class_type, std::remove_const_t<decltype(lambda_134)>>);
[[maybe_unused]] const auto lambda_135 = [](const volatile float &, ...) mutable noexcept -> const volatile float & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_135)>::result_type, const volatile float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_135)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_135)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_135)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_135)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_135)>::arg0_type, const volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_135)>::arg_type<0>, const volatile float &>);
static_assert(callable_traits<decltype(lambda_135)>::arity == 1);
static_assert(callable_traits<decltype(lambda_135)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_135)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_135)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_135)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_135)>::is_const == false);
static_assert(callable_traits<decltype(lambda_135)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_135)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_135)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_135)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_135)>::class_type, std::remove_const_t<decltype(lambda_135)>>);
[[maybe_unused]] const auto lambda_136 = [](float * &) -> float * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_136)>::result_type, float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_136)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_136)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_136)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_136)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_136)>::arg0_type, float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_136)>::arg_type<0>, float * &>);
static_assert(callable_traits<decltype(lambda_136)>::arity == 1);
static_assert(callable_traits<decltype(lambda_136)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_136)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_136)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_136)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_136)>::is_const == true);
static_assert(callable_traits<decltype(lambda_136)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_136)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_136)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_136)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_136)>::class_type, std::remove_const_t<decltype(lambda_136)>>);
[[maybe_unused]] const auto lambda_137 = [](const float * &, ...) mutable -> const float * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_137)>::result_type, const float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_137)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_137)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_137)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_137)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_137)>::arg0_type, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_137)>::arg_type<0>, const float * &>);
static_assert(callable_traits<decltype(lambda_137)>::arity == 1);
static_assert(callable_traits<decltype(lambda_137)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_137)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_137)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_137)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_137)>::is_const == false);
static_assert(callable_traits<decltype(lambda_137)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_137)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_137)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_137)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_137)>::class_type, std::remove_const_t<decltype(lambda_137)>>);
[[maybe_unused]] const auto lambda_138 = [](volatile float * &) noexcept -> volatile float * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_138)>::result_type, volatile float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_138)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_138)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_138)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_138)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_138)>::arg0_type, volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_138)>::arg_type<0>, volatile float * &>);
static_assert(callable_traits<decltype(lambda_138)>::arity == 1);
static_assert(callable_traits<decltype(lambda_138)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_138)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_138)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_138)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_138)>::is_const == true);
static_assert(callable_traits<decltype(lambda_138)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_138)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_138)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_138)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_138)>::class_type, std::remove_const_t<decltype(lambda_138)>>);
[[maybe_unused]] const auto lambda_139 = [](const volatile float * &, ...) mutable noexcept -> const volatile float * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_139)>::result_type, const volatile float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_139)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_139)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_139)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_139)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_139)>::arg0_type, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_139)>::arg_type<0>, const volatile float * &>);
static_assert(callable_traits<decltype(lambda_139)>::arity == 1);
static_assert(callable_traits<decltype(lambda_139)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_139)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_139)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_139)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_139)>::is_const == false);
static_assert(callable_traits<decltype(lambda_139)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_139)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_139)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_139)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_139)>::class_type, std::remove_const_t<decltype(lambda_139)>>);
[[maybe_unused]] const auto lambda_140 = [](float * const &) -> float * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_140)>::result_type, float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_140)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_140)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_140)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_140)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_140)>::arg0_type, float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_140)>::arg_type<0>, float * const &>);
static_assert(callable_traits<decltype(lambda_140)>::arity == 1);
static_assert(callable_traits<decltype(lambda_140)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_140)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_140)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_140)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_140)>::is_const == true);
static_assert(callable_traits<decltype(lambda_140)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_140)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_140)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_140)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_140)>::class_type, std::remove_const_t<decltype(lambda_140)>>);
[[maybe_unused]] const auto lambda_141 = [](const float * const &, ...) mutable -> const float * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_141)>::result_type, const float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_141)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_141)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_141)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_141)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_141)>::arg0_type, const float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_141)>::arg_type<0>, const float * const &>);
static_assert(callable_traits<decltype(lambda_141)>::arity == 1);
static_assert(callable_traits<decltype(lambda_141)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_141)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_141)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_141)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_141)>::is_const == false);
static_assert(callable_traits<decltype(lambda_141)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_141)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_141)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_141)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_141)>::class_type, std::remove_const_t<decltype(lambda_141)>>);
[[maybe_unused]] const auto lambda_142 = [](volatile float * const &) noexcept -> volatile float * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_142)>::result_type, volatile float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_142)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_142)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_142)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_142)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_142)>::arg0_type, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_142)>::arg_type<0>, volatile float * const &>);
static_assert(callable_traits<decltype(lambda_142)>::arity == 1);
static_assert(callable_traits<decltype(lambda_142)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_142)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_142)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_142)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_142)>::is_const == true);
static_assert(callable_traits<decltype(lambda_142)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_142)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_142)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_142)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_142)>::class_type, std::remove_const_t<decltype(lambda_142)>>);
[[maybe_unused]] const auto lambda_143 = [](const volatile float * const &, ...) mutable noexcept -> const volatile float * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_143)>::result_type, const volatile float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_143)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_143)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_143)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_143)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_143)>::arg0_type, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_143)>::arg_type<0>, const volatile float * const &>);
static_assert(callable_traits<decltype(lambda_143)>::arity == 1);
static_assert(callable_traits<decltype(lambda_143)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_143)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_143)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_143)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_143)>::is_const == false);
static_assert(callable_traits<decltype(lambda_143)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_143)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_143)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_143)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_143)>::class_type, std::remove_const_t<decltype(lambda_143)>>);
[[maybe_unused]] const auto lambda_144 = [](float * volatile &) -> float * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_144)>::result_type, float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_144)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_144)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_144)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_144)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_144)>::arg0_type, float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_144)>::arg_type<0>, float * volatile &>);
static_assert(callable_traits<decltype(lambda_144)>::arity == 1);
static_assert(callable_traits<decltype(lambda_144)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_144)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_144)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_144)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_144)>::is_const == true);
static_assert(callable_traits<decltype(lambda_144)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_144)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_144)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_144)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_144)>::class_type, std::remove_const_t<decltype(lambda_144)>>);
[[maybe_unused]] const auto lambda_145 = [](const float * volatile &, ...) mutable -> const float * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_145)>::result_type, const float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_145)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_145)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_145)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_145)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_145)>::arg0_type, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_145)>::arg_type<0>, const float * volatile &>);
static_assert(callable_traits<decltype(lambda_145)>::arity == 1);
static_assert(callable_traits<decltype(lambda_145)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_145)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_145)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_145)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_145)>::is_const == false);
static_assert(callable_traits<decltype(lambda_145)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_145)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_145)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_145)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_145)>::class_type, std::remove_const_t<decltype(lambda_145)>>);
[[maybe_unused]] const auto lambda_146 = [](volatile float * volatile &) noexcept -> volatile float * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_146)>::result_type, volatile float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_146)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_146)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_146)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_146)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_146)>::arg0_type, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_146)>::arg_type<0>, volatile float * volatile &>);
static_assert(callable_traits<decltype(lambda_146)>::arity == 1);
static_assert(callable_traits<decltype(lambda_146)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_146)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_146)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_146)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_146)>::is_const == true);
static_assert(callable_traits<decltype(lambda_146)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_146)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_146)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_146)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_146)>::class_type, std::remove_const_t<decltype(lambda_146)>>);
[[maybe_unused]] const auto lambda_147 = [](const volatile float * volatile &, ...) mutable noexcept -> const volatile float * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_147)>::result_type, const volatile float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_147)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_147)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_147)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_147)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_147)>::arg0_type, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_147)>::arg_type<0>, const volatile float * volatile &>);
static_assert(callable_traits<decltype(lambda_147)>::arity == 1);
static_assert(callable_traits<decltype(lambda_147)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_147)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_147)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_147)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_147)>::is_const == false);
static_assert(callable_traits<decltype(lambda_147)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_147)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_147)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_147)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_147)>::class_type, std::remove_const_t<decltype(lambda_147)>>);
[[maybe_unused]] const auto lambda_148 = [](float * const volatile &) -> float * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_148)>::result_type, float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_148)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_148)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_148)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_148)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_148)>::arg0_type, float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_148)>::arg_type<0>, float * const volatile &>);
static_assert(callable_traits<decltype(lambda_148)>::arity == 1);
static_assert(callable_traits<decltype(lambda_148)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_148)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_148)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_148)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_148)>::is_const == true);
static_assert(callable_traits<decltype(lambda_148)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_148)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_148)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_148)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_148)>::class_type, std::remove_const_t<decltype(lambda_148)>>);
[[maybe_unused]] const auto lambda_149 = [](const float * const volatile &, ...) mutable -> const float * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_149)>::result_type, const float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_149)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_149)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_149)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_149)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_149)>::arg0_type, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_149)>::arg_type<0>, const float * const volatile &>);
static_assert(callable_traits<decltype(lambda_149)>::arity == 1);
static_assert(callable_traits<decltype(lambda_149)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_149)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_149)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_149)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_149)>::is_const == false);
static_assert(callable_traits<decltype(lambda_149)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_149)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_149)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_149)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_149)>::class_type, std::remove_const_t<decltype(lambda_149)>>);
[[maybe_unused]] const auto lambda_150 = [](volatile float * const volatile &) noexcept -> volatile float * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_150)>::result_type, volatile float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_150)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_150)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_150)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_150)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_150)>::arg0_type, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_150)>::arg_type<0>, volatile float * const volatile &>);
static_assert(callable_traits<decltype(lambda_150)>::arity == 1);
static_assert(callable_traits<decltype(lambda_150)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_150)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_150)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_150)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_150)>::is_const == true);
static_assert(callable_traits<decltype(lambda_150)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_150)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_150)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_150)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_150)>::class_type, std::remove_const_t<decltype(lambda_150)>>);
[[maybe_unused]] const auto lambda_151 = [](const volatile float * const volatile &, ...) mutable noexcept -> const volatile float * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_151)>::result_type, const volatile float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_151)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_151)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_151)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_151)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_151)>::arg0_type, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_151)>::arg_type<0>, const volatile float * const volatile &>);
static_assert(callable_traits<decltype(lambda_151)>::arity == 1);
static_assert(callable_traits<decltype(lambda_151)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_151)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_151)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_151)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_151)>::is_const == false);
static_assert(callable_traits<decltype(lambda_151)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_151)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_151)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_151)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_151)>::class_type, std::remove_const_t<decltype(lambda_151)>>);
[[maybe_unused]] const auto lambda_152 = [](float &&) -> float && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_152)>::result_type, float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_152)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_152)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_152)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_152)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_152)>::arg0_type, float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_152)>::arg_type<0>, float &&>);
static_assert(callable_traits<decltype(lambda_152)>::arity == 1);
static_assert(callable_traits<decltype(lambda_152)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_152)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_152)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_152)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_152)>::is_const == true);
static_assert(callable_traits<decltype(lambda_152)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_152)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_152)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_152)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_152)>::class_type, std::remove_const_t<decltype(lambda_152)>>);
[[maybe_unused]] const auto lambda_153 = [](const float &&, ...) mutable -> const float && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_153)>::result_type, const float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_153)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_153)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_153)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_153)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_153)>::arg0_type, const float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_153)>::arg_type<0>, const float &&>);
static_assert(callable_traits<decltype(lambda_153)>::arity == 1);
static_assert(callable_traits<decltype(lambda_153)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_153)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_153)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_153)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_153)>::is_const == false);
static_assert(callable_traits<decltype(lambda_153)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_153)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_153)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_153)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_153)>::class_type, std::remove_const_t<decltype(lambda_153)>>);
[[maybe_unused]] const auto lambda_154 = [](volatile float &&) noexcept -> volatile float && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_154)>::result_type, volatile float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_154)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_154)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_154)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_154)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_154)>::arg0_type, volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_154)>::arg_type<0>, volatile float &&>);
static_assert(callable_traits<decltype(lambda_154)>::arity == 1);
static_assert(callable_traits<decltype(lambda_154)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_154)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_154)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_154)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_154)>::is_const == true);
static_assert(callable_traits<decltype(lambda_154)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_154)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_154)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_154)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_154)>::class_type, std::remove_const_t<decltype(lambda_154)>>);
[[maybe_unused]] const auto lambda_155 = [](const volatile float &&, ...) mutable noexcept -> const volatile float && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_155)>::result_type, const volatile float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_155)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_155)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_155)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_155)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_155)>::arg0_type, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_155)>::arg_type<0>, const volatile float &&>);
static_assert(callable_traits<decltype(lambda_155)>::arity == 1);
static_assert(callable_traits<decltype(lambda_155)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_155)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_155)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_155)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_155)>::is_const == false);
static_assert(callable_traits<decltype(lambda_155)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_155)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_155)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_155)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_155)>::class_type, std::remove_const_t<decltype(lambda_155)>>);
[[maybe_unused]] const auto lambda_156 = [](float * &&) -> float * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_156)>::result_type, float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_156)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_156)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_156)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_156)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_156)>::arg0_type, float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_156)>::arg_type<0>, float * &&>);
static_assert(callable_traits<decltype(lambda_156)>::arity == 1);
static_assert(callable_traits<decltype(lambda_156)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_156)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_156)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_156)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_156)>::is_const == true);
static_assert(callable_traits<decltype(lambda_156)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_156)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_156)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_156)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_156)>::class_type, std::remove_const_t<decltype(lambda_156)>>);
[[maybe_unused]] const auto lambda_157 = [](const float * &&, ...) mutable -> const float * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_157)>::result_type, const float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_157)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_157)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_157)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_157)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_157)>::arg0_type, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_157)>::arg_type<0>, const float * &&>);
static_assert(callable_traits<decltype(lambda_157)>::arity == 1);
static_assert(callable_traits<decltype(lambda_157)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_157)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_157)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_157)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_157)>::is_const == false);
static_assert(callable_traits<decltype(lambda_157)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_157)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_157)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_157)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_157)>::class_type, std::remove_const_t<decltype(lambda_157)>>);
[[maybe_unused]] const auto lambda_158 = [](volatile float * &&) noexcept -> volatile float * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_158)>::result_type, volatile float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_158)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_158)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_158)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_158)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_158)>::arg0_type, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_158)>::arg_type<0>, volatile float * &&>);
static_assert(callable_traits<decltype(lambda_158)>::arity == 1);
static_assert(callable_traits<decltype(lambda_158)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_158)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_158)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_158)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_158)>::is_const == true);
static_assert(callable_traits<decltype(lambda_158)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_158)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_158)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_158)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_158)>::class_type, std::remove_const_t<decltype(lambda_158)>>);
[[maybe_unused]] const auto lambda_159 = [](const volatile float * &&, ...) mutable noexcept -> const volatile float * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_159)>::result_type, const volatile float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_159)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_159)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_159)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_159)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_159)>::arg0_type, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_159)>::arg_type<0>, const volatile float * &&>);
static_assert(callable_traits<decltype(lambda_159)>::arity == 1);
static_assert(callable_traits<decltype(lambda_159)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_159)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_159)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_159)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_159)>::is_const == false);
static_assert(callable_traits<decltype(lambda_159)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_159)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_159)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_159)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_159)>::class_type, std::remove_const_t<decltype(lambda_159)>>);
[[maybe_unused]] const auto lambda_160 = [](float * const &&) -> float * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_160)>::result_type, float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_160)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_160)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_160)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_160)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_160)>::arg0_type, float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_160)>::arg_type<0>, float * const &&>);
static_assert(callable_traits<decltype(lambda_160)>::arity == 1);
static_assert(callable_traits<decltype(lambda_160)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_160)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_160)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_160)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_160)>::is_const == true);
static_assert(callable_traits<decltype(lambda_160)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_160)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_160)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_160)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_160)>::class_type, std::remove_const_t<decltype(lambda_160)>>);
[[maybe_unused]] const auto lambda_161 = [](const float * const &&, ...) mutable -> const float * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_161)>::result_type, const float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_161)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_161)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_161)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_161)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_161)>::arg0_type, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_161)>::arg_type<0>, const float * const &&>);
static_assert(callable_traits<decltype(lambda_161)>::arity == 1);
static_assert(callable_traits<decltype(lambda_161)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_161)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_161)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_161)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_161)>::is_const == false);
static_assert(callable_traits<decltype(lambda_161)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_161)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_161)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_161)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_161)>::class_type, std::remove_const_t<decltype(lambda_161)>>);
[[maybe_unused]] const auto lambda_162 = [](volatile float * const &&) noexcept -> volatile float * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_162)>::result_type, volatile float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_162)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_162)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_162)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_162)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_162)>::arg0_type, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_162)>::arg_type<0>, volatile float * const &&>);
static_assert(callable_traits<decltype(lambda_162)>::arity == 1);
static_assert(callable_traits<decltype(lambda_162)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_162)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_162)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_162)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_162)>::is_const == true);
static_assert(callable_traits<decltype(lambda_162)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_162)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_162)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_162)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_162)>::class_type, std::remove_const_t<decltype(lambda_162)>>);
[[maybe_unused]] const auto lambda_163 = [](const volatile float * const &&, ...) mutable noexcept -> const volatile float * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_163)>::result_type, const volatile float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_163)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_163)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_163)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_163)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_163)>::arg0_type, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_163)>::arg_type<0>, const volatile float * const &&>);
static_assert(callable_traits<decltype(lambda_163)>::arity == 1);
static_assert(callable_traits<decltype(lambda_163)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_163)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_163)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_163)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_163)>::is_const == false);
static_assert(callable_traits<decltype(lambda_163)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_163)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_163)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_163)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_163)>::class_type, std::remove_const_t<decltype(lambda_163)>>);
[[maybe_unused]] const auto lambda_164 = [](float * volatile &&) -> float * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_164)>::result_type, float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_164)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_164)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_164)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_164)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_164)>::arg0_type, float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_164)>::arg_type<0>, float * volatile &&>);
static_assert(callable_traits<decltype(lambda_164)>::arity == 1);
static_assert(callable_traits<decltype(lambda_164)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_164)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_164)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_164)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_164)>::is_const == true);
static_assert(callable_traits<decltype(lambda_164)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_164)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_164)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_164)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_164)>::class_type, std::remove_const_t<decltype(lambda_164)>>);
[[maybe_unused]] const auto lambda_165 = [](const float * volatile &&, ...) mutable -> const float * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_165)>::result_type, const float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_165)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_165)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_165)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_165)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_165)>::arg0_type, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_165)>::arg_type<0>, const float * volatile &&>);
static_assert(callable_traits<decltype(lambda_165)>::arity == 1);
static_assert(callable_traits<decltype(lambda_165)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_165)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_165)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_165)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_165)>::is_const == false);
static_assert(callable_traits<decltype(lambda_165)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_165)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_165)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_165)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_165)>::class_type, std::remove_const_t<decltype(lambda_165)>>);
[[maybe_unused]] const auto lambda_166 = [](volatile float * volatile &&) noexcept -> volatile float * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_166)>::result_type, volatile float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_166)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_166)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_166)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_166)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_166)>::arg0_type, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_166)>::arg_type<0>, volatile float * volatile &&>);
static_assert(callable_traits<decltype(lambda_166)>::arity == 1);
static_assert(callable_traits<decltype(lambda_166)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_166)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_166)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_166)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_166)>::is_const == true);
static_assert(callable_traits<decltype(lambda_166)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_166)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_166)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_166)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_166)>::class_type, std::remove_const_t<decltype(lambda_166)>>);
[[maybe_unused]] const auto lambda_167 = [](const volatile float * volatile &&, ...) mutable noexcept -> const volatile float * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_167)>::result_type, const volatile float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_167)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_167)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_167)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_167)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_167)>::arg0_type, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_167)>::arg_type<0>, const volatile float * volatile &&>);
static_assert(callable_traits<decltype(lambda_167)>::arity == 1);
static_assert(callable_traits<decltype(lambda_167)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_167)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_167)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_167)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_167)>::is_const == false);
static_assert(callable_traits<decltype(lambda_167)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_167)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_167)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_167)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_167)>::class_type, std::remove_const_t<decltype(lambda_167)>>);
[[maybe_unused]] const auto lambda_168 = [](float * const volatile &&) -> float * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_168)>::result_type, float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_168)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_168)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_168)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_168)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_168)>::arg0_type, float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_168)>::arg_type<0>, float * const volatile &&>);
static_assert(callable_traits<decltype(lambda_168)>::arity == 1);
static_assert(callable_traits<decltype(lambda_168)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_168)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_168)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_168)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_168)>::is_const == true);
static_assert(callable_traits<decltype(lambda_168)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_168)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_168)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_168)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_168)>::class_type, std::remove_const_t<decltype(lambda_168)>>);
[[maybe_unused]] const auto lambda_169 = [](const float * const volatile &&, ...) mutable -> const float * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_169)>::result_type, const float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_169)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_169)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_169)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_169)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_169)>::arg0_type, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_169)>::arg_type<0>, const float * const volatile &&>);
static_assert(callable_traits<decltype(lambda_169)>::arity == 1);
static_assert(callable_traits<decltype(lambda_169)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_169)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_169)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_169)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_169)>::is_const == false);
static_assert(callable_traits<decltype(lambda_169)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_169)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_169)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_169)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_169)>::class_type, std::remove_const_t<decltype(lambda_169)>>);
[[maybe_unused]] const auto lambda_170 = [](volatile float * const volatile &&) noexcept -> volatile float * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_170)>::result_type, volatile float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_170)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_170)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_170)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_170)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_170)>::arg0_type, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_170)>::arg_type<0>, volatile float * const volatile &&>);
static_assert(callable_traits<decltype(lambda_170)>::arity == 1);
static_assert(callable_traits<decltype(lambda_170)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_170)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_170)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_170)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_170)>::is_const == true);
static_assert(callable_traits<decltype(lambda_170)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_170)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_170)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_170)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_170)>::class_type, std::remove_const_t<decltype(lambda_170)>>);
[[maybe_unused]] const auto lambda_171 = [](const volatile float * const volatile &&, ...) mutable noexcept -> const volatile float * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_171)>::result_type, const volatile float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_171)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_171)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_171)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_171)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_171)>::arg0_type, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_171)>::arg_type<0>, const volatile float * const volatile &&>);
static_assert(callable_traits<decltype(lambda_171)>::arity == 1);
static_assert(callable_traits<decltype(lambda_171)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_171)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_171)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_171)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_171)>::is_const == false);
static_assert(callable_traits<decltype(lambda_171)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_171)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_171)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_171)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_171)>::class_type, std::remove_const_t<decltype(lambda_171)>>);
[[maybe_unused]] const auto lambda_172 = [](std::string) -> std::string {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_172)>::result_type, std::string>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_172)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_172)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_172)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_172)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_172)>::arg0_type, std::string>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_172)>::arg_type<0>, std::string>);
static_assert(callable_traits<decltype(lambda_172)>::arity == 1);
static_assert(callable_traits<decltype(lambda_172)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_172)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_172)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_172)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_172)>::is_const == true);
static_assert(callable_traits<decltype(lambda_172)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_172)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_172)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_172)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_172)>::class_type, std::remove_const_t<decltype(lambda_172)>>);
[[maybe_unused]] const auto lambda_173 = [](std::string *, ...) mutable -> std::string * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_173)>::result_type, std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_173)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_173)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_173)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_173)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_173)>::arg0_type, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_173)>::arg_type<0>, std::string *>);
static_assert(callable_traits<decltype(lambda_173)>::arity == 1);
static_assert(callable_traits<decltype(lambda_173)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_173)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_173)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_173)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_173)>::is_const == false);
static_assert(callable_traits<decltype(lambda_173)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_173)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_173)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_173)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_173)>::class_type, std::remove_const_t<decltype(lambda_173)>>);
[[maybe_unused]] const auto lambda_174 = [](const std::string *) noexcept -> const std::string * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_174)>::result_type, const std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_174)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_174)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_174)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_174)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_174)>::arg0_type, const std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_174)>::arg_type<0>, const std::string *>);
static_assert(callable_traits<decltype(lambda_174)>::arity == 1);
static_assert(callable_traits<decltype(lambda_174)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_174)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_174)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_174)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_174)>::is_const == true);
static_assert(callable_traits<decltype(lambda_174)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_174)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_174)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_174)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_174)>::class_type, std::remove_const_t<decltype(lambda_174)>>);
[[maybe_unused]] const auto lambda_175 = [](volatile std::string *, ...) mutable noexcept -> volatile std::string * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_175)>::result_type, volatile std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_175)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_175)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_175)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_175)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_175)>::arg0_type, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_175)>::arg_type<0>, volatile std::string *>);
static_assert(callable_traits<decltype(lambda_175)>::arity == 1);
static_assert(callable_traits<decltype(lambda_175)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_175)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_175)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_175)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_175)>::is_const == false);
static_assert(callable_traits<decltype(lambda_175)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_175)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_175)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_175)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_175)>::class_type, std::remove_const_t<decltype(lambda_175)>>);
[[maybe_unused]] const auto lambda_176 = [](const volatile std::string *) -> const volatile std::string * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_176)>::result_type, const volatile std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_176)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_176)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_176)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_176)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_176)>::arg0_type, const volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_176)>::arg_type<0>, const volatile std::string *>);
static_assert(callable_traits<decltype(lambda_176)>::arity == 1);
static_assert(callable_traits<decltype(lambda_176)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_176)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_176)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_176)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_176)>::is_const == true);
static_assert(callable_traits<decltype(lambda_176)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_176)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_176)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_176)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_176)>::class_type, std::remove_const_t<decltype(lambda_176)>>);
[[maybe_unused]] const auto lambda_177 = [](std::string &, ...) mutable -> std::string & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_177)>::result_type, std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_177)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_177)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_177)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_177)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_177)>::arg0_type, std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_177)>::arg_type<0>, std::string &>);
static_assert(callable_traits<decltype(lambda_177)>::arity == 1);
static_assert(callable_traits<decltype(lambda_177)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_177)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_177)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_177)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_177)>::is_const == false);
static_assert(callable_traits<decltype(lambda_177)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_177)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_177)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_177)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_177)>::class_type, std::remove_const_t<decltype(lambda_177)>>);
[[maybe_unused]] const auto lambda_178 = [](const std::string &) noexcept -> const std::string & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_178)>::result_type, const std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_178)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_178)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_178)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_178)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_178)>::arg0_type, const std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_178)>::arg_type<0>, const std::string &>);
static_assert(callable_traits<decltype(lambda_178)>::arity == 1);
static_assert(callable_traits<decltype(lambda_178)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_178)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_178)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_178)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_178)>::is_const == true);
static_assert(callable_traits<decltype(lambda_178)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_178)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_178)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_178)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_178)>::class_type, std::remove_const_t<decltype(lambda_178)>>);
[[maybe_unused]] const auto lambda_179 = [](volatile std::string &, ...) mutable noexcept -> volatile std::string & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_179)>::result_type, volatile std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_179)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_179)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_179)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_179)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_179)>::arg0_type, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_179)>::arg_type<0>, volatile std::string &>);
static_assert(callable_traits<decltype(lambda_179)>::arity == 1);
static_assert(callable_traits<decltype(lambda_179)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_179)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_179)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_179)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_179)>::is_const == false);
static_assert(callable_traits<decltype(lambda_179)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_179)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_179)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_179)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_179)>::class_type, std::remove_const_t<decltype(lambda_179)>>);
[[maybe_unused]] const auto lambda_180 = [](const volatile std::string &) -> const volatile std::string & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_180)>::result_type, const volatile std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_180)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_180)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_180)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_180)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_180)>::arg0_type, const volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_180)>::arg_type<0>, const volatile std::string &>);
static_assert(callable_traits<decltype(lambda_180)>::arity == 1);
static_assert(callable_traits<decltype(lambda_180)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_180)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_180)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_180)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_180)>::is_const == true);
static_assert(callable_traits<decltype(lambda_180)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_180)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_180)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_180)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_180)>::class_type, std::remove_const_t<decltype(lambda_180)>>);
[[maybe_unused]] const auto lambda_181 = [](std::string * &, ...) mutable -> std::string * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_181)>::result_type, std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_181)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_181)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_181)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_181)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_181)>::arg0_type, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_181)>::arg_type<0>, std::string * &>);
static_assert(callable_traits<decltype(lambda_181)>::arity == 1);
static_assert(callable_traits<decltype(lambda_181)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_181)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_181)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_181)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_181)>::is_const == false);
static_assert(callable_traits<decltype(lambda_181)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_181)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_181)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_181)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_181)>::class_type, std::remove_const_t<decltype(lambda_181)>>);
[[maybe_unused]] const auto lambda_182 = [](const std::string * &) noexcept -> const std::string * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_182)>::result_type, const std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_182)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_182)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_182)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_182)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_182)>::arg0_type, const std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_182)>::arg_type<0>, const std::string * &>);
static_assert(callable_traits<decltype(lambda_182)>::arity == 1);
static_assert(callable_traits<decltype(lambda_182)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_182)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_182)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_182)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_182)>::is_const == true);
static_assert(callable_traits<decltype(lambda_182)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_182)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_182)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_182)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_182)>::class_type, std::remove_const_t<decltype(lambda_182)>>);
[[maybe_unused]] const auto lambda_183 = [](volatile std::string * &, ...) mutable noexcept -> volatile std::string * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_183)>::result_type, volatile std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_183)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_183)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_183)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_183)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_183)>::arg0_type, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_183)>::arg_type<0>, volatile std::string * &>);
static_assert(callable_traits<decltype(lambda_183)>::arity == 1);
static_assert(callable_traits<decltype(lambda_183)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_183)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_183)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_183)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_183)>::is_const == false);
static_assert(callable_traits<decltype(lambda_183)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_183)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_183)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_183)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_183)>::class_type, std::remove_const_t<decltype(lambda_183)>>);
[[maybe_unused]] const auto lambda_184 = [](const volatile std::string * &) -> const volatile std::string * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_184)>::result_type, const volatile std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_184)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_184)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_184)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_184)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_184)>::arg0_type, const volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_184)>::arg_type<0>, const volatile std::string * &>);
static_assert(callable_traits<decltype(lambda_184)>::arity == 1);
static_assert(callable_traits<decltype(lambda_184)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_184)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_184)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_184)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_184)>::is_const == true);
static_assert(callable_traits<decltype(lambda_184)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_184)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_184)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_184)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_184)>::class_type, std::remove_const_t<decltype(lambda_184)>>);
[[maybe_unused]] const auto lambda_185 = [](std::string * const &, ...) mutable -> std::string * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_185)>::result_type, std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_185)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_185)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_185)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_185)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_185)>::arg0_type, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_185)>::arg_type<0>, std::string * const &>);
static_assert(callable_traits<decltype(lambda_185)>::arity == 1);
static_assert(callable_traits<decltype(lambda_185)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_185)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_185)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_185)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_185)>::is_const == false);
static_assert(callable_traits<decltype(lambda_185)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_185)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_185)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_185)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_185)>::class_type, std::remove_const_t<decltype(lambda_185)>>);
[[maybe_unused]] const auto lambda_186 = [](const std::string * const &) noexcept -> const std::string * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_186)>::result_type, const std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_186)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_186)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_186)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_186)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_186)>::arg0_type, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_186)>::arg_type<0>, const std::string * const &>);
static_assert(callable_traits<decltype(lambda_186)>::arity == 1);
static_assert(callable_traits<decltype(lambda_186)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_186)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_186)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_186)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_186)>::is_const == true);
static_assert(callable_traits<decltype(lambda_186)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_186)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_186)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_186)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_186)>::class_type, std::remove_const_t<decltype(lambda_186)>>);
[[maybe_unused]] const auto lambda_187 = [](volatile std::string * const &, ...) mutable noexcept -> volatile std::string * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_187)>::result_type, volatile std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_187)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_187)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_187)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_187)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_187)>::arg0_type, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_187)>::arg_type<0>, volatile std::string * const &>);
static_assert(callable_traits<decltype(lambda_187)>::arity == 1);
static_assert(callable_traits<decltype(lambda_187)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_187)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_187)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_187)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_187)>::is_const == false);
static_assert(callable_traits<decltype(lambda_187)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_187)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_187)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_187)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_187)>::class_type, std::remove_const_t<decltype(lambda_187)>>);
[[maybe_unused]] const auto lambda_188 = [](const volatile std::string * const &) -> const volatile std::string * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_188)>::result_type, const volatile std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_188)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_188)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_188)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_188)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_188)>::arg0_type, const volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_188)>::arg_type<0>, const volatile std::string * const &>);
static_assert(callable_traits<decltype(lambda_188)>::arity == 1);
static_assert(callable_traits<decltype(lambda_188)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_188)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_188)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_188)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_188)>::is_const == true);
static_assert(callable_traits<decltype(lambda_188)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_188)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_188)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_188)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_188)>::class_type, std::remove_const_t<decltype(lambda_188)>>);
[[maybe_unused]] const auto lambda_189 = [](std::string * volatile &, ...) mutable -> std::string * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_189)>::result_type, std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_189)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_189)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_189)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_189)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_189)>::arg0_type, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_189)>::arg_type<0>, std::string * volatile &>);
static_assert(callable_traits<decltype(lambda_189)>::arity == 1);
static_assert(callable_traits<decltype(lambda_189)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_189)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_189)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_189)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_189)>::is_const == false);
static_assert(callable_traits<decltype(lambda_189)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_189)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_189)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_189)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_189)>::class_type, std::remove_const_t<decltype(lambda_189)>>);
[[maybe_unused]] const auto lambda_190 = [](const std::string * volatile &) noexcept -> const std::string * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_190)>::result_type, const std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_190)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_190)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_190)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_190)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_190)>::arg0_type, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_190)>::arg_type<0>, const std::string * volatile &>);
static_assert(callable_traits<decltype(lambda_190)>::arity == 1);
static_assert(callable_traits<decltype(lambda_190)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_190)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_190)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_190)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_190)>::is_const == true);
static_assert(callable_traits<decltype(lambda_190)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_190)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_190)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_190)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_190)>::class_type, std::remove_const_t<decltype(lambda_190)>>);
[[maybe_unused]] const auto lambda_191 = [](volatile std::string * volatile &, ...) mutable noexcept -> volatile std::string * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_191)>::result_type, volatile std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_191)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_191)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_191)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_191)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_191)>::arg0_type, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_191)>::arg_type<0>, volatile std::string * volatile &>);
static_assert(callable_traits<decltype(lambda_191)>::arity == 1);
static_assert(callable_traits<decltype(lambda_191)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_191)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_191)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_191)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_191)>::is_const == false);
static_assert(callable_traits<decltype(lambda_191)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_191)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_191)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_191)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_191)>::class_type, std::remove_const_t<decltype(lambda_191)>>);
[[maybe_unused]] const auto lambda_192 = [](const volatile std::string * volatile &) -> const volatile std::string * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_192)>::result_type, const volatile std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_192)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_192)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_192)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_192)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_192)>::arg0_type, const volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_192)>::arg_type<0>, const volatile std::string * volatile &>);
static_assert(callable_traits<decltype(lambda_192)>::arity == 1);
static_assert(callable_traits<decltype(lambda_192)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_192)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_192)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_192)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_192)>::is_const == true);
static_assert(callable_traits<decltype(lambda_192)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_192)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_192)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_192)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_192)>::class_type, std::remove_const_t<decltype(lambda_192)>>);
[[maybe_unused]] const auto lambda_193 = [](std::string * const volatile &, ...) mutable -> std::string * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_193)>::result_type, std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_193)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_193)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_193)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_193)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_193)>::arg0_type, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_193)>::arg_type<0>, std::string * const volatile &>);
static_assert(callable_traits<decltype(lambda_193)>::arity == 1);
static_assert(callable_traits<decltype(lambda_193)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_193)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_193)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_193)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_193)>::is_const == false);
static_assert(callable_traits<decltype(lambda_193)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_193)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_193)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_193)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_193)>::class_type, std::remove_const_t<decltype(lambda_193)>>);
[[maybe_unused]] const auto lambda_194 = [](const std::string * const volatile &) noexcept -> const std::string * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_194)>::result_type, const std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_194)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_194)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_194)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_194)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_194)>::arg0_type, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_194)>::arg_type<0>, const std::string * const volatile &>);
static_assert(callable_traits<decltype(lambda_194)>::arity == 1);
static_assert(callable_traits<decltype(lambda_194)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_194)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_194)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_194)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_194)>::is_const == true);
static_assert(callable_traits<decltype(lambda_194)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_194)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_194)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_194)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_194)>::class_type, std::remove_const_t<decltype(lambda_194)>>);
[[maybe_unused]] const auto lambda_195 = [](volatile std::string * const volatile &, ...) mutable noexcept -> volatile std::string * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_195)>::result_type, volatile std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_195)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_195)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_195)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_195)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_195)>::arg0_type, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_195)>::arg_type<0>, volatile std::string * const volatile &>);
static_assert(callable_traits<decltype(lambda_195)>::arity == 1);
static_assert(callable_traits<decltype(lambda_195)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_195)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_195)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_195)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_195)>::is_const == false);
static_assert(callable_traits<decltype(lambda_195)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_195)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_195)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_195)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_195)>::class_type, std::remove_const_t<decltype(lambda_195)>>);
[[maybe_unused]] const auto lambda_196 = [](const volatile std::string * const volatile &) -> const volatile std::string * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_196)>::result_type, const volatile std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_196)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_196)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_196)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_196)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_196)>::arg0_type, const volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_196)>::arg_type<0>, const volatile std::string * const volatile &>);
static_assert(callable_traits<decltype(lambda_196)>::arity == 1);
static_assert(callable_traits<decltype(lambda_196)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_196)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_196)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_196)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_196)>::is_const == true);
static_assert(callable_traits<decltype(lambda_196)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_196)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_196)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_196)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_196)>::class_type, std::remove_const_t<decltype(lambda_196)>>);
[[maybe_unused]] const auto lambda_197 = [](std::string &&, ...) mutable -> std::string && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_197)>::result_type, std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_197)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_197)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_197)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_197)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_197)>::arg0_type, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_197)>::arg_type<0>, std::string &&>);
static_assert(callable_traits<decltype(lambda_197)>::arity == 1);
static_assert(callable_traits<decltype(lambda_197)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_197)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_197)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_197)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_197)>::is_const == false);
static_assert(callable_traits<decltype(lambda_197)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_197)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_197)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_197)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_197)>::class_type, std::remove_const_t<decltype(lambda_197)>>);
[[maybe_unused]] const auto lambda_198 = [](const std::string &&) noexcept -> const std::string && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_198)>::result_type, const std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_198)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_198)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_198)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_198)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_198)>::arg0_type, const std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_198)>::arg_type<0>, const std::string &&>);
static_assert(callable_traits<decltype(lambda_198)>::arity == 1);
static_assert(callable_traits<decltype(lambda_198)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_198)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_198)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_198)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_198)>::is_const == true);
static_assert(callable_traits<decltype(lambda_198)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_198)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_198)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_198)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_198)>::class_type, std::remove_const_t<decltype(lambda_198)>>);
[[maybe_unused]] const auto lambda_199 = [](volatile std::string &&, ...) mutable noexcept -> volatile std::string && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_199)>::result_type, volatile std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_199)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_199)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_199)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_199)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_199)>::arg0_type, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_199)>::arg_type<0>, volatile std::string &&>);
static_assert(callable_traits<decltype(lambda_199)>::arity == 1);
static_assert(callable_traits<decltype(lambda_199)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_199)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_199)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_199)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_199)>::is_const == false);
static_assert(callable_traits<decltype(lambda_199)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_199)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_199)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_199)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_199)>::class_type, std::remove_const_t<decltype(lambda_199)>>);
[[maybe_unused]] const auto lambda_200 = [](const volatile std::string &&) -> const volatile std::string && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_200)>::result_type, const volatile std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_200)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_200)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_200)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_200)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_200)>::arg0_type, const volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_200)>::arg_type<0>, const volatile std::string &&>);
static_assert(callable_traits<decltype(lambda_200)>::arity == 1);
static_assert(callable_traits<decltype(lambda_200)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_200)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_200)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_200)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_200)>::is_const == true);
static_assert(callable_traits<decltype(lambda_200)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_200)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_200)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_200)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_200)>::class_type, std::remove_const_t<decltype(lambda_200)>>);
[[maybe_unused]] const auto lambda_201 = [](std::string * &&, ...) mutable -> std::string * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_201)>::result_type, std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_201)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_201)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_201)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_201)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_201)>::arg0_type, std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_201)>::arg_type<0>, std::string * &&>);
static_assert(callable_traits<decltype(lambda_201)>::arity == 1);
static_assert(callable_traits<decltype(lambda_201)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_201)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_201)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_201)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_201)>::is_const == false);
static_assert(callable_traits<decltype(lambda_201)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_201)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_201)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_201)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_201)>::class_type, std::remove_const_t<decltype(lambda_201)>>);
[[maybe_unused]] const auto lambda_202 = [](const std::string * &&) noexcept -> const std::string * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_202)>::result_type, const std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_202)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_202)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_202)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_202)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_202)>::arg0_type, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_202)>::arg_type<0>, const std::string * &&>);
static_assert(callable_traits<decltype(lambda_202)>::arity == 1);
static_assert(callable_traits<decltype(lambda_202)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_202)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_202)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_202)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_202)>::is_const == true);
static_assert(callable_traits<decltype(lambda_202)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_202)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_202)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_202)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_202)>::class_type, std::remove_const_t<decltype(lambda_202)>>);
[[maybe_unused]] const auto lambda_203 = [](volatile std::string * &&, ...) mutable noexcept -> volatile std::string * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_203)>::result_type, volatile std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_203)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_203)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_203)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_203)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_203)>::arg0_type, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_203)>::arg_type<0>, volatile std::string * &&>);
static_assert(callable_traits<decltype(lambda_203)>::arity == 1);
static_assert(callable_traits<decltype(lambda_203)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_203)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_203)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_203)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_203)>::is_const == false);
static_assert(callable_traits<decltype(lambda_203)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_203)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_203)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_203)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_203)>::class_type, std::remove_const_t<decltype(lambda_203)>>);
[[maybe_unused]] const auto lambda_204 = [](const volatile std::string * &&) -> const volatile std::string * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_204)>::result_type, const volatile std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_204)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_204)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_204)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_204)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_204)>::arg0_type, const volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_204)>::arg_type<0>, const volatile std::string * &&>);
static_assert(callable_traits<decltype(lambda_204)>::arity == 1);
static_assert(callable_traits<decltype(lambda_204)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_204)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_204)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_204)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_204)>::is_const == true);
static_assert(callable_traits<decltype(lambda_204)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_204)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_204)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_204)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_204)>::class_type, std::remove_const_t<decltype(lambda_204)>>);
[[maybe_unused]] const auto lambda_205 = [](std::string * const &&, ...) mutable -> std::string * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_205)>::result_type, std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_205)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_205)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_205)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_205)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_205)>::arg0_type, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_205)>::arg_type<0>, std::string * const &&>);
static_assert(callable_traits<decltype(lambda_205)>::arity == 1);
static_assert(callable_traits<decltype(lambda_205)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_205)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_205)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_205)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_205)>::is_const == false);
static_assert(callable_traits<decltype(lambda_205)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_205)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_205)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_205)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_205)>::class_type, std::remove_const_t<decltype(lambda_205)>>);
[[maybe_unused]] const auto lambda_206 = [](const std::string * const &&) noexcept -> const std::string * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_206)>::result_type, const std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_206)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_206)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_206)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_206)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_206)>::arg0_type, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_206)>::arg_type<0>, const std::string * const &&>);
static_assert(callable_traits<decltype(lambda_206)>::arity == 1);
static_assert(callable_traits<decltype(lambda_206)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_206)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_206)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_206)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_206)>::is_const == true);
static_assert(callable_traits<decltype(lambda_206)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_206)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_206)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_206)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_206)>::class_type, std::remove_const_t<decltype(lambda_206)>>);
[[maybe_unused]] const auto lambda_207 = [](volatile std::string * const &&, ...) mutable noexcept -> volatile std::string * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_207)>::result_type, volatile std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_207)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_207)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_207)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_207)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_207)>::arg0_type, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_207)>::arg_type<0>, volatile std::string * const &&>);
static_assert(callable_traits<decltype(lambda_207)>::arity == 1);
static_assert(callable_traits<decltype(lambda_207)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_207)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_207)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_207)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_207)>::is_const == false);
static_assert(callable_traits<decltype(lambda_207)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_207)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_207)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_207)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_207)>::class_type, std::remove_const_t<decltype(lambda_207)>>);
[[maybe_unused]] const auto lambda_208 = [](const volatile std::string * const &&) -> const volatile std::string * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_208)>::result_type, const volatile std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_208)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_208)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_208)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_208)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_208)>::arg0_type, const volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_208)>::arg_type<0>, const volatile std::string * const &&>);
static_assert(callable_traits<decltype(lambda_208)>::arity == 1);
static_assert(callable_traits<decltype(lambda_208)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_208)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_208)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_208)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_208)>::is_const == true);
static_assert(callable_traits<decltype(lambda_208)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_208)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_208)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_208)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_208)>::class_type, std::remove_const_t<decltype(lambda_208)>>);
[[maybe_unused]] const auto lambda_209 = [](std::string * volatile &&, ...) mutable -> std::string * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_209)>::result_type, std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_209)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_209)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_209)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_209)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_209)>::arg0_type, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_209)>::arg_type<0>, std::string * volatile &&>);
static_assert(callable_traits<decltype(lambda_209)>::arity == 1);
static_assert(callable_traits<decltype(lambda_209)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_209)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_209)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_209)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_209)>::is_const == false);
static_assert(callable_traits<decltype(lambda_209)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_209)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_209)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_209)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_209)>::class_type, std::remove_const_t<decltype(lambda_209)>>);
[[maybe_unused]] const auto lambda_210 = [](const std::string * volatile &&) noexcept -> const std::string * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_210)>::result_type, const std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_210)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_210)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_210)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_210)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_210)>::arg0_type, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_210)>::arg_type<0>, const std::string * volatile &&>);
static_assert(callable_traits<decltype(lambda_210)>::arity == 1);
static_assert(callable_traits<decltype(lambda_210)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_210)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_210)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_210)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_210)>::is_const == true);
static_assert(callable_traits<decltype(lambda_210)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_210)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_210)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_210)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_210)>::class_type, std::remove_const_t<decltype(lambda_210)>>);
[[maybe_unused]] const auto lambda_211 = [](volatile std::string * volatile &&, ...) mutable noexcept -> volatile std::string * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_211)>::result_type, volatile std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_211)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_211)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_211)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_211)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_211)>::arg0_type, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_211)>::arg_type<0>, volatile std::string * volatile &&>);
static_assert(callable_traits<decltype(lambda_211)>::arity == 1);
static_assert(callable_traits<decltype(lambda_211)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_211)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_211)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_211)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_211)>::is_const == false);
static_assert(callable_traits<decltype(lambda_211)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_211)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_211)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_211)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_211)>::class_type, std::remove_const_t<decltype(lambda_211)>>);
[[maybe_unused]] const auto lambda_212 = [](const volatile std::string * volatile &&) -> const volatile std::string * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_212)>::result_type, const volatile std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_212)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_212)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_212)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_212)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_212)>::arg0_type, const volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_212)>::arg_type<0>, const volatile std::string * volatile &&>);
static_assert(callable_traits<decltype(lambda_212)>::arity == 1);
static_assert(callable_traits<decltype(lambda_212)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_212)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_212)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_212)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_212)>::is_const == true);
static_assert(callable_traits<decltype(lambda_212)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_212)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_212)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_212)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_212)>::class_type, std::remove_const_t<decltype(lambda_212)>>);
[[maybe_unused]] const auto lambda_213 = [](std::string * const volatile &&, ...) mutable -> std::string * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_213)>::result_type, std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_213)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_213)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_213)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_213)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_213)>::arg0_type, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_213)>::arg_type<0>, std::string * const volatile &&>);
static_assert(callable_traits<decltype(lambda_213)>::arity == 1);
static_assert(callable_traits<decltype(lambda_213)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_213)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_213)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_213)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_213)>::is_const == false);
static_assert(callable_traits<decltype(lambda_213)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_213)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_213)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_213)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_213)>::class_type, std::remove_const_t<decltype(lambda_213)>>);
[[maybe_unused]] const auto lambda_214 = [](const std::string * const volatile &&) noexcept -> const std::string * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_214)>::result_type, const std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_214)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_214)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_214)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_214)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_214)>::arg0_type, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_214)>::arg_type<0>, const std::string * const volatile &&>);
static_assert(callable_traits<decltype(lambda_214)>::arity == 1);
static_assert(callable_traits<decltype(lambda_214)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_214)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_214)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_214)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_214)>::is_const == true);
static_assert(callable_traits<decltype(lambda_214)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_214)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_214)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_214)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_214)>::class_type, std::remove_const_t<decltype(lambda_214)>>);
[[maybe_unused]] const auto lambda_215 = [](volatile std::string * const volatile &&, ...) mutable noexcept -> volatile std::string * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_215)>::result_type, volatile std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_215)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_215)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_215)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_215)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_215)>::arg0_type, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_215)>::arg_type<0>, volatile std::string * const volatile &&>);
static_assert(callable_traits<decltype(lambda_215)>::arity == 1);
static_assert(callable_traits<decltype(lambda_215)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_215)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_215)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_215)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_215)>::is_const == false);
static_assert(callable_traits<decltype(lambda_215)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_215)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_215)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_215)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_215)>::class_type, std::remove_const_t<decltype(lambda_215)>>);
[[maybe_unused]] const auto lambda_216 = [](const volatile std::string * const volatile &&) -> const volatile std::string * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_216)>::result_type, const volatile std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_216)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_216)>> == false);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_216)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_216)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_216)>::arg0_type, const volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_216)>::arg_type<0>, const volatile std::string * const volatile &&>);
static_assert(callable_traits<decltype(lambda_216)>::arity == 1);
static_assert(callable_traits<decltype(lambda_216)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_216)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_216)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_216)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_216)>::is_const == true);
static_assert(callable_traits<decltype(lambda_216)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_216)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_216)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_216)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_216)>::class_type, std::remove_const_t<decltype(lambda_216)>>);
[[maybe_unused]] const auto lambda_217 = [](void *, const void *, ...) mutable -> void {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_217)>::result_type, void>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_217)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_217)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_217)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_217)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_217)>::arg0_type, void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_217)>::arg_type<0>, void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_217)>::arg1_type, const void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_217)>::arg_type<1>, const void *>);
static_assert(callable_traits<decltype(lambda_217)>::arity == 2);
static_assert(callable_traits<decltype(lambda_217)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_217)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_217)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_217)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_217)>::is_const == false);
static_assert(callable_traits<decltype(lambda_217)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_217)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_217)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_217)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_217)>::class_type, std::remove_const_t<decltype(lambda_217)>>);
[[maybe_unused]] const auto lambda_218 = [](volatile void *, const volatile void *) noexcept -> void * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_218)>::result_type, void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_218)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_218)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_218)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_218)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_218)>::arg0_type, volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_218)>::arg_type<0>, volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_218)>::arg1_type, const volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_218)>::arg_type<1>, const volatile void *>);
static_assert(callable_traits<decltype(lambda_218)>::arity == 2);
static_assert(callable_traits<decltype(lambda_218)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_218)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_218)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_218)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_218)>::is_const == true);
static_assert(callable_traits<decltype(lambda_218)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_218)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_218)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_218)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_218)>::class_type, std::remove_const_t<decltype(lambda_218)>>);
[[maybe_unused]] const auto lambda_219 = [](void * &, const void * &, ...) mutable noexcept -> const void * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_219)>::result_type, const void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_219)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_219)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_219)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_219)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_219)>::arg0_type, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_219)>::arg_type<0>, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_219)>::arg1_type, const void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_219)>::arg_type<1>, const void * &>);
static_assert(callable_traits<decltype(lambda_219)>::arity == 2);
static_assert(callable_traits<decltype(lambda_219)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_219)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_219)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_219)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_219)>::is_const == false);
static_assert(callable_traits<decltype(lambda_219)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_219)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_219)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_219)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_219)>::class_type, std::remove_const_t<decltype(lambda_219)>>);
[[maybe_unused]] const auto lambda_220 = [](volatile void * &, const volatile void * &) -> volatile void * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_220)>::result_type, volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_220)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_220)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_220)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_220)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_220)>::arg0_type, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_220)>::arg_type<0>, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_220)>::arg1_type, const volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_220)>::arg_type<1>, const volatile void * &>);
static_assert(callable_traits<decltype(lambda_220)>::arity == 2);
static_assert(callable_traits<decltype(lambda_220)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_220)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_220)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_220)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_220)>::is_const == true);
static_assert(callable_traits<decltype(lambda_220)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_220)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_220)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_220)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_220)>::class_type, std::remove_const_t<decltype(lambda_220)>>);
[[maybe_unused]] const auto lambda_221 = [](void * const &, const void * const &, ...) mutable -> const volatile void * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_221)>::result_type, const volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_221)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_221)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_221)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_221)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_221)>::arg0_type, void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_221)>::arg_type<0>, void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_221)>::arg1_type, const void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_221)>::arg_type<1>, const void * const &>);
static_assert(callable_traits<decltype(lambda_221)>::arity == 2);
static_assert(callable_traits<decltype(lambda_221)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_221)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_221)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_221)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_221)>::is_const == false);
static_assert(callable_traits<decltype(lambda_221)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_221)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_221)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_221)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_221)>::class_type, std::remove_const_t<decltype(lambda_221)>>);
[[maybe_unused]] const auto lambda_222 = [](volatile void * const &, const volatile void * const &) noexcept -> void * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_222)>::result_type, void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_222)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_222)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_222)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_222)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_222)>::arg0_type, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_222)>::arg_type<0>, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_222)>::arg1_type, const volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_222)>::arg_type<1>, const volatile void * const &>);
static_assert(callable_traits<decltype(lambda_222)>::arity == 2);
static_assert(callable_traits<decltype(lambda_222)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_222)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_222)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_222)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_222)>::is_const == true);
static_assert(callable_traits<decltype(lambda_222)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_222)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_222)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_222)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_222)>::class_type, std::remove_const_t<decltype(lambda_222)>>);
[[maybe_unused]] const auto lambda_223 = [](void * volatile &, const void * volatile &, ...) mutable noexcept -> const void * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_223)>::result_type, const void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_223)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_223)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_223)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_223)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_223)>::arg0_type, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_223)>::arg_type<0>, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_223)>::arg1_type, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_223)>::arg_type<1>, const void * volatile &>);
static_assert(callable_traits<decltype(lambda_223)>::arity == 2);
static_assert(callable_traits<decltype(lambda_223)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_223)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_223)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_223)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_223)>::is_const == false);
static_assert(callable_traits<decltype(lambda_223)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_223)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_223)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_223)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_223)>::class_type, std::remove_const_t<decltype(lambda_223)>>);
[[maybe_unused]] const auto lambda_224 = [](volatile void * volatile &, const volatile void * volatile &) -> volatile void * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_224)>::result_type, volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_224)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_224)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_224)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_224)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_224)>::arg0_type, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_224)>::arg_type<0>, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_224)>::arg1_type, const volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_224)>::arg_type<1>, const volatile void * volatile &>);
static_assert(callable_traits<decltype(lambda_224)>::arity == 2);
static_assert(callable_traits<decltype(lambda_224)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_224)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_224)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_224)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_224)>::is_const == true);
static_assert(callable_traits<decltype(lambda_224)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_224)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_224)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_224)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_224)>::class_type, std::remove_const_t<decltype(lambda_224)>>);
[[maybe_unused]] const auto lambda_225 = [](void * const volatile &, const void * const volatile &, ...) mutable -> const volatile void * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_225)>::result_type, const volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_225)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_225)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_225)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_225)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_225)>::arg0_type, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_225)>::arg_type<0>, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_225)>::arg1_type, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_225)>::arg_type<1>, const void * const volatile &>);
static_assert(callable_traits<decltype(lambda_225)>::arity == 2);
static_assert(callable_traits<decltype(lambda_225)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_225)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_225)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_225)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_225)>::is_const == false);
static_assert(callable_traits<decltype(lambda_225)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_225)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_225)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_225)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_225)>::class_type, std::remove_const_t<decltype(lambda_225)>>);
[[maybe_unused]] const auto lambda_226 = [](volatile void * const volatile &, const volatile void * const volatile &) noexcept -> void * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_226)>::result_type, void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_226)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_226)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_226)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_226)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_226)>::arg0_type, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_226)>::arg_type<0>, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_226)>::arg1_type, const volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_226)>::arg_type<1>, const volatile void * const volatile &>);
static_assert(callable_traits<decltype(lambda_226)>::arity == 2);
static_assert(callable_traits<decltype(lambda_226)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_226)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_226)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_226)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_226)>::is_const == true);
static_assert(callable_traits<decltype(lambda_226)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_226)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_226)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_226)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_226)>::class_type, std::remove_const_t<decltype(lambda_226)>>);
[[maybe_unused]] const auto lambda_227 = [](void * &&, const void * &&, ...) mutable noexcept -> const void * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_227)>::result_type, const void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_227)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_227)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_227)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_227)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_227)>::arg0_type, void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_227)>::arg_type<0>, void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_227)>::arg1_type, const void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_227)>::arg_type<1>, const void * &&>);
static_assert(callable_traits<decltype(lambda_227)>::arity == 2);
static_assert(callable_traits<decltype(lambda_227)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_227)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_227)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_227)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_227)>::is_const == false);
static_assert(callable_traits<decltype(lambda_227)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_227)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_227)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_227)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_227)>::class_type, std::remove_const_t<decltype(lambda_227)>>);
[[maybe_unused]] const auto lambda_228 = [](volatile void * &&, const volatile void * &&) -> volatile void * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_228)>::result_type, volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_228)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_228)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_228)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_228)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_228)>::arg0_type, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_228)>::arg_type<0>, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_228)>::arg1_type, const volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_228)>::arg_type<1>, const volatile void * &&>);
static_assert(callable_traits<decltype(lambda_228)>::arity == 2);
static_assert(callable_traits<decltype(lambda_228)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_228)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_228)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_228)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_228)>::is_const == true);
static_assert(callable_traits<decltype(lambda_228)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_228)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_228)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_228)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_228)>::class_type, std::remove_const_t<decltype(lambda_228)>>);
[[maybe_unused]] const auto lambda_229 = [](void * const &&, const void * const &&, ...) mutable -> const volatile void * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_229)>::result_type, const volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_229)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_229)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_229)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_229)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_229)>::arg0_type, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_229)>::arg_type<0>, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_229)>::arg1_type, const void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_229)>::arg_type<1>, const void * const &&>);
static_assert(callable_traits<decltype(lambda_229)>::arity == 2);
static_assert(callable_traits<decltype(lambda_229)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_229)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_229)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_229)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_229)>::is_const == false);
static_assert(callable_traits<decltype(lambda_229)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_229)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_229)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_229)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_229)>::class_type, std::remove_const_t<decltype(lambda_229)>>);
[[maybe_unused]] const auto lambda_230 = [](volatile void * const &&, const volatile void * const &&) noexcept -> void * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_230)>::result_type, void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_230)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_230)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_230)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_230)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_230)>::arg0_type, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_230)>::arg_type<0>, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_230)>::arg1_type, const volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_230)>::arg_type<1>, const volatile void * const &&>);
static_assert(callable_traits<decltype(lambda_230)>::arity == 2);
static_assert(callable_traits<decltype(lambda_230)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_230)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_230)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_230)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_230)>::is_const == true);
static_assert(callable_traits<decltype(lambda_230)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_230)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_230)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_230)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_230)>::class_type, std::remove_const_t<decltype(lambda_230)>>);
[[maybe_unused]] const auto lambda_231 = [](void * volatile &&, const void * volatile &&, ...) mutable noexcept -> const void * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_231)>::result_type, const void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_231)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_231)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_231)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_231)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_231)>::arg0_type, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_231)>::arg_type<0>, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_231)>::arg1_type, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_231)>::arg_type<1>, const void * volatile &&>);
static_assert(callable_traits<decltype(lambda_231)>::arity == 2);
static_assert(callable_traits<decltype(lambda_231)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_231)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_231)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_231)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_231)>::is_const == false);
static_assert(callable_traits<decltype(lambda_231)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_231)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_231)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_231)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_231)>::class_type, std::remove_const_t<decltype(lambda_231)>>);
[[maybe_unused]] const auto lambda_232 = [](volatile void * volatile &&, const volatile void * volatile &&) -> volatile void * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_232)>::result_type, volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_232)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_232)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_232)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_232)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_232)>::arg0_type, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_232)>::arg_type<0>, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_232)>::arg1_type, const volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_232)>::arg_type<1>, const volatile void * volatile &&>);
static_assert(callable_traits<decltype(lambda_232)>::arity == 2);
static_assert(callable_traits<decltype(lambda_232)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_232)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_232)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_232)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_232)>::is_const == true);
static_assert(callable_traits<decltype(lambda_232)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_232)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_232)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_232)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_232)>::class_type, std::remove_const_t<decltype(lambda_232)>>);
[[maybe_unused]] const auto lambda_233 = [](void * const volatile &&, const void * const volatile &&, ...) mutable -> const volatile void * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_233)>::result_type, const volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_233)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_233)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_233)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_233)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_233)>::arg0_type, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_233)>::arg_type<0>, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_233)>::arg1_type, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_233)>::arg_type<1>, const void * const volatile &&>);
static_assert(callable_traits<decltype(lambda_233)>::arity == 2);
static_assert(callable_traits<decltype(lambda_233)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_233)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_233)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_233)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_233)>::is_const == false);
static_assert(callable_traits<decltype(lambda_233)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_233)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_233)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_233)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_233)>::class_type, std::remove_const_t<decltype(lambda_233)>>);
[[maybe_unused]] const auto lambda_234 = [](volatile void * const volatile &&, const volatile void * const volatile &&) noexcept -> void * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_234)>::result_type, void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_234)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_234)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_234)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_234)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_234)>::arg0_type, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_234)>::arg_type<0>, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_234)>::arg1_type, const volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_234)>::arg_type<1>, const volatile void * const volatile &&>);
static_assert(callable_traits<decltype(lambda_234)>::arity == 2);
static_assert(callable_traits<decltype(lambda_234)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_234)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_234)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_234)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_234)>::is_const == true);
static_assert(callable_traits<decltype(lambda_234)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_234)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_234)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_234)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_234)>::class_type, std::remove_const_t<decltype(lambda_234)>>);
[[maybe_unused]] const auto lambda_235 = [](bool, bool *, ...) mutable noexcept -> const void * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_235)>::result_type, const void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_235)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_235)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_235)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_235)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_235)>::arg0_type, bool>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_235)>::arg_type<0>, bool>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_235)>::arg1_type, bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_235)>::arg_type<1>, bool *>);
static_assert(callable_traits<decltype(lambda_235)>::arity == 2);
static_assert(callable_traits<decltype(lambda_235)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_235)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_235)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_235)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_235)>::is_const == false);
static_assert(callable_traits<decltype(lambda_235)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_235)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_235)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_235)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_235)>::class_type, std::remove_const_t<decltype(lambda_235)>>);
[[maybe_unused]] const auto lambda_236 = [](const bool *, volatile bool *) -> volatile void * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_236)>::result_type, volatile void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_236)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_236)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_236)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_236)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_236)>::arg0_type, const bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_236)>::arg_type<0>, const bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_236)>::arg1_type, volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_236)>::arg_type<1>, volatile bool *>);
static_assert(callable_traits<decltype(lambda_236)>::arity == 2);
static_assert(callable_traits<decltype(lambda_236)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_236)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_236)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_236)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_236)>::is_const == true);
static_assert(callable_traits<decltype(lambda_236)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_236)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_236)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_236)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_236)>::class_type, std::remove_const_t<decltype(lambda_236)>>);
[[maybe_unused]] const auto lambda_237 = [](const volatile bool *, bool &, ...) mutable -> const volatile void * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_237)>::result_type, const volatile void * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_237)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_237)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_237)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_237)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_237)>::arg0_type, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_237)>::arg_type<0>, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_237)>::arg1_type, bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_237)>::arg_type<1>, bool &>);
static_assert(callable_traits<decltype(lambda_237)>::arity == 2);
static_assert(callable_traits<decltype(lambda_237)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_237)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_237)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_237)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_237)>::is_const == false);
static_assert(callable_traits<decltype(lambda_237)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_237)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_237)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_237)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_237)>::class_type, std::remove_const_t<decltype(lambda_237)>>);
[[maybe_unused]] const auto lambda_238 = [](const bool &, volatile bool &) noexcept -> void * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_238)>::result_type, void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_238)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_238)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_238)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_238)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_238)>::arg0_type, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_238)>::arg_type<0>, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_238)>::arg1_type, volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_238)>::arg_type<1>, volatile bool &>);
static_assert(callable_traits<decltype(lambda_238)>::arity == 2);
static_assert(callable_traits<decltype(lambda_238)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_238)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_238)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_238)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_238)>::is_const == true);
static_assert(callable_traits<decltype(lambda_238)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_238)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_238)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_238)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_238)>::class_type, std::remove_const_t<decltype(lambda_238)>>);
[[maybe_unused]] const auto lambda_239 = [](const volatile bool &, bool * &, ...) mutable noexcept -> const void * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_239)>::result_type, const void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_239)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_239)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_239)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_239)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_239)>::arg0_type, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_239)>::arg_type<0>, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_239)>::arg1_type, bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_239)>::arg_type<1>, bool * &>);
static_assert(callable_traits<decltype(lambda_239)>::arity == 2);
static_assert(callable_traits<decltype(lambda_239)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_239)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_239)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_239)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_239)>::is_const == false);
static_assert(callable_traits<decltype(lambda_239)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_239)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_239)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_239)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_239)>::class_type, std::remove_const_t<decltype(lambda_239)>>);
[[maybe_unused]] const auto lambda_240 = [](const bool * &, volatile bool * &) -> volatile void * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_240)>::result_type, volatile void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_240)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_240)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_240)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_240)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_240)>::arg0_type, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_240)>::arg_type<0>, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_240)>::arg1_type, volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_240)>::arg_type<1>, volatile bool * &>);
static_assert(callable_traits<decltype(lambda_240)>::arity == 2);
static_assert(callable_traits<decltype(lambda_240)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_240)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_240)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_240)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_240)>::is_const == true);
static_assert(callable_traits<decltype(lambda_240)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_240)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_240)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_240)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_240)>::class_type, std::remove_const_t<decltype(lambda_240)>>);
[[maybe_unused]] const auto lambda_241 = [](const volatile bool * &, bool * const &, ...) mutable -> const volatile void * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_241)>::result_type, const volatile void * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_241)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_241)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_241)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_241)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_241)>::arg0_type, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_241)>::arg_type<0>, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_241)>::arg1_type, bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_241)>::arg_type<1>, bool * const &>);
static_assert(callable_traits<decltype(lambda_241)>::arity == 2);
static_assert(callable_traits<decltype(lambda_241)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_241)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_241)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_241)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_241)>::is_const == false);
static_assert(callable_traits<decltype(lambda_241)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_241)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_241)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_241)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_241)>::class_type, std::remove_const_t<decltype(lambda_241)>>);
[[maybe_unused]] const auto lambda_242 = [](const bool * const &, volatile bool * const &) noexcept -> void * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_242)>::result_type, void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_242)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_242)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_242)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_242)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_242)>::arg0_type, const bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_242)>::arg_type<0>, const bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_242)>::arg1_type, volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_242)>::arg_type<1>, volatile bool * const &>);
static_assert(callable_traits<decltype(lambda_242)>::arity == 2);
static_assert(callable_traits<decltype(lambda_242)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_242)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_242)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_242)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_242)>::is_const == true);
static_assert(callable_traits<decltype(lambda_242)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_242)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_242)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_242)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_242)>::class_type, std::remove_const_t<decltype(lambda_242)>>);
[[maybe_unused]] const auto lambda_243 = [](const volatile bool * const &, bool * volatile &, ...) mutable noexcept -> const void * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_243)>::result_type, const void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_243)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_243)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_243)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_243)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_243)>::arg0_type, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_243)>::arg_type<0>, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_243)>::arg1_type, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_243)>::arg_type<1>, bool * volatile &>);
static_assert(callable_traits<decltype(lambda_243)>::arity == 2);
static_assert(callable_traits<decltype(lambda_243)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_243)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_243)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_243)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_243)>::is_const == false);
static_assert(callable_traits<decltype(lambda_243)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_243)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_243)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_243)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_243)>::class_type, std::remove_const_t<decltype(lambda_243)>>);
[[maybe_unused]] const auto lambda_244 = [](const bool * volatile &, volatile bool * volatile &) -> volatile void * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_244)>::result_type, volatile void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_244)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_244)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_244)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_244)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_244)>::arg0_type, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_244)>::arg_type<0>, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_244)>::arg1_type, volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_244)>::arg_type<1>, volatile bool * volatile &>);
static_assert(callable_traits<decltype(lambda_244)>::arity == 2);
static_assert(callable_traits<decltype(lambda_244)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_244)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_244)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_244)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_244)>::is_const == true);
static_assert(callable_traits<decltype(lambda_244)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_244)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_244)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_244)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_244)>::class_type, std::remove_const_t<decltype(lambda_244)>>);
[[maybe_unused]] const auto lambda_245 = [](const volatile bool * volatile &, bool * const volatile &, ...) mutable -> const volatile void * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_245)>::result_type, const volatile void * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_245)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_245)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_245)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_245)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_245)>::arg0_type, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_245)>::arg_type<0>, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_245)>::arg1_type, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_245)>::arg_type<1>, bool * const volatile &>);
static_assert(callable_traits<decltype(lambda_245)>::arity == 2);
static_assert(callable_traits<decltype(lambda_245)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_245)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_245)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_245)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_245)>::is_const == false);
static_assert(callable_traits<decltype(lambda_245)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_245)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_245)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_245)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_245)>::class_type, std::remove_const_t<decltype(lambda_245)>>);
[[maybe_unused]] const auto lambda_246 = [](const bool * const volatile &, volatile bool * const volatile &) noexcept -> void * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_246)>::result_type, void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_246)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_246)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_246)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_246)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_246)>::arg0_type, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_246)>::arg_type<0>, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_246)>::arg1_type, volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_246)>::arg_type<1>, volatile bool * const volatile &>);
static_assert(callable_traits<decltype(lambda_246)>::arity == 2);
static_assert(callable_traits<decltype(lambda_246)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_246)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_246)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_246)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_246)>::is_const == true);
static_assert(callable_traits<decltype(lambda_246)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_246)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_246)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_246)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_246)>::class_type, std::remove_const_t<decltype(lambda_246)>>);
[[maybe_unused]] const auto lambda_247 = [](const volatile bool * const volatile &, bool &&, ...) mutable noexcept -> const void * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_247)>::result_type, const void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_247)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_247)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_247)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_247)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_247)>::arg0_type, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_247)>::arg_type<0>, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_247)>::arg1_type, bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_247)>::arg_type<1>, bool &&>);
static_assert(callable_traits<decltype(lambda_247)>::arity == 2);
static_assert(callable_traits<decltype(lambda_247)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_247)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_247)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_247)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_247)>::is_const == false);
static_assert(callable_traits<decltype(lambda_247)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_247)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_247)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_247)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_247)>::class_type, std::remove_const_t<decltype(lambda_247)>>);
[[maybe_unused]] const auto lambda_248 = [](const bool &&, volatile bool &&) -> volatile void * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_248)>::result_type, volatile void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_248)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_248)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_248)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_248)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_248)>::arg0_type, const bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_248)>::arg_type<0>, const bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_248)>::arg1_type, volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_248)>::arg_type<1>, volatile bool &&>);
static_assert(callable_traits<decltype(lambda_248)>::arity == 2);
static_assert(callable_traits<decltype(lambda_248)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_248)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_248)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_248)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_248)>::is_const == true);
static_assert(callable_traits<decltype(lambda_248)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_248)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_248)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_248)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_248)>::class_type, std::remove_const_t<decltype(lambda_248)>>);
[[maybe_unused]] const auto lambda_249 = [](const volatile bool &&, bool * &&, ...) mutable -> const volatile void * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_249)>::result_type, const volatile void * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_249)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_249)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_249)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_249)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_249)>::arg0_type, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_249)>::arg_type<0>, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_249)>::arg1_type, bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_249)>::arg_type<1>, bool * &&>);
static_assert(callable_traits<decltype(lambda_249)>::arity == 2);
static_assert(callable_traits<decltype(lambda_249)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_249)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_249)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_249)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_249)>::is_const == false);
static_assert(callable_traits<decltype(lambda_249)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_249)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_249)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_249)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_249)>::class_type, std::remove_const_t<decltype(lambda_249)>>);
[[maybe_unused]] const auto lambda_250 = [](const bool * &&, volatile bool * &&) noexcept -> void * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_250)>::result_type, void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_250)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_250)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_250)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_250)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_250)>::arg0_type, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_250)>::arg_type<0>, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_250)>::arg1_type, volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_250)>::arg_type<1>, volatile bool * &&>);
static_assert(callable_traits<decltype(lambda_250)>::arity == 2);
static_assert(callable_traits<decltype(lambda_250)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_250)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_250)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_250)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_250)>::is_const == true);
static_assert(callable_traits<decltype(lambda_250)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_250)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_250)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_250)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_250)>::class_type, std::remove_const_t<decltype(lambda_250)>>);
[[maybe_unused]] const auto lambda_251 = [](const volatile bool * &&, bool * const &&, ...) mutable noexcept -> const void * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_251)>::result_type, const void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_251)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_251)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_251)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_251)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_251)>::arg0_type, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_251)>::arg_type<0>, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_251)>::arg1_type, bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_251)>::arg_type<1>, bool * const &&>);
static_assert(callable_traits<decltype(lambda_251)>::arity == 2);
static_assert(callable_traits<decltype(lambda_251)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_251)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_251)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_251)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_251)>::is_const == false);
static_assert(callable_traits<decltype(lambda_251)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_251)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_251)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_251)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_251)>::class_type, std::remove_const_t<decltype(lambda_251)>>);
[[maybe_unused]] const auto lambda_252 = [](const bool * const &&, volatile bool * const &&) -> volatile void * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_252)>::result_type, volatile void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_252)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_252)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_252)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_252)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_252)>::arg0_type, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_252)>::arg_type<0>, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_252)>::arg1_type, volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_252)>::arg_type<1>, volatile bool * const &&>);
static_assert(callable_traits<decltype(lambda_252)>::arity == 2);
static_assert(callable_traits<decltype(lambda_252)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_252)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_252)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_252)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_252)>::is_const == true);
static_assert(callable_traits<decltype(lambda_252)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_252)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_252)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_252)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_252)>::class_type, std::remove_const_t<decltype(lambda_252)>>);
[[maybe_unused]] const auto lambda_253 = [](const volatile bool * const &&, bool * volatile &&, ...) mutable -> const volatile void * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_253)>::result_type, const volatile void * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_253)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_253)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_253)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_253)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_253)>::arg0_type, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_253)>::arg_type<0>, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_253)>::arg1_type, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_253)>::arg_type<1>, bool * volatile &&>);
static_assert(callable_traits<decltype(lambda_253)>::arity == 2);
static_assert(callable_traits<decltype(lambda_253)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_253)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_253)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_253)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_253)>::is_const == false);
static_assert(callable_traits<decltype(lambda_253)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_253)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_253)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_253)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_253)>::class_type, std::remove_const_t<decltype(lambda_253)>>);
[[maybe_unused]] const auto lambda_254 = [](const bool * volatile &&, volatile bool * volatile &&) noexcept -> bool {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_254)>::result_type, bool>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_254)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_254)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_254)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_254)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_254)>::arg0_type, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_254)>::arg_type<0>, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_254)>::arg1_type, volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_254)>::arg_type<1>, volatile bool * volatile &&>);
static_assert(callable_traits<decltype(lambda_254)>::arity == 2);
static_assert(callable_traits<decltype(lambda_254)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_254)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_254)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_254)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_254)>::is_const == true);
static_assert(callable_traits<decltype(lambda_254)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_254)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_254)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_254)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_254)>::class_type, std::remove_const_t<decltype(lambda_254)>>);
[[maybe_unused]] const auto lambda_255 = [](const volatile bool * volatile &&, bool * const volatile &&, ...) mutable noexcept -> bool * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_255)>::result_type, bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_255)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_255)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_255)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_255)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_255)>::arg0_type, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_255)>::arg_type<0>, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_255)>::arg1_type, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_255)>::arg_type<1>, bool * const volatile &&>);
static_assert(callable_traits<decltype(lambda_255)>::arity == 2);
static_assert(callable_traits<decltype(lambda_255)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_255)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_255)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_255)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_255)>::is_const == false);
static_assert(callable_traits<decltype(lambda_255)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_255)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_255)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_255)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_255)>::class_type, std::remove_const_t<decltype(lambda_255)>>);
[[maybe_unused]] const auto lambda_256 = [](const bool * const volatile &&, volatile bool * const volatile &&) -> const bool * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_256)>::result_type, const bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_256)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_256)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_256)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_256)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_256)>::arg0_type, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_256)>::arg_type<0>, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_256)>::arg1_type, volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_256)>::arg_type<1>, volatile bool * const volatile &&>);
static_assert(callable_traits<decltype(lambda_256)>::arity == 2);
static_assert(callable_traits<decltype(lambda_256)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_256)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_256)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_256)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_256)>::is_const == true);
static_assert(callable_traits<decltype(lambda_256)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_256)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_256)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_256)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_256)>::class_type, std::remove_const_t<decltype(lambda_256)>>);
[[maybe_unused]] const auto lambda_257 = [](const volatile bool * const volatile &&, int, ...) mutable -> volatile bool * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_257)>::result_type, volatile bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_257)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_257)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_257)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_257)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_257)>::arg0_type, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_257)>::arg_type<0>, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_257)>::arg1_type, int>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_257)>::arg_type<1>, int>);
static_assert(callable_traits<decltype(lambda_257)>::arity == 2);
static_assert(callable_traits<decltype(lambda_257)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_257)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_257)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_257)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_257)>::is_const == false);
static_assert(callable_traits<decltype(lambda_257)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_257)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_257)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_257)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_257)>::class_type, std::remove_const_t<decltype(lambda_257)>>);
[[maybe_unused]] const auto lambda_258 = [](int *, const int *) noexcept -> const volatile bool * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_258)>::result_type, const volatile bool *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_258)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_258)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_258)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_258)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_258)>::arg0_type, int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_258)>::arg_type<0>, int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_258)>::arg1_type, const int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_258)>::arg_type<1>, const int *>);
static_assert(callable_traits<decltype(lambda_258)>::arity == 2);
static_assert(callable_traits<decltype(lambda_258)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_258)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_258)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_258)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_258)>::is_const == true);
static_assert(callable_traits<decltype(lambda_258)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_258)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_258)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_258)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_258)>::class_type, std::remove_const_t<decltype(lambda_258)>>);
[[maybe_unused]] const auto lambda_259 = [](volatile int *, const volatile int *, ...) mutable noexcept -> bool & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_259)>::result_type, bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_259)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_259)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_259)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_259)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_259)>::arg0_type, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_259)>::arg_type<0>, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_259)>::arg1_type, const volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_259)>::arg_type<1>, const volatile int *>);
static_assert(callable_traits<decltype(lambda_259)>::arity == 2);
static_assert(callable_traits<decltype(lambda_259)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_259)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_259)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_259)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_259)>::is_const == false);
static_assert(callable_traits<decltype(lambda_259)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_259)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_259)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_259)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_259)>::class_type, std::remove_const_t<decltype(lambda_259)>>);
[[maybe_unused]] const auto lambda_260 = [](int &, const int &) -> const bool & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_260)>::result_type, const bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_260)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_260)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_260)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_260)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_260)>::arg0_type, int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_260)>::arg_type<0>, int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_260)>::arg1_type, const int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_260)>::arg_type<1>, const int &>);
static_assert(callable_traits<decltype(lambda_260)>::arity == 2);
static_assert(callable_traits<decltype(lambda_260)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_260)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_260)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_260)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_260)>::is_const == true);
static_assert(callable_traits<decltype(lambda_260)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_260)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_260)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_260)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_260)>::class_type, std::remove_const_t<decltype(lambda_260)>>);
[[maybe_unused]] const auto lambda_261 = [](volatile int &, const volatile int &, ...) mutable -> volatile bool & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_261)>::result_type, volatile bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_261)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_261)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_261)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_261)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_261)>::arg0_type, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_261)>::arg_type<0>, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_261)>::arg1_type, const volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_261)>::arg_type<1>, const volatile int &>);
static_assert(callable_traits<decltype(lambda_261)>::arity == 2);
static_assert(callable_traits<decltype(lambda_261)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_261)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_261)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_261)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_261)>::is_const == false);
static_assert(callable_traits<decltype(lambda_261)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_261)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_261)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_261)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_261)>::class_type, std::remove_const_t<decltype(lambda_261)>>);
[[maybe_unused]] const auto lambda_262 = [](int * &, const int * &) noexcept -> const volatile bool & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_262)>::result_type, const volatile bool &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_262)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_262)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_262)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_262)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_262)>::arg0_type, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_262)>::arg_type<0>, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_262)>::arg1_type, const int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_262)>::arg_type<1>, const int * &>);
static_assert(callable_traits<decltype(lambda_262)>::arity == 2);
static_assert(callable_traits<decltype(lambda_262)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_262)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_262)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_262)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_262)>::is_const == true);
static_assert(callable_traits<decltype(lambda_262)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_262)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_262)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_262)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_262)>::class_type, std::remove_const_t<decltype(lambda_262)>>);
[[maybe_unused]] const auto lambda_263 = [](volatile int * &, const volatile int * &, ...) mutable noexcept -> bool * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_263)>::result_type, bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_263)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_263)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_263)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_263)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_263)>::arg0_type, volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_263)>::arg_type<0>, volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_263)>::arg1_type, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_263)>::arg_type<1>, const volatile int * &>);
static_assert(callable_traits<decltype(lambda_263)>::arity == 2);
static_assert(callable_traits<decltype(lambda_263)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_263)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_263)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_263)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_263)>::is_const == false);
static_assert(callable_traits<decltype(lambda_263)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_263)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_263)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_263)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_263)>::class_type, std::remove_const_t<decltype(lambda_263)>>);
[[maybe_unused]] const auto lambda_264 = [](int * const &, const int * const &) -> const bool * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_264)>::result_type, const bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_264)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_264)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_264)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_264)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_264)>::arg0_type, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_264)>::arg_type<0>, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_264)>::arg1_type, const int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_264)>::arg_type<1>, const int * const &>);
static_assert(callable_traits<decltype(lambda_264)>::arity == 2);
static_assert(callable_traits<decltype(lambda_264)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_264)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_264)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_264)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_264)>::is_const == true);
static_assert(callable_traits<decltype(lambda_264)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_264)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_264)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_264)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_264)>::class_type, std::remove_const_t<decltype(lambda_264)>>);
[[maybe_unused]] const auto lambda_265 = [](volatile int * const &, const volatile int * const &, ...) mutable -> volatile bool * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_265)>::result_type, volatile bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_265)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_265)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_265)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_265)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_265)>::arg0_type, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_265)>::arg_type<0>, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_265)>::arg1_type, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_265)>::arg_type<1>, const volatile int * const &>);
static_assert(callable_traits<decltype(lambda_265)>::arity == 2);
static_assert(callable_traits<decltype(lambda_265)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_265)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_265)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_265)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_265)>::is_const == false);
static_assert(callable_traits<decltype(lambda_265)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_265)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_265)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_265)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_265)>::class_type, std::remove_const_t<decltype(lambda_265)>>);
[[maybe_unused]] const auto lambda_266 = [](int * volatile &, const int * volatile &) noexcept -> const volatile bool * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_266)>::result_type, const volatile bool * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_266)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_266)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_266)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_266)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_266)>::arg0_type, int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_266)>::arg_type<0>, int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_266)>::arg1_type, const int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_266)>::arg_type<1>, const int * volatile &>);
static_assert(callable_traits<decltype(lambda_266)>::arity == 2);
static_assert(callable_traits<decltype(lambda_266)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_266)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_266)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_266)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_266)>::is_const == true);
static_assert(callable_traits<decltype(lambda_266)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_266)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_266)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_266)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_266)>::class_type, std::remove_const_t<decltype(lambda_266)>>);
[[maybe_unused]] const auto lambda_267 = [](volatile int * volatile &, const volatile int * volatile &, ...) mutable noexcept -> bool * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_267)>::result_type, bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_267)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_267)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_267)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_267)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_267)>::arg0_type, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_267)>::arg_type<0>, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_267)>::arg1_type, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_267)>::arg_type<1>, const volatile int * volatile &>);
static_assert(callable_traits<decltype(lambda_267)>::arity == 2);
static_assert(callable_traits<decltype(lambda_267)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_267)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_267)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_267)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_267)>::is_const == false);
static_assert(callable_traits<decltype(lambda_267)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_267)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_267)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_267)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_267)>::class_type, std::remove_const_t<decltype(lambda_267)>>);
[[maybe_unused]] const auto lambda_268 = [](int * const volatile &, const int * const volatile &) -> const bool * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_268)>::result_type, const bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_268)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_268)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_268)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_268)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_268)>::arg0_type, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_268)>::arg_type<0>, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_268)>::arg1_type, const int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_268)>::arg_type<1>, const int * const volatile &>);
static_assert(callable_traits<decltype(lambda_268)>::arity == 2);
static_assert(callable_traits<decltype(lambda_268)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_268)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_268)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_268)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_268)>::is_const == true);
static_assert(callable_traits<decltype(lambda_268)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_268)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_268)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_268)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_268)>::class_type, std::remove_const_t<decltype(lambda_268)>>);
[[maybe_unused]] const auto lambda_269 = [](volatile int * const volatile &, const volatile int * const volatile &, ...) mutable -> volatile bool * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_269)>::result_type, volatile bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_269)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_269)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_269)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_269)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_269)>::arg0_type, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_269)>::arg_type<0>, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_269)>::arg1_type, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_269)>::arg_type<1>, const volatile int * const volatile &>);
static_assert(callable_traits<decltype(lambda_269)>::arity == 2);
static_assert(callable_traits<decltype(lambda_269)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_269)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_269)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_269)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_269)>::is_const == false);
static_assert(callable_traits<decltype(lambda_269)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_269)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_269)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_269)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_269)>::class_type, std::remove_const_t<decltype(lambda_269)>>);
[[maybe_unused]] const auto lambda_270 = [](int &&, const int &&) noexcept -> const volatile bool * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_270)>::result_type, const volatile bool * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_270)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_270)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_270)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_270)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_270)>::arg0_type, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_270)>::arg_type<0>, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_270)>::arg1_type, const int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_270)>::arg_type<1>, const int &&>);
static_assert(callable_traits<decltype(lambda_270)>::arity == 2);
static_assert(callable_traits<decltype(lambda_270)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_270)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_270)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_270)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_270)>::is_const == true);
static_assert(callable_traits<decltype(lambda_270)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_270)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_270)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_270)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_270)>::class_type, std::remove_const_t<decltype(lambda_270)>>);
[[maybe_unused]] const auto lambda_271 = [](volatile int &&, const volatile int &&, ...) mutable noexcept -> bool * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_271)>::result_type, bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_271)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_271)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_271)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_271)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_271)>::arg0_type, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_271)>::arg_type<0>, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_271)>::arg1_type, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_271)>::arg_type<1>, const volatile int &&>);
static_assert(callable_traits<decltype(lambda_271)>::arity == 2);
static_assert(callable_traits<decltype(lambda_271)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_271)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_271)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_271)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_271)>::is_const == false);
static_assert(callable_traits<decltype(lambda_271)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_271)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_271)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_271)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_271)>::class_type, std::remove_const_t<decltype(lambda_271)>>);
[[maybe_unused]] const auto lambda_272 = [](int * &&, const int * &&) -> const bool * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_272)>::result_type, const bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_272)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_272)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_272)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_272)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_272)>::arg0_type, int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_272)>::arg_type<0>, int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_272)>::arg1_type, const int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_272)>::arg_type<1>, const int * &&>);
static_assert(callable_traits<decltype(lambda_272)>::arity == 2);
static_assert(callable_traits<decltype(lambda_272)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_272)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_272)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_272)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_272)>::is_const == true);
static_assert(callable_traits<decltype(lambda_272)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_272)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_272)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_272)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_272)>::class_type, std::remove_const_t<decltype(lambda_272)>>);
[[maybe_unused]] const auto lambda_273 = [](volatile int * &&, const volatile int * &&, ...) mutable -> volatile bool * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_273)>::result_type, volatile bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_273)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_273)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_273)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_273)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_273)>::arg0_type, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_273)>::arg_type<0>, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_273)>::arg1_type, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_273)>::arg_type<1>, const volatile int * &&>);
static_assert(callable_traits<decltype(lambda_273)>::arity == 2);
static_assert(callable_traits<decltype(lambda_273)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_273)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_273)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_273)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_273)>::is_const == false);
static_assert(callable_traits<decltype(lambda_273)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_273)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_273)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_273)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_273)>::class_type, std::remove_const_t<decltype(lambda_273)>>);
[[maybe_unused]] const auto lambda_274 = [](int * const &&, const int * const &&) noexcept -> const volatile bool * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_274)>::result_type, const volatile bool * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_274)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_274)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_274)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_274)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_274)>::arg0_type, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_274)>::arg_type<0>, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_274)>::arg1_type, const int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_274)>::arg_type<1>, const int * const &&>);
static_assert(callable_traits<decltype(lambda_274)>::arity == 2);
static_assert(callable_traits<decltype(lambda_274)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_274)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_274)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_274)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_274)>::is_const == true);
static_assert(callable_traits<decltype(lambda_274)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_274)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_274)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_274)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_274)>::class_type, std::remove_const_t<decltype(lambda_274)>>);
[[maybe_unused]] const auto lambda_275 = [](volatile int * const &&, const volatile int * const &&, ...) mutable noexcept -> bool * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_275)>::result_type, bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_275)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_275)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_275)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_275)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_275)>::arg0_type, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_275)>::arg_type<0>, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_275)>::arg1_type, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_275)>::arg_type<1>, const volatile int * const &&>);
static_assert(callable_traits<decltype(lambda_275)>::arity == 2);
static_assert(callable_traits<decltype(lambda_275)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_275)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_275)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_275)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_275)>::is_const == false);
static_assert(callable_traits<decltype(lambda_275)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_275)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_275)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_275)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_275)>::class_type, std::remove_const_t<decltype(lambda_275)>>);
[[maybe_unused]] const auto lambda_276 = [](int * volatile &&, const int * volatile &&) -> const bool * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_276)>::result_type, const bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_276)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_276)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_276)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_276)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_276)>::arg0_type, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_276)>::arg_type<0>, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_276)>::arg1_type, const int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_276)>::arg_type<1>, const int * volatile &&>);
static_assert(callable_traits<decltype(lambda_276)>::arity == 2);
static_assert(callable_traits<decltype(lambda_276)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_276)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_276)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_276)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_276)>::is_const == true);
static_assert(callable_traits<decltype(lambda_276)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_276)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_276)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_276)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_276)>::class_type, std::remove_const_t<decltype(lambda_276)>>);
[[maybe_unused]] const auto lambda_277 = [](volatile int * volatile &&, const volatile int * volatile &&, ...) mutable -> volatile bool * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_277)>::result_type, volatile bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_277)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_277)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_277)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_277)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_277)>::arg0_type, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_277)>::arg_type<0>, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_277)>::arg1_type, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_277)>::arg_type<1>, const volatile int * volatile &&>);
static_assert(callable_traits<decltype(lambda_277)>::arity == 2);
static_assert(callable_traits<decltype(lambda_277)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_277)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_277)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_277)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_277)>::is_const == false);
static_assert(callable_traits<decltype(lambda_277)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_277)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_277)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_277)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_277)>::class_type, std::remove_const_t<decltype(lambda_277)>>);
[[maybe_unused]] const auto lambda_278 = [](int * const volatile &&, const int * const volatile &&) noexcept -> const volatile bool * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_278)>::result_type, const volatile bool * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_278)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_278)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_278)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_278)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_278)>::arg0_type, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_278)>::arg_type<0>, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_278)>::arg1_type, const int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_278)>::arg_type<1>, const int * const volatile &&>);
static_assert(callable_traits<decltype(lambda_278)>::arity == 2);
static_assert(callable_traits<decltype(lambda_278)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_278)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_278)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_278)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_278)>::is_const == true);
static_assert(callable_traits<decltype(lambda_278)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_278)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_278)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_278)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_278)>::class_type, std::remove_const_t<decltype(lambda_278)>>);
[[maybe_unused]] const auto lambda_279 = [](volatile int * const volatile &&, const volatile int * const volatile &&, ...) mutable noexcept -> bool && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_279)>::result_type, bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_279)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_279)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_279)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_279)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_279)>::arg0_type, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_279)>::arg_type<0>, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_279)>::arg1_type, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_279)>::arg_type<1>, const volatile int * const volatile &&>);
static_assert(callable_traits<decltype(lambda_279)>::arity == 2);
static_assert(callable_traits<decltype(lambda_279)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_279)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_279)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_279)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_279)>::is_const == false);
static_assert(callable_traits<decltype(lambda_279)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_279)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_279)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_279)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_279)>::class_type, std::remove_const_t<decltype(lambda_279)>>);
[[maybe_unused]] const auto lambda_280 = [](float, float *) -> const bool && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_280)>::result_type, const bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_280)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_280)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_280)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_280)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_280)>::arg0_type, float>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_280)>::arg_type<0>, float>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_280)>::arg1_type, float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_280)>::arg_type<1>, float *>);
static_assert(callable_traits<decltype(lambda_280)>::arity == 2);
static_assert(callable_traits<decltype(lambda_280)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_280)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_280)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_280)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_280)>::is_const == true);
static_assert(callable_traits<decltype(lambda_280)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_280)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_280)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_280)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_280)>::class_type, std::remove_const_t<decltype(lambda_280)>>);
[[maybe_unused]] const auto lambda_281 = [](const float *, volatile float *, ...) mutable -> volatile bool && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_281)>::result_type, volatile bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_281)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_281)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_281)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_281)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_281)>::arg0_type, const float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_281)>::arg_type<0>, const float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_281)>::arg1_type, volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_281)>::arg_type<1>, volatile float *>);
static_assert(callable_traits<decltype(lambda_281)>::arity == 2);
static_assert(callable_traits<decltype(lambda_281)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_281)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_281)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_281)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_281)>::is_const == false);
static_assert(callable_traits<decltype(lambda_281)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_281)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_281)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_281)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_281)>::class_type, std::remove_const_t<decltype(lambda_281)>>);
[[maybe_unused]] const auto lambda_282 = [](const volatile float *, float &) noexcept -> const volatile bool && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_282)>::result_type, const volatile bool &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_282)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_282)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_282)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_282)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_282)>::arg0_type, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_282)>::arg_type<0>, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_282)>::arg1_type, float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_282)>::arg_type<1>, float &>);
static_assert(callable_traits<decltype(lambda_282)>::arity == 2);
static_assert(callable_traits<decltype(lambda_282)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_282)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_282)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_282)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_282)>::is_const == true);
static_assert(callable_traits<decltype(lambda_282)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_282)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_282)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_282)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_282)>::class_type, std::remove_const_t<decltype(lambda_282)>>);
[[maybe_unused]] const auto lambda_283 = [](const float &, volatile float &, ...) mutable noexcept -> bool * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_283)>::result_type, bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_283)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_283)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_283)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_283)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_283)>::arg0_type, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_283)>::arg_type<0>, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_283)>::arg1_type, volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_283)>::arg_type<1>, volatile float &>);
static_assert(callable_traits<decltype(lambda_283)>::arity == 2);
static_assert(callable_traits<decltype(lambda_283)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_283)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_283)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_283)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_283)>::is_const == false);
static_assert(callable_traits<decltype(lambda_283)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_283)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_283)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_283)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_283)>::class_type, std::remove_const_t<decltype(lambda_283)>>);
[[maybe_unused]] const auto lambda_284 = [](const volatile float &, float * &) -> const bool * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_284)>::result_type, const bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_284)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_284)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_284)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_284)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_284)>::arg0_type, const volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_284)>::arg_type<0>, const volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_284)>::arg1_type, float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_284)>::arg_type<1>, float * &>);
static_assert(callable_traits<decltype(lambda_284)>::arity == 2);
static_assert(callable_traits<decltype(lambda_284)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_284)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_284)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_284)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_284)>::is_const == true);
static_assert(callable_traits<decltype(lambda_284)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_284)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_284)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_284)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_284)>::class_type, std::remove_const_t<decltype(lambda_284)>>);
[[maybe_unused]] const auto lambda_285 = [](const float * &, volatile float * &, ...) mutable -> volatile bool * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_285)>::result_type, volatile bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_285)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_285)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_285)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_285)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_285)>::arg0_type, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_285)>::arg_type<0>, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_285)>::arg1_type, volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_285)>::arg_type<1>, volatile float * &>);
static_assert(callable_traits<decltype(lambda_285)>::arity == 2);
static_assert(callable_traits<decltype(lambda_285)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_285)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_285)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_285)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_285)>::is_const == false);
static_assert(callable_traits<decltype(lambda_285)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_285)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_285)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_285)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_285)>::class_type, std::remove_const_t<decltype(lambda_285)>>);
[[maybe_unused]] const auto lambda_286 = [](const volatile float * &, float * const &) noexcept -> const volatile bool * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_286)>::result_type, const volatile bool * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_286)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_286)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_286)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_286)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_286)>::arg0_type, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_286)>::arg_type<0>, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_286)>::arg1_type, float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_286)>::arg_type<1>, float * const &>);
static_assert(callable_traits<decltype(lambda_286)>::arity == 2);
static_assert(callable_traits<decltype(lambda_286)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_286)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_286)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_286)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_286)>::is_const == true);
static_assert(callable_traits<decltype(lambda_286)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_286)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_286)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_286)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_286)>::class_type, std::remove_const_t<decltype(lambda_286)>>);
[[maybe_unused]] const auto lambda_287 = [](const float * const &, volatile float * const &, ...) mutable noexcept -> bool * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_287)>::result_type, bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_287)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_287)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_287)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_287)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_287)>::arg0_type, const float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_287)>::arg_type<0>, const float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_287)>::arg1_type, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_287)>::arg_type<1>, volatile float * const &>);
static_assert(callable_traits<decltype(lambda_287)>::arity == 2);
static_assert(callable_traits<decltype(lambda_287)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_287)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_287)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_287)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_287)>::is_const == false);
static_assert(callable_traits<decltype(lambda_287)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_287)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_287)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_287)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_287)>::class_type, std::remove_const_t<decltype(lambda_287)>>);
[[maybe_unused]] const auto lambda_288 = [](const volatile float * const &, float * volatile &) -> const bool * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_288)>::result_type, const bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_288)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_288)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_288)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_288)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_288)>::arg0_type, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_288)>::arg_type<0>, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_288)>::arg1_type, float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_288)>::arg_type<1>, float * volatile &>);
static_assert(callable_traits<decltype(lambda_288)>::arity == 2);
static_assert(callable_traits<decltype(lambda_288)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_288)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_288)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_288)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_288)>::is_const == true);
static_assert(callable_traits<decltype(lambda_288)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_288)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_288)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_288)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_288)>::class_type, std::remove_const_t<decltype(lambda_288)>>);
[[maybe_unused]] const auto lambda_289 = [](const float * volatile &, volatile float * volatile &, ...) mutable -> volatile bool * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_289)>::result_type, volatile bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_289)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_289)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_289)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_289)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_289)>::arg0_type, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_289)>::arg_type<0>, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_289)>::arg1_type, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_289)>::arg_type<1>, volatile float * volatile &>);
static_assert(callable_traits<decltype(lambda_289)>::arity == 2);
static_assert(callable_traits<decltype(lambda_289)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_289)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_289)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_289)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_289)>::is_const == false);
static_assert(callable_traits<decltype(lambda_289)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_289)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_289)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_289)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_289)>::class_type, std::remove_const_t<decltype(lambda_289)>>);
[[maybe_unused]] const auto lambda_290 = [](const volatile float * volatile &, float * const volatile &) noexcept -> const volatile bool * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_290)>::result_type, const volatile bool * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_290)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_290)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_290)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_290)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_290)>::arg0_type, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_290)>::arg_type<0>, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_290)>::arg1_type, float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_290)>::arg_type<1>, float * const volatile &>);
static_assert(callable_traits<decltype(lambda_290)>::arity == 2);
static_assert(callable_traits<decltype(lambda_290)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_290)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_290)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_290)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_290)>::is_const == true);
static_assert(callable_traits<decltype(lambda_290)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_290)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_290)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_290)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_290)>::class_type, std::remove_const_t<decltype(lambda_290)>>);
[[maybe_unused]] const auto lambda_291 = [](const float * const volatile &, volatile float * const volatile &, ...) mutable noexcept -> bool * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_291)>::result_type, bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_291)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_291)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_291)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_291)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_291)>::arg0_type, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_291)>::arg_type<0>, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_291)>::arg1_type, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_291)>::arg_type<1>, volatile float * const volatile &>);
static_assert(callable_traits<decltype(lambda_291)>::arity == 2);
static_assert(callable_traits<decltype(lambda_291)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_291)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_291)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_291)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_291)>::is_const == false);
static_assert(callable_traits<decltype(lambda_291)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_291)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_291)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_291)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_291)>::class_type, std::remove_const_t<decltype(lambda_291)>>);
[[maybe_unused]] const auto lambda_292 = [](const volatile float * const volatile &, float &&) -> const bool * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_292)>::result_type, const bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_292)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_292)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_292)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_292)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_292)>::arg0_type, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_292)>::arg_type<0>, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_292)>::arg1_type, float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_292)>::arg_type<1>, float &&>);
static_assert(callable_traits<decltype(lambda_292)>::arity == 2);
static_assert(callable_traits<decltype(lambda_292)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_292)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_292)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_292)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_292)>::is_const == true);
static_assert(callable_traits<decltype(lambda_292)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_292)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_292)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_292)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_292)>::class_type, std::remove_const_t<decltype(lambda_292)>>);
[[maybe_unused]] const auto lambda_293 = [](const float &&, volatile float &&, ...) mutable -> volatile bool * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_293)>::result_type, volatile bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_293)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_293)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_293)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_293)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_293)>::arg0_type, const float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_293)>::arg_type<0>, const float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_293)>::arg1_type, volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_293)>::arg_type<1>, volatile float &&>);
static_assert(callable_traits<decltype(lambda_293)>::arity == 2);
static_assert(callable_traits<decltype(lambda_293)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_293)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_293)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_293)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_293)>::is_const == false);
static_assert(callable_traits<decltype(lambda_293)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_293)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_293)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_293)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_293)>::class_type, std::remove_const_t<decltype(lambda_293)>>);
[[maybe_unused]] const auto lambda_294 = [](const volatile float &&, float * &&) noexcept -> const volatile bool * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_294)>::result_type, const volatile bool * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_294)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_294)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_294)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_294)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_294)>::arg0_type, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_294)>::arg_type<0>, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_294)>::arg1_type, float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_294)>::arg_type<1>, float * &&>);
static_assert(callable_traits<decltype(lambda_294)>::arity == 2);
static_assert(callable_traits<decltype(lambda_294)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_294)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_294)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_294)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_294)>::is_const == true);
static_assert(callable_traits<decltype(lambda_294)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_294)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_294)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_294)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_294)>::class_type, std::remove_const_t<decltype(lambda_294)>>);
[[maybe_unused]] const auto lambda_295 = [](const float * &&, volatile float * &&, ...) mutable noexcept -> bool * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_295)>::result_type, bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_295)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_295)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_295)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_295)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_295)>::arg0_type, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_295)>::arg_type<0>, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_295)>::arg1_type, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_295)>::arg_type<1>, volatile float * &&>);
static_assert(callable_traits<decltype(lambda_295)>::arity == 2);
static_assert(callable_traits<decltype(lambda_295)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_295)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_295)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_295)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_295)>::is_const == false);
static_assert(callable_traits<decltype(lambda_295)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_295)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_295)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_295)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_295)>::class_type, std::remove_const_t<decltype(lambda_295)>>);
[[maybe_unused]] const auto lambda_296 = [](const volatile float * &&, float * const &&) -> const bool * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_296)>::result_type, const bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_296)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_296)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_296)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_296)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_296)>::arg0_type, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_296)>::arg_type<0>, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_296)>::arg1_type, float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_296)>::arg_type<1>, float * const &&>);
static_assert(callable_traits<decltype(lambda_296)>::arity == 2);
static_assert(callable_traits<decltype(lambda_296)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_296)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_296)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_296)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_296)>::is_const == true);
static_assert(callable_traits<decltype(lambda_296)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_296)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_296)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_296)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_296)>::class_type, std::remove_const_t<decltype(lambda_296)>>);
[[maybe_unused]] const auto lambda_297 = [](const float * const &&, volatile float * const &&, ...) mutable -> volatile bool * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_297)>::result_type, volatile bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_297)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_297)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_297)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_297)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_297)>::arg0_type, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_297)>::arg_type<0>, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_297)>::arg1_type, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_297)>::arg_type<1>, volatile float * const &&>);
static_assert(callable_traits<decltype(lambda_297)>::arity == 2);
static_assert(callable_traits<decltype(lambda_297)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_297)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_297)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_297)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_297)>::is_const == false);
static_assert(callable_traits<decltype(lambda_297)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_297)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_297)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_297)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_297)>::class_type, std::remove_const_t<decltype(lambda_297)>>);
[[maybe_unused]] const auto lambda_298 = [](const volatile float * const &&, float * volatile &&) noexcept -> const volatile bool * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_298)>::result_type, const volatile bool * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_298)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_298)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_298)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_298)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_298)>::arg0_type, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_298)>::arg_type<0>, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_298)>::arg1_type, float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_298)>::arg_type<1>, float * volatile &&>);
static_assert(callable_traits<decltype(lambda_298)>::arity == 2);
static_assert(callable_traits<decltype(lambda_298)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_298)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_298)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_298)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_298)>::is_const == true);
static_assert(callable_traits<decltype(lambda_298)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_298)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_298)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_298)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_298)>::class_type, std::remove_const_t<decltype(lambda_298)>>);
[[maybe_unused]] const auto lambda_299 = [](const float * volatile &&, volatile float * volatile &&, ...) mutable noexcept -> int {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_299)>::result_type, int>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_299)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_299)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_299)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_299)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_299)>::arg0_type, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_299)>::arg_type<0>, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_299)>::arg1_type, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_299)>::arg_type<1>, volatile float * volatile &&>);
static_assert(callable_traits<decltype(lambda_299)>::arity == 2);
static_assert(callable_traits<decltype(lambda_299)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_299)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_299)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_299)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_299)>::is_const == false);
static_assert(callable_traits<decltype(lambda_299)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_299)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_299)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_299)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_299)>::class_type, std::remove_const_t<decltype(lambda_299)>>);
[[maybe_unused]] const auto lambda_300 = [](const volatile float * volatile &&, float * const volatile &&) -> int * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_300)>::result_type, int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_300)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_300)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_300)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_300)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_300)>::arg0_type, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_300)>::arg_type<0>, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_300)>::arg1_type, float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_300)>::arg_type<1>, float * const volatile &&>);
static_assert(callable_traits<decltype(lambda_300)>::arity == 2);
static_assert(callable_traits<decltype(lambda_300)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_300)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_300)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_300)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_300)>::is_const == true);
static_assert(callable_traits<decltype(lambda_300)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_300)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_300)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_300)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_300)>::class_type, std::remove_const_t<decltype(lambda_300)>>);
[[maybe_unused]] const auto lambda_301 = [](const float * const volatile &&, volatile float * const volatile &&, ...) mutable -> const int * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_301)>::result_type, const int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_301)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_301)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_301)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_301)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_301)>::arg0_type, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_301)>::arg_type<0>, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_301)>::arg1_type, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_301)>::arg_type<1>, volatile float * const volatile &&>);
static_assert(callable_traits<decltype(lambda_301)>::arity == 2);
static_assert(callable_traits<decltype(lambda_301)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_301)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_301)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_301)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_301)>::is_const == false);
static_assert(callable_traits<decltype(lambda_301)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_301)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_301)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_301)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_301)>::class_type, std::remove_const_t<decltype(lambda_301)>>);
[[maybe_unused]] const auto lambda_302 = [](const volatile float * const volatile &&, std::string) noexcept -> volatile int * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_302)>::result_type, volatile int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_302)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_302)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_302)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_302)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_302)>::arg0_type, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_302)>::arg_type<0>, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_302)>::arg1_type, std::string>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_302)>::arg_type<1>, std::string>);
static_assert(callable_traits<decltype(lambda_302)>::arity == 2);
static_assert(callable_traits<decltype(lambda_302)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_302)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_302)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_302)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_302)>::is_const == true);
static_assert(callable_traits<decltype(lambda_302)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_302)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_302)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_302)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_302)>::class_type, std::remove_const_t<decltype(lambda_302)>>);
[[maybe_unused]] const auto lambda_303 = [](std::string *, const std::string *, ...) mutable noexcept -> const volatile int * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_303)>::result_type, const volatile int *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_303)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_303)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_303)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_303)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_303)>::arg0_type, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_303)>::arg_type<0>, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_303)>::arg1_type, const std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_303)>::arg_type<1>, const std::string *>);
static_assert(callable_traits<decltype(lambda_303)>::arity == 2);
static_assert(callable_traits<decltype(lambda_303)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_303)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_303)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_303)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_303)>::is_const == false);
static_assert(callable_traits<decltype(lambda_303)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_303)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_303)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_303)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_303)>::class_type, std::remove_const_t<decltype(lambda_303)>>);
[[maybe_unused]] const auto lambda_304 = [](volatile std::string *, const volatile std::string *) -> int & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_304)>::result_type, int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_304)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_304)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_304)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_304)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_304)>::arg0_type, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_304)>::arg_type<0>, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_304)>::arg1_type, const volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_304)>::arg_type<1>, const volatile std::string *>);
static_assert(callable_traits<decltype(lambda_304)>::arity == 2);
static_assert(callable_traits<decltype(lambda_304)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_304)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_304)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_304)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_304)>::is_const == true);
static_assert(callable_traits<decltype(lambda_304)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_304)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_304)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_304)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_304)>::class_type, std::remove_const_t<decltype(lambda_304)>>);
[[maybe_unused]] const auto lambda_305 = [](std::string &, const std::string &, ...) mutable -> const int & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_305)>::result_type, const int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_305)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_305)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_305)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_305)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_305)>::arg0_type, std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_305)>::arg_type<0>, std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_305)>::arg1_type, const std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_305)>::arg_type<1>, const std::string &>);
static_assert(callable_traits<decltype(lambda_305)>::arity == 2);
static_assert(callable_traits<decltype(lambda_305)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_305)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_305)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_305)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_305)>::is_const == false);
static_assert(callable_traits<decltype(lambda_305)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_305)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_305)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_305)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_305)>::class_type, std::remove_const_t<decltype(lambda_305)>>);
[[maybe_unused]] const auto lambda_306 = [](volatile std::string &, const volatile std::string &) noexcept -> volatile int & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_306)>::result_type, volatile int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_306)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_306)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_306)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_306)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_306)>::arg0_type, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_306)>::arg_type<0>, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_306)>::arg1_type, const volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_306)>::arg_type<1>, const volatile std::string &>);
static_assert(callable_traits<decltype(lambda_306)>::arity == 2);
static_assert(callable_traits<decltype(lambda_306)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_306)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_306)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_306)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_306)>::is_const == true);
static_assert(callable_traits<decltype(lambda_306)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_306)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_306)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_306)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_306)>::class_type, std::remove_const_t<decltype(lambda_306)>>);
[[maybe_unused]] const auto lambda_307 = [](std::string * &, const std::string * &, ...) mutable noexcept -> const volatile int & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_307)>::result_type, const volatile int &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_307)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_307)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_307)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_307)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_307)>::arg0_type, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_307)>::arg_type<0>, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_307)>::arg1_type, const std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_307)>::arg_type<1>, const std::string * &>);
static_assert(callable_traits<decltype(lambda_307)>::arity == 2);
static_assert(callable_traits<decltype(lambda_307)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_307)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_307)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_307)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_307)>::is_const == false);
static_assert(callable_traits<decltype(lambda_307)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_307)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_307)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_307)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_307)>::class_type, std::remove_const_t<decltype(lambda_307)>>);
[[maybe_unused]] const auto lambda_308 = [](volatile std::string * &, const volatile std::string * &) -> int * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_308)>::result_type, int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_308)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_308)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_308)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_308)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_308)>::arg0_type, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_308)>::arg_type<0>, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_308)>::arg1_type, const volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_308)>::arg_type<1>, const volatile std::string * &>);
static_assert(callable_traits<decltype(lambda_308)>::arity == 2);
static_assert(callable_traits<decltype(lambda_308)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_308)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_308)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_308)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_308)>::is_const == true);
static_assert(callable_traits<decltype(lambda_308)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_308)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_308)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_308)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_308)>::class_type, std::remove_const_t<decltype(lambda_308)>>);
[[maybe_unused]] const auto lambda_309 = [](std::string * const &, const std::string * const &, ...) mutable -> const int * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_309)>::result_type, const int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_309)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_309)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_309)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_309)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_309)>::arg0_type, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_309)>::arg_type<0>, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_309)>::arg1_type, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_309)>::arg_type<1>, const std::string * const &>);
static_assert(callable_traits<decltype(lambda_309)>::arity == 2);
static_assert(callable_traits<decltype(lambda_309)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_309)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_309)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_309)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_309)>::is_const == false);
static_assert(callable_traits<decltype(lambda_309)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_309)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_309)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_309)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_309)>::class_type, std::remove_const_t<decltype(lambda_309)>>);
[[maybe_unused]] const auto lambda_310 = [](volatile std::string * const &, const volatile std::string * const &) noexcept -> volatile int * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_310)>::result_type, volatile int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_310)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_310)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_310)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_310)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_310)>::arg0_type, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_310)>::arg_type<0>, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_310)>::arg1_type, const volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_310)>::arg_type<1>, const volatile std::string * const &>);
static_assert(callable_traits<decltype(lambda_310)>::arity == 2);
static_assert(callable_traits<decltype(lambda_310)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_310)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_310)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_310)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_310)>::is_const == true);
static_assert(callable_traits<decltype(lambda_310)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_310)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_310)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_310)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_310)>::class_type, std::remove_const_t<decltype(lambda_310)>>);
[[maybe_unused]] const auto lambda_311 = [](std::string * volatile &, const std::string * volatile &, ...) mutable noexcept -> const volatile int * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_311)>::result_type, const volatile int * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_311)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_311)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_311)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_311)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_311)>::arg0_type, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_311)>::arg_type<0>, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_311)>::arg1_type, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_311)>::arg_type<1>, const std::string * volatile &>);
static_assert(callable_traits<decltype(lambda_311)>::arity == 2);
static_assert(callable_traits<decltype(lambda_311)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_311)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_311)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_311)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_311)>::is_const == false);
static_assert(callable_traits<decltype(lambda_311)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_311)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_311)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_311)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_311)>::class_type, std::remove_const_t<decltype(lambda_311)>>);
[[maybe_unused]] const auto lambda_312 = [](volatile std::string * volatile &, const volatile std::string * volatile &) -> int * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_312)>::result_type, int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_312)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_312)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_312)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_312)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_312)>::arg0_type, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_312)>::arg_type<0>, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_312)>::arg1_type, const volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_312)>::arg_type<1>, const volatile std::string * volatile &>);
static_assert(callable_traits<decltype(lambda_312)>::arity == 2);
static_assert(callable_traits<decltype(lambda_312)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_312)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_312)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_312)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_312)>::is_const == true);
static_assert(callable_traits<decltype(lambda_312)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_312)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_312)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_312)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_312)>::class_type, std::remove_const_t<decltype(lambda_312)>>);
[[maybe_unused]] const auto lambda_313 = [](std::string * const volatile &, const std::string * const volatile &, ...) mutable -> const int * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_313)>::result_type, const int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_313)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_313)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_313)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_313)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_313)>::arg0_type, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_313)>::arg_type<0>, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_313)>::arg1_type, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_313)>::arg_type<1>, const std::string * const volatile &>);
static_assert(callable_traits<decltype(lambda_313)>::arity == 2);
static_assert(callable_traits<decltype(lambda_313)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_313)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_313)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_313)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_313)>::is_const == false);
static_assert(callable_traits<decltype(lambda_313)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_313)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_313)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_313)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_313)>::class_type, std::remove_const_t<decltype(lambda_313)>>);
[[maybe_unused]] const auto lambda_314 = [](volatile std::string * const volatile &, const volatile std::string * const volatile &) noexcept -> volatile int * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_314)>::result_type, volatile int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_314)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_314)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_314)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_314)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_314)>::arg0_type, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_314)>::arg_type<0>, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_314)>::arg1_type, const volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_314)>::arg_type<1>, const volatile std::string * const volatile &>);
static_assert(callable_traits<decltype(lambda_314)>::arity == 2);
static_assert(callable_traits<decltype(lambda_314)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_314)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_314)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_314)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_314)>::is_const == true);
static_assert(callable_traits<decltype(lambda_314)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_314)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_314)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_314)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_314)>::class_type, std::remove_const_t<decltype(lambda_314)>>);
[[maybe_unused]] const auto lambda_315 = [](std::string &&, const std::string &&, ...) mutable noexcept -> const volatile int * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_315)>::result_type, const volatile int * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_315)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_315)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_315)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_315)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_315)>::arg0_type, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_315)>::arg_type<0>, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_315)>::arg1_type, const std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_315)>::arg_type<1>, const std::string &&>);
static_assert(callable_traits<decltype(lambda_315)>::arity == 2);
static_assert(callable_traits<decltype(lambda_315)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_315)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_315)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_315)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_315)>::is_const == false);
static_assert(callable_traits<decltype(lambda_315)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_315)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_315)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_315)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_315)>::class_type, std::remove_const_t<decltype(lambda_315)>>);
[[maybe_unused]] const auto lambda_316 = [](volatile std::string &&, const volatile std::string &&) -> int * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_316)>::result_type, int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_316)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_316)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_316)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_316)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_316)>::arg0_type, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_316)>::arg_type<0>, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_316)>::arg1_type, const volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_316)>::arg_type<1>, const volatile std::string &&>);
static_assert(callable_traits<decltype(lambda_316)>::arity == 2);
static_assert(callable_traits<decltype(lambda_316)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_316)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_316)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_316)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_316)>::is_const == true);
static_assert(callable_traits<decltype(lambda_316)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_316)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_316)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_316)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_316)>::class_type, std::remove_const_t<decltype(lambda_316)>>);
[[maybe_unused]] const auto lambda_317 = [](std::string * &&, const std::string * &&, ...) mutable -> const int * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_317)>::result_type, const int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_317)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_317)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_317)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_317)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_317)>::arg0_type, std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_317)>::arg_type<0>, std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_317)>::arg1_type, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_317)>::arg_type<1>, const std::string * &&>);
static_assert(callable_traits<decltype(lambda_317)>::arity == 2);
static_assert(callable_traits<decltype(lambda_317)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_317)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_317)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_317)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_317)>::is_const == false);
static_assert(callable_traits<decltype(lambda_317)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_317)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_317)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_317)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_317)>::class_type, std::remove_const_t<decltype(lambda_317)>>);
[[maybe_unused]] const auto lambda_318 = [](volatile std::string * &&, const volatile std::string * &&) noexcept -> volatile int * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_318)>::result_type, volatile int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_318)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_318)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_318)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_318)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_318)>::arg0_type, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_318)>::arg_type<0>, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_318)>::arg1_type, const volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_318)>::arg_type<1>, const volatile std::string * &&>);
static_assert(callable_traits<decltype(lambda_318)>::arity == 2);
static_assert(callable_traits<decltype(lambda_318)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_318)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_318)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_318)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_318)>::is_const == true);
static_assert(callable_traits<decltype(lambda_318)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_318)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_318)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_318)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_318)>::class_type, std::remove_const_t<decltype(lambda_318)>>);
[[maybe_unused]] const auto lambda_319 = [](std::string * const &&, const std::string * const &&, ...) mutable noexcept -> const volatile int * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_319)>::result_type, const volatile int * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_319)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_319)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_319)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_319)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_319)>::arg0_type, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_319)>::arg_type<0>, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_319)>::arg1_type, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_319)>::arg_type<1>, const std::string * const &&>);
static_assert(callable_traits<decltype(lambda_319)>::arity == 2);
static_assert(callable_traits<decltype(lambda_319)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_319)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_319)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_319)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_319)>::is_const == false);
static_assert(callable_traits<decltype(lambda_319)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_319)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_319)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_319)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_319)>::class_type, std::remove_const_t<decltype(lambda_319)>>);
[[maybe_unused]] const auto lambda_320 = [](volatile std::string * const &&, const volatile std::string * const &&) -> int * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_320)>::result_type, int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_320)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_320)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_320)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_320)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_320)>::arg0_type, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_320)>::arg_type<0>, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_320)>::arg1_type, const volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_320)>::arg_type<1>, const volatile std::string * const &&>);
static_assert(callable_traits<decltype(lambda_320)>::arity == 2);
static_assert(callable_traits<decltype(lambda_320)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_320)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_320)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_320)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_320)>::is_const == true);
static_assert(callable_traits<decltype(lambda_320)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_320)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_320)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_320)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_320)>::class_type, std::remove_const_t<decltype(lambda_320)>>);
[[maybe_unused]] const auto lambda_321 = [](std::string * volatile &&, const std::string * volatile &&, ...) mutable -> const int * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_321)>::result_type, const int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_321)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_321)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_321)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_321)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_321)>::arg0_type, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_321)>::arg_type<0>, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_321)>::arg1_type, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_321)>::arg_type<1>, const std::string * volatile &&>);
static_assert(callable_traits<decltype(lambda_321)>::arity == 2);
static_assert(callable_traits<decltype(lambda_321)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_321)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_321)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_321)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_321)>::is_const == false);
static_assert(callable_traits<decltype(lambda_321)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_321)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_321)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_321)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_321)>::class_type, std::remove_const_t<decltype(lambda_321)>>);
[[maybe_unused]] const auto lambda_322 = [](volatile std::string * volatile &&, const volatile std::string * volatile &&) noexcept -> volatile int * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_322)>::result_type, volatile int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_322)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_322)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_322)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_322)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_322)>::arg0_type, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_322)>::arg_type<0>, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_322)>::arg1_type, const volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_322)>::arg_type<1>, const volatile std::string * volatile &&>);
static_assert(callable_traits<decltype(lambda_322)>::arity == 2);
static_assert(callable_traits<decltype(lambda_322)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_322)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_322)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_322)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_322)>::is_const == true);
static_assert(callable_traits<decltype(lambda_322)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_322)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_322)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_322)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_322)>::class_type, std::remove_const_t<decltype(lambda_322)>>);
[[maybe_unused]] const auto lambda_323 = [](std::string * const volatile &&, const std::string * const volatile &&, ...) mutable noexcept -> const volatile int * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_323)>::result_type, const volatile int * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_323)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_323)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_323)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_323)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_323)>::arg0_type, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_323)>::arg_type<0>, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_323)>::arg1_type, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_323)>::arg_type<1>, const std::string * const volatile &&>);
static_assert(callable_traits<decltype(lambda_323)>::arity == 2);
static_assert(callable_traits<decltype(lambda_323)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_323)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_323)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_323)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_323)>::is_const == false);
static_assert(callable_traits<decltype(lambda_323)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_323)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_323)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_323)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_323)>::class_type, std::remove_const_t<decltype(lambda_323)>>);
[[maybe_unused]] const auto lambda_324 = [](volatile std::string * const volatile &&, const volatile std::string * const volatile &&) -> int && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_324)>::result_type, int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_324)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_324)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_324)>> == false);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_324)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_324)>::arg0_type, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_324)>::arg_type<0>, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_324)>::arg1_type, const volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_324)>::arg_type<1>, const volatile std::string * const volatile &&>);
static_assert(callable_traits<decltype(lambda_324)>::arity == 2);
static_assert(callable_traits<decltype(lambda_324)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_324)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_324)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_324)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_324)>::is_const == true);
static_assert(callable_traits<decltype(lambda_324)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_324)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_324)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_324)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_324)>::class_type, std::remove_const_t<decltype(lambda_324)>>);
[[maybe_unused]] const auto lambda_325 = [](void *, const void *, volatile void *, ...) mutable -> const int && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_325)>::result_type, const int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_325)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_325)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_325)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_325)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_325)>::arg0_type, void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_325)>::arg_type<0>, void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_325)>::arg1_type, const void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_325)>::arg_type<1>, const void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_325)>::arg2_type, volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_325)>::arg_type<2>, volatile void *>);
static_assert(callable_traits<decltype(lambda_325)>::arity == 3);
static_assert(callable_traits<decltype(lambda_325)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_325)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_325)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_325)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_325)>::is_const == false);
static_assert(callable_traits<decltype(lambda_325)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_325)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_325)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_325)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_325)>::class_type, std::remove_const_t<decltype(lambda_325)>>);
[[maybe_unused]] const auto lambda_326 = [](const volatile void *, void * &, const void * &) noexcept -> volatile int && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_326)>::result_type, volatile int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_326)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_326)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_326)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_326)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_326)>::arg0_type, const volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_326)>::arg_type<0>, const volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_326)>::arg1_type, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_326)>::arg_type<1>, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_326)>::arg2_type, const void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_326)>::arg_type<2>, const void * &>);
static_assert(callable_traits<decltype(lambda_326)>::arity == 3);
static_assert(callable_traits<decltype(lambda_326)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_326)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_326)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_326)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_326)>::is_const == true);
static_assert(callable_traits<decltype(lambda_326)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_326)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_326)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_326)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_326)>::class_type, std::remove_const_t<decltype(lambda_326)>>);
[[maybe_unused]] const auto lambda_327 = [](volatile void * &, const volatile void * &, void * const &, ...) mutable noexcept -> const volatile int && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_327)>::result_type, const volatile int &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_327)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_327)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_327)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_327)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_327)>::arg0_type, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_327)>::arg_type<0>, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_327)>::arg1_type, const volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_327)>::arg_type<1>, const volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_327)>::arg2_type, void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_327)>::arg_type<2>, void * const &>);
static_assert(callable_traits<decltype(lambda_327)>::arity == 3);
static_assert(callable_traits<decltype(lambda_327)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_327)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_327)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_327)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_327)>::is_const == false);
static_assert(callable_traits<decltype(lambda_327)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_327)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_327)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_327)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_327)>::class_type, std::remove_const_t<decltype(lambda_327)>>);
[[maybe_unused]] const auto lambda_328 = [](const void * const &, volatile void * const &, const volatile void * const &) -> int * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_328)>::result_type, int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_328)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_328)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_328)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_328)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_328)>::arg0_type, const void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_328)>::arg_type<0>, const void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_328)>::arg1_type, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_328)>::arg_type<1>, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_328)>::arg2_type, const volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_328)>::arg_type<2>, const volatile void * const &>);
static_assert(callable_traits<decltype(lambda_328)>::arity == 3);
static_assert(callable_traits<decltype(lambda_328)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_328)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_328)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_328)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_328)>::is_const == true);
static_assert(callable_traits<decltype(lambda_328)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_328)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_328)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_328)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_328)>::class_type, std::remove_const_t<decltype(lambda_328)>>);
[[maybe_unused]] const auto lambda_329 = [](void * volatile &, const void * volatile &, volatile void * volatile &, ...) mutable -> const int * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_329)>::result_type, const int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_329)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_329)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_329)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_329)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_329)>::arg0_type, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_329)>::arg_type<0>, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_329)>::arg1_type, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_329)>::arg_type<1>, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_329)>::arg2_type, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_329)>::arg_type<2>, volatile void * volatile &>);
static_assert(callable_traits<decltype(lambda_329)>::arity == 3);
static_assert(callable_traits<decltype(lambda_329)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_329)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_329)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_329)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_329)>::is_const == false);
static_assert(callable_traits<decltype(lambda_329)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_329)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_329)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_329)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_329)>::class_type, std::remove_const_t<decltype(lambda_329)>>);
[[maybe_unused]] const auto lambda_330 = [](const volatile void * volatile &, void * const volatile &, const void * const volatile &) noexcept -> volatile int * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_330)>::result_type, volatile int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_330)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_330)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_330)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_330)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_330)>::arg0_type, const volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_330)>::arg_type<0>, const volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_330)>::arg1_type, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_330)>::arg_type<1>, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_330)>::arg2_type, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_330)>::arg_type<2>, const void * const volatile &>);
static_assert(callable_traits<decltype(lambda_330)>::arity == 3);
static_assert(callable_traits<decltype(lambda_330)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_330)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_330)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_330)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_330)>::is_const == true);
static_assert(callable_traits<decltype(lambda_330)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_330)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_330)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_330)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_330)>::class_type, std::remove_const_t<decltype(lambda_330)>>);
[[maybe_unused]] const auto lambda_331 = [](volatile void * const volatile &, const volatile void * const volatile &, void * &&, ...) mutable noexcept -> const volatile int * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_331)>::result_type, const volatile int * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_331)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_331)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_331)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_331)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_331)>::arg0_type, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_331)>::arg_type<0>, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_331)>::arg1_type, const volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_331)>::arg_type<1>, const volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_331)>::arg2_type, void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_331)>::arg_type<2>, void * &&>);
static_assert(callable_traits<decltype(lambda_331)>::arity == 3);
static_assert(callable_traits<decltype(lambda_331)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_331)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_331)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_331)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_331)>::is_const == false);
static_assert(callable_traits<decltype(lambda_331)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_331)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_331)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_331)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_331)>::class_type, std::remove_const_t<decltype(lambda_331)>>);
[[maybe_unused]] const auto lambda_332 = [](const void * &&, volatile void * &&, const volatile void * &&) -> int * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_332)>::result_type, int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_332)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_332)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_332)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_332)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_332)>::arg0_type, const void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_332)>::arg_type<0>, const void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_332)>::arg1_type, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_332)>::arg_type<1>, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_332)>::arg2_type, const volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_332)>::arg_type<2>, const volatile void * &&>);
static_assert(callable_traits<decltype(lambda_332)>::arity == 3);
static_assert(callable_traits<decltype(lambda_332)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_332)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_332)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_332)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_332)>::is_const == true);
static_assert(callable_traits<decltype(lambda_332)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_332)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_332)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_332)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_332)>::class_type, std::remove_const_t<decltype(lambda_332)>>);
[[maybe_unused]] const auto lambda_333 = [](void * const &&, const void * const &&, volatile void * const &&, ...) mutable -> const int * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_333)>::result_type, const int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_333)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_333)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_333)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_333)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_333)>::arg0_type, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_333)>::arg_type<0>, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_333)>::arg1_type, const void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_333)>::arg_type<1>, const void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_333)>::arg2_type, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_333)>::arg_type<2>, volatile void * const &&>);
static_assert(callable_traits<decltype(lambda_333)>::arity == 3);
static_assert(callable_traits<decltype(lambda_333)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_333)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_333)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_333)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_333)>::is_const == false);
static_assert(callable_traits<decltype(lambda_333)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_333)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_333)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_333)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_333)>::class_type, std::remove_const_t<decltype(lambda_333)>>);
[[maybe_unused]] const auto lambda_334 = [](const volatile void * const &&, void * volatile &&, const void * volatile &&) noexcept -> volatile int * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_334)>::result_type, volatile int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_334)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_334)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_334)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_334)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_334)>::arg0_type, const volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_334)>::arg_type<0>, const volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_334)>::arg1_type, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_334)>::arg_type<1>, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_334)>::arg2_type, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_334)>::arg_type<2>, const void * volatile &&>);
static_assert(callable_traits<decltype(lambda_334)>::arity == 3);
static_assert(callable_traits<decltype(lambda_334)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_334)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_334)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_334)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_334)>::is_const == true);
static_assert(callable_traits<decltype(lambda_334)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_334)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_334)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_334)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_334)>::class_type, std::remove_const_t<decltype(lambda_334)>>);
[[maybe_unused]] const auto lambda_335 = [](volatile void * volatile &&, const volatile void * volatile &&, void * const volatile &&, ...) mutable noexcept -> const volatile int * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_335)>::result_type, const volatile int * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_335)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_335)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_335)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_335)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_335)>::arg0_type, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_335)>::arg_type<0>, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_335)>::arg1_type, const volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_335)>::arg_type<1>, const volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_335)>::arg2_type, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_335)>::arg_type<2>, void * const volatile &&>);
static_assert(callable_traits<decltype(lambda_335)>::arity == 3);
static_assert(callable_traits<decltype(lambda_335)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_335)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_335)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_335)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_335)>::is_const == false);
static_assert(callable_traits<decltype(lambda_335)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_335)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_335)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_335)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_335)>::class_type, std::remove_const_t<decltype(lambda_335)>>);
[[maybe_unused]] const auto lambda_336 = [](const void * const volatile &&, volatile void * const volatile &&, const volatile void * const volatile &&) -> int * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_336)>::result_type, int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_336)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_336)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_336)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_336)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_336)>::arg0_type, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_336)>::arg_type<0>, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_336)>::arg1_type, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_336)>::arg_type<1>, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_336)>::arg2_type, const volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_336)>::arg_type<2>, const volatile void * const volatile &&>);
static_assert(callable_traits<decltype(lambda_336)>::arity == 3);
static_assert(callable_traits<decltype(lambda_336)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_336)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_336)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_336)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_336)>::is_const == true);
static_assert(callable_traits<decltype(lambda_336)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_336)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_336)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_336)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_336)>::class_type, std::remove_const_t<decltype(lambda_336)>>);
[[maybe_unused]] const auto lambda_337 = [](bool, bool *, const bool *, ...) mutable -> const int * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_337)>::result_type, const int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_337)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_337)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_337)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_337)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_337)>::arg0_type, bool>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_337)>::arg_type<0>, bool>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_337)>::arg1_type, bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_337)>::arg_type<1>, bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_337)>::arg2_type, const bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_337)>::arg_type<2>, const bool *>);
static_assert(callable_traits<decltype(lambda_337)>::arity == 3);
static_assert(callable_traits<decltype(lambda_337)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_337)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_337)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_337)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_337)>::is_const == false);
static_assert(callable_traits<decltype(lambda_337)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_337)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_337)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_337)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_337)>::class_type, std::remove_const_t<decltype(lambda_337)>>);
[[maybe_unused]] const auto lambda_338 = [](volatile bool *, const volatile bool *, bool &) noexcept -> volatile int * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_338)>::result_type, volatile int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_338)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_338)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_338)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_338)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_338)>::arg0_type, volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_338)>::arg_type<0>, volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_338)>::arg1_type, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_338)>::arg_type<1>, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_338)>::arg2_type, bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_338)>::arg_type<2>, bool &>);
static_assert(callable_traits<decltype(lambda_338)>::arity == 3);
static_assert(callable_traits<decltype(lambda_338)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_338)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_338)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_338)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_338)>::is_const == true);
static_assert(callable_traits<decltype(lambda_338)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_338)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_338)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_338)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_338)>::class_type, std::remove_const_t<decltype(lambda_338)>>);
[[maybe_unused]] const auto lambda_339 = [](const bool &, volatile bool &, const volatile bool &, ...) mutable noexcept -> const volatile int * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_339)>::result_type, const volatile int * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_339)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_339)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_339)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_339)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_339)>::arg0_type, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_339)>::arg_type<0>, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_339)>::arg1_type, volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_339)>::arg_type<1>, volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_339)>::arg2_type, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_339)>::arg_type<2>, const volatile bool &>);
static_assert(callable_traits<decltype(lambda_339)>::arity == 3);
static_assert(callable_traits<decltype(lambda_339)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_339)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_339)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_339)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_339)>::is_const == false);
static_assert(callable_traits<decltype(lambda_339)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_339)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_339)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_339)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_339)>::class_type, std::remove_const_t<decltype(lambda_339)>>);
[[maybe_unused]] const auto lambda_340 = [](bool * &, const bool * &, volatile bool * &) -> int * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_340)>::result_type, int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_340)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_340)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_340)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_340)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_340)>::arg0_type, bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_340)>::arg_type<0>, bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_340)>::arg1_type, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_340)>::arg_type<1>, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_340)>::arg2_type, volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_340)>::arg_type<2>, volatile bool * &>);
static_assert(callable_traits<decltype(lambda_340)>::arity == 3);
static_assert(callable_traits<decltype(lambda_340)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_340)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_340)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_340)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_340)>::is_const == true);
static_assert(callable_traits<decltype(lambda_340)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_340)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_340)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_340)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_340)>::class_type, std::remove_const_t<decltype(lambda_340)>>);
[[maybe_unused]] const auto lambda_341 = [](const volatile bool * &, bool * const &, const bool * const &, ...) mutable -> const int * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_341)>::result_type, const int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_341)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_341)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_341)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_341)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_341)>::arg0_type, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_341)>::arg_type<0>, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_341)>::arg1_type, bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_341)>::arg_type<1>, bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_341)>::arg2_type, const bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_341)>::arg_type<2>, const bool * const &>);
static_assert(callable_traits<decltype(lambda_341)>::arity == 3);
static_assert(callable_traits<decltype(lambda_341)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_341)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_341)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_341)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_341)>::is_const == false);
static_assert(callable_traits<decltype(lambda_341)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_341)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_341)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_341)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_341)>::class_type, std::remove_const_t<decltype(lambda_341)>>);
[[maybe_unused]] const auto lambda_342 = [](volatile bool * const &, const volatile bool * const &, bool * volatile &) noexcept -> volatile int * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_342)>::result_type, volatile int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_342)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_342)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_342)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_342)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_342)>::arg0_type, volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_342)>::arg_type<0>, volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_342)>::arg1_type, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_342)>::arg_type<1>, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_342)>::arg2_type, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_342)>::arg_type<2>, bool * volatile &>);
static_assert(callable_traits<decltype(lambda_342)>::arity == 3);
static_assert(callable_traits<decltype(lambda_342)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_342)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_342)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_342)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_342)>::is_const == true);
static_assert(callable_traits<decltype(lambda_342)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_342)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_342)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_342)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_342)>::class_type, std::remove_const_t<decltype(lambda_342)>>);
[[maybe_unused]] const auto lambda_343 = [](const bool * volatile &, volatile bool * volatile &, const volatile bool * volatile &, ...) mutable noexcept -> const volatile int * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_343)>::result_type, const volatile int * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_343)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_343)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_343)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_343)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_343)>::arg0_type, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_343)>::arg_type<0>, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_343)>::arg1_type, volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_343)>::arg_type<1>, volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_343)>::arg2_type, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_343)>::arg_type<2>, const volatile bool * volatile &>);
static_assert(callable_traits<decltype(lambda_343)>::arity == 3);
static_assert(callable_traits<decltype(lambda_343)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_343)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_343)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_343)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_343)>::is_const == false);
static_assert(callable_traits<decltype(lambda_343)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_343)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_343)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_343)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_343)>::class_type, std::remove_const_t<decltype(lambda_343)>>);
[[maybe_unused]] const auto lambda_344 = [](bool * const volatile &, const bool * const volatile &, volatile bool * const volatile &) -> float {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_344)>::result_type, float>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_344)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_344)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_344)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_344)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_344)>::arg0_type, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_344)>::arg_type<0>, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_344)>::arg1_type, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_344)>::arg_type<1>, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_344)>::arg2_type, volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_344)>::arg_type<2>, volatile bool * const volatile &>);
static_assert(callable_traits<decltype(lambda_344)>::arity == 3);
static_assert(callable_traits<decltype(lambda_344)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_344)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_344)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_344)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_344)>::is_const == true);
static_assert(callable_traits<decltype(lambda_344)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_344)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_344)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_344)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_344)>::class_type, std::remove_const_t<decltype(lambda_344)>>);
[[maybe_unused]] const auto lambda_345 = [](const volatile bool * const volatile &, bool &&, const bool &&, ...) mutable -> float * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_345)>::result_type, float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_345)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_345)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_345)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_345)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_345)>::arg0_type, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_345)>::arg_type<0>, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_345)>::arg1_type, bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_345)>::arg_type<1>, bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_345)>::arg2_type, const bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_345)>::arg_type<2>, const bool &&>);
static_assert(callable_traits<decltype(lambda_345)>::arity == 3);
static_assert(callable_traits<decltype(lambda_345)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_345)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_345)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_345)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_345)>::is_const == false);
static_assert(callable_traits<decltype(lambda_345)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_345)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_345)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_345)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_345)>::class_type, std::remove_const_t<decltype(lambda_345)>>);
[[maybe_unused]] const auto lambda_346 = [](volatile bool &&, const volatile bool &&, bool * &&) noexcept -> const float * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_346)>::result_type, const float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_346)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_346)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_346)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_346)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_346)>::arg0_type, volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_346)>::arg_type<0>, volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_346)>::arg1_type, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_346)>::arg_type<1>, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_346)>::arg2_type, bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_346)>::arg_type<2>, bool * &&>);
static_assert(callable_traits<decltype(lambda_346)>::arity == 3);
static_assert(callable_traits<decltype(lambda_346)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_346)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_346)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_346)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_346)>::is_const == true);
static_assert(callable_traits<decltype(lambda_346)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_346)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_346)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_346)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_346)>::class_type, std::remove_const_t<decltype(lambda_346)>>);
[[maybe_unused]] const auto lambda_347 = [](const bool * &&, volatile bool * &&, const volatile bool * &&, ...) mutable noexcept -> volatile float * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_347)>::result_type, volatile float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_347)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_347)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_347)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_347)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_347)>::arg0_type, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_347)>::arg_type<0>, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_347)>::arg1_type, volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_347)>::arg_type<1>, volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_347)>::arg2_type, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_347)>::arg_type<2>, const volatile bool * &&>);
static_assert(callable_traits<decltype(lambda_347)>::arity == 3);
static_assert(callable_traits<decltype(lambda_347)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_347)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_347)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_347)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_347)>::is_const == false);
static_assert(callable_traits<decltype(lambda_347)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_347)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_347)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_347)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_347)>::class_type, std::remove_const_t<decltype(lambda_347)>>);
[[maybe_unused]] const auto lambda_348 = [](bool * const &&, const bool * const &&, volatile bool * const &&) -> const volatile float * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_348)>::result_type, const volatile float *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_348)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_348)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_348)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_348)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_348)>::arg0_type, bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_348)>::arg_type<0>, bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_348)>::arg1_type, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_348)>::arg_type<1>, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_348)>::arg2_type, volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_348)>::arg_type<2>, volatile bool * const &&>);
static_assert(callable_traits<decltype(lambda_348)>::arity == 3);
static_assert(callable_traits<decltype(lambda_348)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_348)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_348)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_348)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_348)>::is_const == true);
static_assert(callable_traits<decltype(lambda_348)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_348)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_348)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_348)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_348)>::class_type, std::remove_const_t<decltype(lambda_348)>>);
[[maybe_unused]] const auto lambda_349 = [](const volatile bool * const &&, bool * volatile &&, const bool * volatile &&, ...) mutable -> float & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_349)>::result_type, float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_349)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_349)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_349)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_349)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_349)>::arg0_type, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_349)>::arg_type<0>, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_349)>::arg1_type, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_349)>::arg_type<1>, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_349)>::arg2_type, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_349)>::arg_type<2>, const bool * volatile &&>);
static_assert(callable_traits<decltype(lambda_349)>::arity == 3);
static_assert(callable_traits<decltype(lambda_349)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_349)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_349)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_349)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_349)>::is_const == false);
static_assert(callable_traits<decltype(lambda_349)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_349)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_349)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_349)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_349)>::class_type, std::remove_const_t<decltype(lambda_349)>>);
[[maybe_unused]] const auto lambda_350 = [](volatile bool * volatile &&, const volatile bool * volatile &&, bool * const volatile &&) noexcept -> const float & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_350)>::result_type, const float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_350)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_350)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_350)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_350)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_350)>::arg0_type, volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_350)>::arg_type<0>, volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_350)>::arg1_type, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_350)>::arg_type<1>, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_350)>::arg2_type, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_350)>::arg_type<2>, bool * const volatile &&>);
static_assert(callable_traits<decltype(lambda_350)>::arity == 3);
static_assert(callable_traits<decltype(lambda_350)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_350)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_350)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_350)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_350)>::is_const == true);
static_assert(callable_traits<decltype(lambda_350)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_350)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_350)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_350)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_350)>::class_type, std::remove_const_t<decltype(lambda_350)>>);
[[maybe_unused]] const auto lambda_351 = [](const bool * const volatile &&, volatile bool * const volatile &&, const volatile bool * const volatile &&, ...) mutable noexcept -> volatile float & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_351)>::result_type, volatile float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_351)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_351)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_351)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_351)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_351)>::arg0_type, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_351)>::arg_type<0>, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_351)>::arg1_type, volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_351)>::arg_type<1>, volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_351)>::arg2_type, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_351)>::arg_type<2>, const volatile bool * const volatile &&>);
static_assert(callable_traits<decltype(lambda_351)>::arity == 3);
static_assert(callable_traits<decltype(lambda_351)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_351)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_351)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_351)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_351)>::is_const == false);
static_assert(callable_traits<decltype(lambda_351)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_351)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_351)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_351)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_351)>::class_type, std::remove_const_t<decltype(lambda_351)>>);
[[maybe_unused]] const auto lambda_352 = [](int, int *, const int *) -> const volatile float & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_352)>::result_type, const volatile float &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_352)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_352)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_352)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_352)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_352)>::arg0_type, int>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_352)>::arg_type<0>, int>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_352)>::arg1_type, int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_352)>::arg_type<1>, int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_352)>::arg2_type, const int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_352)>::arg_type<2>, const int *>);
static_assert(callable_traits<decltype(lambda_352)>::arity == 3);
static_assert(callable_traits<decltype(lambda_352)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_352)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_352)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_352)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_352)>::is_const == true);
static_assert(callable_traits<decltype(lambda_352)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_352)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_352)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_352)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_352)>::class_type, std::remove_const_t<decltype(lambda_352)>>);
[[maybe_unused]] const auto lambda_353 = [](volatile int *, const volatile int *, int &, ...) mutable -> float * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_353)>::result_type, float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_353)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_353)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_353)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_353)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_353)>::arg0_type, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_353)>::arg_type<0>, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_353)>::arg1_type, const volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_353)>::arg_type<1>, const volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_353)>::arg2_type, int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_353)>::arg_type<2>, int &>);
static_assert(callable_traits<decltype(lambda_353)>::arity == 3);
static_assert(callable_traits<decltype(lambda_353)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_353)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_353)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_353)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_353)>::is_const == false);
static_assert(callable_traits<decltype(lambda_353)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_353)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_353)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_353)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_353)>::class_type, std::remove_const_t<decltype(lambda_353)>>);
[[maybe_unused]] const auto lambda_354 = [](const int &, volatile int &, const volatile int &) noexcept -> const float * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_354)>::result_type, const float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_354)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_354)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_354)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_354)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_354)>::arg0_type, const int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_354)>::arg_type<0>, const int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_354)>::arg1_type, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_354)>::arg_type<1>, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_354)>::arg2_type, const volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_354)>::arg_type<2>, const volatile int &>);
static_assert(callable_traits<decltype(lambda_354)>::arity == 3);
static_assert(callable_traits<decltype(lambda_354)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_354)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_354)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_354)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_354)>::is_const == true);
static_assert(callable_traits<decltype(lambda_354)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_354)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_354)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_354)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_354)>::class_type, std::remove_const_t<decltype(lambda_354)>>);
[[maybe_unused]] const auto lambda_355 = [](int * &, const int * &, volatile int * &, ...) mutable noexcept -> volatile float * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_355)>::result_type, volatile float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_355)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_355)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_355)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_355)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_355)>::arg0_type, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_355)>::arg_type<0>, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_355)>::arg1_type, const int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_355)>::arg_type<1>, const int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_355)>::arg2_type, volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_355)>::arg_type<2>, volatile int * &>);
static_assert(callable_traits<decltype(lambda_355)>::arity == 3);
static_assert(callable_traits<decltype(lambda_355)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_355)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_355)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_355)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_355)>::is_const == false);
static_assert(callable_traits<decltype(lambda_355)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_355)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_355)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_355)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_355)>::class_type, std::remove_const_t<decltype(lambda_355)>>);
[[maybe_unused]] const auto lambda_356 = [](const volatile int * &, int * const &, const int * const &) -> const volatile float * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_356)>::result_type, const volatile float * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_356)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_356)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_356)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_356)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_356)>::arg0_type, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_356)>::arg_type<0>, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_356)>::arg1_type, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_356)>::arg_type<1>, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_356)>::arg2_type, const int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_356)>::arg_type<2>, const int * const &>);
static_assert(callable_traits<decltype(lambda_356)>::arity == 3);
static_assert(callable_traits<decltype(lambda_356)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_356)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_356)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_356)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_356)>::is_const == true);
static_assert(callable_traits<decltype(lambda_356)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_356)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_356)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_356)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_356)>::class_type, std::remove_const_t<decltype(lambda_356)>>);
[[maybe_unused]] const auto lambda_357 = [](volatile int * const &, const volatile int * const &, int * volatile &, ...) mutable -> float * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_357)>::result_type, float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_357)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_357)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_357)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_357)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_357)>::arg0_type, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_357)>::arg_type<0>, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_357)>::arg1_type, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_357)>::arg_type<1>, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_357)>::arg2_type, int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_357)>::arg_type<2>, int * volatile &>);
static_assert(callable_traits<decltype(lambda_357)>::arity == 3);
static_assert(callable_traits<decltype(lambda_357)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_357)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_357)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_357)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_357)>::is_const == false);
static_assert(callable_traits<decltype(lambda_357)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_357)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_357)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_357)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_357)>::class_type, std::remove_const_t<decltype(lambda_357)>>);
[[maybe_unused]] const auto lambda_358 = [](const int * volatile &, volatile int * volatile &, const volatile int * volatile &) noexcept -> const float * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_358)>::result_type, const float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_358)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_358)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_358)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_358)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_358)>::arg0_type, const int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_358)>::arg_type<0>, const int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_358)>::arg1_type, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_358)>::arg_type<1>, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_358)>::arg2_type, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_358)>::arg_type<2>, const volatile int * volatile &>);
static_assert(callable_traits<decltype(lambda_358)>::arity == 3);
static_assert(callable_traits<decltype(lambda_358)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_358)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_358)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_358)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_358)>::is_const == true);
static_assert(callable_traits<decltype(lambda_358)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_358)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_358)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_358)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_358)>::class_type, std::remove_const_t<decltype(lambda_358)>>);
[[maybe_unused]] const auto lambda_359 = [](int * const volatile &, const int * const volatile &, volatile int * const volatile &, ...) mutable noexcept -> volatile float * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_359)>::result_type, volatile float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_359)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_359)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_359)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_359)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_359)>::arg0_type, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_359)>::arg_type<0>, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_359)>::arg1_type, const int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_359)>::arg_type<1>, const int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_359)>::arg2_type, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_359)>::arg_type<2>, volatile int * const volatile &>);
static_assert(callable_traits<decltype(lambda_359)>::arity == 3);
static_assert(callable_traits<decltype(lambda_359)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_359)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_359)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_359)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_359)>::is_const == false);
static_assert(callable_traits<decltype(lambda_359)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_359)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_359)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_359)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_359)>::class_type, std::remove_const_t<decltype(lambda_359)>>);
[[maybe_unused]] const auto lambda_360 = [](const volatile int * const volatile &, int &&, const int &&) -> const volatile float * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_360)>::result_type, const volatile float * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_360)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_360)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_360)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_360)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_360)>::arg0_type, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_360)>::arg_type<0>, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_360)>::arg1_type, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_360)>::arg_type<1>, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_360)>::arg2_type, const int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_360)>::arg_type<2>, const int &&>);
static_assert(callable_traits<decltype(lambda_360)>::arity == 3);
static_assert(callable_traits<decltype(lambda_360)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_360)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_360)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_360)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_360)>::is_const == true);
static_assert(callable_traits<decltype(lambda_360)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_360)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_360)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_360)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_360)>::class_type, std::remove_const_t<decltype(lambda_360)>>);
[[maybe_unused]] const auto lambda_361 = [](volatile int &&, const volatile int &&, int * &&, ...) mutable -> float * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_361)>::result_type, float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_361)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_361)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_361)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_361)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_361)>::arg0_type, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_361)>::arg_type<0>, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_361)>::arg1_type, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_361)>::arg_type<1>, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_361)>::arg2_type, int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_361)>::arg_type<2>, int * &&>);
static_assert(callable_traits<decltype(lambda_361)>::arity == 3);
static_assert(callable_traits<decltype(lambda_361)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_361)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_361)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_361)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_361)>::is_const == false);
static_assert(callable_traits<decltype(lambda_361)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_361)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_361)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_361)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_361)>::class_type, std::remove_const_t<decltype(lambda_361)>>);
[[maybe_unused]] const auto lambda_362 = [](const int * &&, volatile int * &&, const volatile int * &&) noexcept -> const float * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_362)>::result_type, const float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_362)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_362)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_362)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_362)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_362)>::arg0_type, const int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_362)>::arg_type<0>, const int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_362)>::arg1_type, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_362)>::arg_type<1>, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_362)>::arg2_type, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_362)>::arg_type<2>, const volatile int * &&>);
static_assert(callable_traits<decltype(lambda_362)>::arity == 3);
static_assert(callable_traits<decltype(lambda_362)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_362)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_362)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_362)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_362)>::is_const == true);
static_assert(callable_traits<decltype(lambda_362)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_362)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_362)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_362)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_362)>::class_type, std::remove_const_t<decltype(lambda_362)>>);
[[maybe_unused]] const auto lambda_363 = [](int * const &&, const int * const &&, volatile int * const &&, ...) mutable noexcept -> volatile float * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_363)>::result_type, volatile float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_363)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_363)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_363)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_363)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_363)>::arg0_type, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_363)>::arg_type<0>, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_363)>::arg1_type, const int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_363)>::arg_type<1>, const int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_363)>::arg2_type, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_363)>::arg_type<2>, volatile int * const &&>);
static_assert(callable_traits<decltype(lambda_363)>::arity == 3);
static_assert(callable_traits<decltype(lambda_363)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_363)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_363)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_363)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_363)>::is_const == false);
static_assert(callable_traits<decltype(lambda_363)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_363)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_363)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_363)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_363)>::class_type, std::remove_const_t<decltype(lambda_363)>>);
[[maybe_unused]] const auto lambda_364 = [](const volatile int * const &&, int * volatile &&, const int * volatile &&) -> const volatile float * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_364)>::result_type, const volatile float * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_364)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_364)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_364)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_364)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_364)>::arg0_type, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_364)>::arg_type<0>, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_364)>::arg1_type, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_364)>::arg_type<1>, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_364)>::arg2_type, const int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_364)>::arg_type<2>, const int * volatile &&>);
static_assert(callable_traits<decltype(lambda_364)>::arity == 3);
static_assert(callable_traits<decltype(lambda_364)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_364)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_364)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_364)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_364)>::is_const == true);
static_assert(callable_traits<decltype(lambda_364)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_364)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_364)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_364)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_364)>::class_type, std::remove_const_t<decltype(lambda_364)>>);
[[maybe_unused]] const auto lambda_365 = [](volatile int * volatile &&, const volatile int * volatile &&, int * const volatile &&, ...) mutable -> float * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_365)>::result_type, float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_365)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_365)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_365)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_365)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_365)>::arg0_type, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_365)>::arg_type<0>, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_365)>::arg1_type, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_365)>::arg_type<1>, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_365)>::arg2_type, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_365)>::arg_type<2>, int * const volatile &&>);
static_assert(callable_traits<decltype(lambda_365)>::arity == 3);
static_assert(callable_traits<decltype(lambda_365)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_365)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_365)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_365)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_365)>::is_const == false);
static_assert(callable_traits<decltype(lambda_365)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_365)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_365)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_365)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_365)>::class_type, std::remove_const_t<decltype(lambda_365)>>);
[[maybe_unused]] const auto lambda_366 = [](const int * const volatile &&, volatile int * const volatile &&, const volatile int * const volatile &&) noexcept -> const float * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_366)>::result_type, const float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_366)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_366)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_366)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_366)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_366)>::arg0_type, const int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_366)>::arg_type<0>, const int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_366)>::arg1_type, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_366)>::arg_type<1>, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_366)>::arg2_type, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_366)>::arg_type<2>, const volatile int * const volatile &&>);
static_assert(callable_traits<decltype(lambda_366)>::arity == 3);
static_assert(callable_traits<decltype(lambda_366)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_366)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_366)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_366)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_366)>::is_const == true);
static_assert(callable_traits<decltype(lambda_366)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_366)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_366)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_366)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_366)>::class_type, std::remove_const_t<decltype(lambda_366)>>);
[[maybe_unused]] const auto lambda_367 = [](float, float *, const float *, ...) mutable noexcept -> volatile float * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_367)>::result_type, volatile float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_367)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_367)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_367)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_367)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_367)>::arg0_type, float>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_367)>::arg_type<0>, float>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_367)>::arg1_type, float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_367)>::arg_type<1>, float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_367)>::arg2_type, const float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_367)>::arg_type<2>, const float *>);
static_assert(callable_traits<decltype(lambda_367)>::arity == 3);
static_assert(callable_traits<decltype(lambda_367)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_367)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_367)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_367)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_367)>::is_const == false);
static_assert(callable_traits<decltype(lambda_367)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_367)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_367)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_367)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_367)>::class_type, std::remove_const_t<decltype(lambda_367)>>);
[[maybe_unused]] const auto lambda_368 = [](volatile float *, const volatile float *, float &) -> const volatile float * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_368)>::result_type, const volatile float * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_368)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_368)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_368)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_368)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_368)>::arg0_type, volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_368)>::arg_type<0>, volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_368)>::arg1_type, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_368)>::arg_type<1>, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_368)>::arg2_type, float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_368)>::arg_type<2>, float &>);
static_assert(callable_traits<decltype(lambda_368)>::arity == 3);
static_assert(callable_traits<decltype(lambda_368)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_368)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_368)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_368)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_368)>::is_const == true);
static_assert(callable_traits<decltype(lambda_368)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_368)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_368)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_368)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_368)>::class_type, std::remove_const_t<decltype(lambda_368)>>);
[[maybe_unused]] const auto lambda_369 = [](const float &, volatile float &, const volatile float &, ...) mutable -> float && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_369)>::result_type, float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_369)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_369)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_369)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_369)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_369)>::arg0_type, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_369)>::arg_type<0>, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_369)>::arg1_type, volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_369)>::arg_type<1>, volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_369)>::arg2_type, const volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_369)>::arg_type<2>, const volatile float &>);
static_assert(callable_traits<decltype(lambda_369)>::arity == 3);
static_assert(callable_traits<decltype(lambda_369)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_369)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_369)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_369)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_369)>::is_const == false);
static_assert(callable_traits<decltype(lambda_369)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_369)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_369)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_369)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_369)>::class_type, std::remove_const_t<decltype(lambda_369)>>);
[[maybe_unused]] const auto lambda_370 = [](float * &, const float * &, volatile float * &) noexcept -> const float && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_370)>::result_type, const float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_370)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_370)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_370)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_370)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_370)>::arg0_type, float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_370)>::arg_type<0>, float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_370)>::arg1_type, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_370)>::arg_type<1>, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_370)>::arg2_type, volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_370)>::arg_type<2>, volatile float * &>);
static_assert(callable_traits<decltype(lambda_370)>::arity == 3);
static_assert(callable_traits<decltype(lambda_370)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_370)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_370)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_370)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_370)>::is_const == true);
static_assert(callable_traits<decltype(lambda_370)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_370)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_370)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_370)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_370)>::class_type, std::remove_const_t<decltype(lambda_370)>>);
[[maybe_unused]] const auto lambda_371 = [](const volatile float * &, float * const &, const float * const &, ...) mutable noexcept -> volatile float && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_371)>::result_type, volatile float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_371)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_371)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_371)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_371)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_371)>::arg0_type, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_371)>::arg_type<0>, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_371)>::arg1_type, float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_371)>::arg_type<1>, float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_371)>::arg2_type, const float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_371)>::arg_type<2>, const float * const &>);
static_assert(callable_traits<decltype(lambda_371)>::arity == 3);
static_assert(callable_traits<decltype(lambda_371)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_371)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_371)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_371)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_371)>::is_const == false);
static_assert(callable_traits<decltype(lambda_371)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_371)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_371)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_371)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_371)>::class_type, std::remove_const_t<decltype(lambda_371)>>);
[[maybe_unused]] const auto lambda_372 = [](volatile float * const &, const volatile float * const &, float * volatile &) -> const volatile float && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_372)>::result_type, const volatile float &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_372)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_372)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_372)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_372)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_372)>::arg0_type, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_372)>::arg_type<0>, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_372)>::arg1_type, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_372)>::arg_type<1>, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_372)>::arg2_type, float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_372)>::arg_type<2>, float * volatile &>);
static_assert(callable_traits<decltype(lambda_372)>::arity == 3);
static_assert(callable_traits<decltype(lambda_372)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_372)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_372)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_372)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_372)>::is_const == true);
static_assert(callable_traits<decltype(lambda_372)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_372)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_372)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_372)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_372)>::class_type, std::remove_const_t<decltype(lambda_372)>>);
[[maybe_unused]] const auto lambda_373 = [](const float * volatile &, volatile float * volatile &, const volatile float * volatile &, ...) mutable -> float * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_373)>::result_type, float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_373)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_373)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_373)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_373)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_373)>::arg0_type, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_373)>::arg_type<0>, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_373)>::arg1_type, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_373)>::arg_type<1>, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_373)>::arg2_type, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_373)>::arg_type<2>, const volatile float * volatile &>);
static_assert(callable_traits<decltype(lambda_373)>::arity == 3);
static_assert(callable_traits<decltype(lambda_373)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_373)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_373)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_373)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_373)>::is_const == false);
static_assert(callable_traits<decltype(lambda_373)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_373)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_373)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_373)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_373)>::class_type, std::remove_const_t<decltype(lambda_373)>>);
[[maybe_unused]] const auto lambda_374 = [](float * const volatile &, const float * const volatile &, volatile float * const volatile &) noexcept -> const float * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_374)>::result_type, const float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_374)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_374)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_374)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_374)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_374)>::arg0_type, float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_374)>::arg_type<0>, float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_374)>::arg1_type, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_374)>::arg_type<1>, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_374)>::arg2_type, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_374)>::arg_type<2>, volatile float * const volatile &>);
static_assert(callable_traits<decltype(lambda_374)>::arity == 3);
static_assert(callable_traits<decltype(lambda_374)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_374)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_374)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_374)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_374)>::is_const == true);
static_assert(callable_traits<decltype(lambda_374)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_374)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_374)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_374)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_374)>::class_type, std::remove_const_t<decltype(lambda_374)>>);
[[maybe_unused]] const auto lambda_375 = [](const volatile float * const volatile &, float &&, const float &&, ...) mutable noexcept -> volatile float * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_375)>::result_type, volatile float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_375)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_375)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_375)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_375)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_375)>::arg0_type, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_375)>::arg_type<0>, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_375)>::arg1_type, float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_375)>::arg_type<1>, float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_375)>::arg2_type, const float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_375)>::arg_type<2>, const float &&>);
static_assert(callable_traits<decltype(lambda_375)>::arity == 3);
static_assert(callable_traits<decltype(lambda_375)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_375)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_375)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_375)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_375)>::is_const == false);
static_assert(callable_traits<decltype(lambda_375)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_375)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_375)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_375)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_375)>::class_type, std::remove_const_t<decltype(lambda_375)>>);
[[maybe_unused]] const auto lambda_376 = [](volatile float &&, const volatile float &&, float * &&) -> const volatile float * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_376)>::result_type, const volatile float * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_376)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_376)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_376)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_376)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_376)>::arg0_type, volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_376)>::arg_type<0>, volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_376)>::arg1_type, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_376)>::arg_type<1>, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_376)>::arg2_type, float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_376)>::arg_type<2>, float * &&>);
static_assert(callable_traits<decltype(lambda_376)>::arity == 3);
static_assert(callable_traits<decltype(lambda_376)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_376)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_376)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_376)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_376)>::is_const == true);
static_assert(callable_traits<decltype(lambda_376)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_376)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_376)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_376)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_376)>::class_type, std::remove_const_t<decltype(lambda_376)>>);
[[maybe_unused]] const auto lambda_377 = [](const float * &&, volatile float * &&, const volatile float * &&, ...) mutable -> float * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_377)>::result_type, float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_377)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_377)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_377)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_377)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_377)>::arg0_type, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_377)>::arg_type<0>, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_377)>::arg1_type, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_377)>::arg_type<1>, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_377)>::arg2_type, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_377)>::arg_type<2>, const volatile float * &&>);
static_assert(callable_traits<decltype(lambda_377)>::arity == 3);
static_assert(callable_traits<decltype(lambda_377)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_377)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_377)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_377)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_377)>::is_const == false);
static_assert(callable_traits<decltype(lambda_377)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_377)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_377)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_377)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_377)>::class_type, std::remove_const_t<decltype(lambda_377)>>);
[[maybe_unused]] const auto lambda_378 = [](float * const &&, const float * const &&, volatile float * const &&) noexcept -> const float * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_378)>::result_type, const float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_378)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_378)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_378)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_378)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_378)>::arg0_type, float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_378)>::arg_type<0>, float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_378)>::arg1_type, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_378)>::arg_type<1>, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_378)>::arg2_type, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_378)>::arg_type<2>, volatile float * const &&>);
static_assert(callable_traits<decltype(lambda_378)>::arity == 3);
static_assert(callable_traits<decltype(lambda_378)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_378)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_378)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_378)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_378)>::is_const == true);
static_assert(callable_traits<decltype(lambda_378)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_378)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_378)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_378)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_378)>::class_type, std::remove_const_t<decltype(lambda_378)>>);
[[maybe_unused]] const auto lambda_379 = [](const volatile float * const &&, float * volatile &&, const float * volatile &&, ...) mutable noexcept -> volatile float * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_379)>::result_type, volatile float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_379)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_379)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_379)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_379)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_379)>::arg0_type, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_379)>::arg_type<0>, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_379)>::arg1_type, float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_379)>::arg_type<1>, float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_379)>::arg2_type, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_379)>::arg_type<2>, const float * volatile &&>);
static_assert(callable_traits<decltype(lambda_379)>::arity == 3);
static_assert(callable_traits<decltype(lambda_379)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_379)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_379)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_379)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_379)>::is_const == false);
static_assert(callable_traits<decltype(lambda_379)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_379)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_379)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_379)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_379)>::class_type, std::remove_const_t<decltype(lambda_379)>>);
[[maybe_unused]] const auto lambda_380 = [](volatile float * volatile &&, const volatile float * volatile &&, float * const volatile &&) -> const volatile float * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_380)>::result_type, const volatile float * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_380)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_380)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_380)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_380)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_380)>::arg0_type, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_380)>::arg_type<0>, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_380)>::arg1_type, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_380)>::arg_type<1>, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_380)>::arg2_type, float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_380)>::arg_type<2>, float * const volatile &&>);
static_assert(callable_traits<decltype(lambda_380)>::arity == 3);
static_assert(callable_traits<decltype(lambda_380)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_380)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_380)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_380)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_380)>::is_const == true);
static_assert(callable_traits<decltype(lambda_380)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_380)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_380)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_380)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_380)>::class_type, std::remove_const_t<decltype(lambda_380)>>);
[[maybe_unused]] const auto lambda_381 = [](const float * const volatile &&, volatile float * const volatile &&, const volatile float * const volatile &&, ...) mutable -> float * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_381)>::result_type, float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_381)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_381)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_381)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_381)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_381)>::arg0_type, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_381)>::arg_type<0>, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_381)>::arg1_type, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_381)>::arg_type<1>, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_381)>::arg2_type, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_381)>::arg_type<2>, const volatile float * const volatile &&>);
static_assert(callable_traits<decltype(lambda_381)>::arity == 3);
static_assert(callable_traits<decltype(lambda_381)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_381)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_381)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_381)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_381)>::is_const == false);
static_assert(callable_traits<decltype(lambda_381)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_381)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_381)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_381)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_381)>::class_type, std::remove_const_t<decltype(lambda_381)>>);
[[maybe_unused]] const auto lambda_382 = [](std::string, std::string *, const std::string *) noexcept -> const float * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_382)>::result_type, const float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_382)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_382)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_382)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_382)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_382)>::arg0_type, std::string>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_382)>::arg_type<0>, std::string>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_382)>::arg1_type, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_382)>::arg_type<1>, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_382)>::arg2_type, const std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_382)>::arg_type<2>, const std::string *>);
static_assert(callable_traits<decltype(lambda_382)>::arity == 3);
static_assert(callable_traits<decltype(lambda_382)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_382)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_382)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_382)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_382)>::is_const == true);
static_assert(callable_traits<decltype(lambda_382)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_382)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_382)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_382)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_382)>::class_type, std::remove_const_t<decltype(lambda_382)>>);
[[maybe_unused]] const auto lambda_383 = [](volatile std::string *, const volatile std::string *, std::string &, ...) mutable noexcept -> volatile float * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_383)>::result_type, volatile float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_383)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_383)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_383)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_383)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_383)>::arg0_type, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_383)>::arg_type<0>, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_383)>::arg1_type, const volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_383)>::arg_type<1>, const volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_383)>::arg2_type, std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_383)>::arg_type<2>, std::string &>);
static_assert(callable_traits<decltype(lambda_383)>::arity == 3);
static_assert(callable_traits<decltype(lambda_383)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_383)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_383)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_383)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_383)>::is_const == false);
static_assert(callable_traits<decltype(lambda_383)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_383)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_383)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_383)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_383)>::class_type, std::remove_const_t<decltype(lambda_383)>>);
[[maybe_unused]] const auto lambda_384 = [](const std::string &, volatile std::string &, const volatile std::string &) -> const volatile float * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_384)>::result_type, const volatile float * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_384)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_384)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_384)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_384)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_384)>::arg0_type, const std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_384)>::arg_type<0>, const std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_384)>::arg1_type, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_384)>::arg_type<1>, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_384)>::arg2_type, const volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_384)>::arg_type<2>, const volatile std::string &>);
static_assert(callable_traits<decltype(lambda_384)>::arity == 3);
static_assert(callable_traits<decltype(lambda_384)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_384)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_384)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_384)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_384)>::is_const == true);
static_assert(callable_traits<decltype(lambda_384)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_384)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_384)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_384)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_384)>::class_type, std::remove_const_t<decltype(lambda_384)>>);
[[maybe_unused]] const auto lambda_385 = [](std::string * &, const std::string * &, volatile std::string * &, ...) mutable -> float * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_385)>::result_type, float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_385)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_385)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_385)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_385)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_385)>::arg0_type, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_385)>::arg_type<0>, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_385)>::arg1_type, const std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_385)>::arg_type<1>, const std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_385)>::arg2_type, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_385)>::arg_type<2>, volatile std::string * &>);
static_assert(callable_traits<decltype(lambda_385)>::arity == 3);
static_assert(callable_traits<decltype(lambda_385)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_385)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_385)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_385)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_385)>::is_const == false);
static_assert(callable_traits<decltype(lambda_385)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_385)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_385)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_385)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_385)>::class_type, std::remove_const_t<decltype(lambda_385)>>);
[[maybe_unused]] const auto lambda_386 = [](const volatile std::string * &, std::string * const &, const std::string * const &) noexcept -> const float * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_386)>::result_type, const float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_386)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_386)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_386)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_386)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_386)>::arg0_type, const volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_386)>::arg_type<0>, const volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_386)>::arg1_type, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_386)>::arg_type<1>, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_386)>::arg2_type, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_386)>::arg_type<2>, const std::string * const &>);
static_assert(callable_traits<decltype(lambda_386)>::arity == 3);
static_assert(callable_traits<decltype(lambda_386)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_386)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_386)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_386)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_386)>::is_const == true);
static_assert(callable_traits<decltype(lambda_386)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_386)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_386)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_386)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_386)>::class_type, std::remove_const_t<decltype(lambda_386)>>);
[[maybe_unused]] const auto lambda_387 = [](volatile std::string * const &, const volatile std::string * const &, std::string * volatile &, ...) mutable noexcept -> volatile float * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_387)>::result_type, volatile float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_387)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_387)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_387)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_387)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_387)>::arg0_type, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_387)>::arg_type<0>, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_387)>::arg1_type, const volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_387)>::arg_type<1>, const volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_387)>::arg2_type, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_387)>::arg_type<2>, std::string * volatile &>);
static_assert(callable_traits<decltype(lambda_387)>::arity == 3);
static_assert(callable_traits<decltype(lambda_387)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_387)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_387)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_387)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_387)>::is_const == false);
static_assert(callable_traits<decltype(lambda_387)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_387)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_387)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_387)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_387)>::class_type, std::remove_const_t<decltype(lambda_387)>>);
[[maybe_unused]] const auto lambda_388 = [](const std::string * volatile &, volatile std::string * volatile &, const volatile std::string * volatile &) -> const volatile float * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_388)>::result_type, const volatile float * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_388)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_388)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_388)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_388)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_388)>::arg0_type, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_388)>::arg_type<0>, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_388)>::arg1_type, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_388)>::arg_type<1>, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_388)>::arg2_type, const volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_388)>::arg_type<2>, const volatile std::string * volatile &>);
static_assert(callable_traits<decltype(lambda_388)>::arity == 3);
static_assert(callable_traits<decltype(lambda_388)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_388)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_388)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_388)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_388)>::is_const == true);
static_assert(callable_traits<decltype(lambda_388)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_388)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_388)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_388)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_388)>::class_type, std::remove_const_t<decltype(lambda_388)>>);
[[maybe_unused]] const auto lambda_389 = [](std::string * const volatile &, const std::string * const volatile &, volatile std::string * const volatile &, ...) mutable -> std::string {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_389)>::result_type, std::string>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_389)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_389)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_389)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_389)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_389)>::arg0_type, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_389)>::arg_type<0>, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_389)>::arg1_type, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_389)>::arg_type<1>, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_389)>::arg2_type, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_389)>::arg_type<2>, volatile std::string * const volatile &>);
static_assert(callable_traits<decltype(lambda_389)>::arity == 3);
static_assert(callable_traits<decltype(lambda_389)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_389)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_389)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_389)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_389)>::is_const == false);
static_assert(callable_traits<decltype(lambda_389)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_389)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_389)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_389)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_389)>::class_type, std::remove_const_t<decltype(lambda_389)>>);
[[maybe_unused]] const auto lambda_390 = [](const volatile std::string * const volatile &, std::string &&, const std::string &&) noexcept -> std::string * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_390)>::result_type, std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_390)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_390)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_390)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_390)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_390)>::arg0_type, const volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_390)>::arg_type<0>, const volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_390)>::arg1_type, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_390)>::arg_type<1>, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_390)>::arg2_type, const std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_390)>::arg_type<2>, const std::string &&>);
static_assert(callable_traits<decltype(lambda_390)>::arity == 3);
static_assert(callable_traits<decltype(lambda_390)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_390)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_390)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_390)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_390)>::is_const == true);
static_assert(callable_traits<decltype(lambda_390)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_390)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_390)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_390)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_390)>::class_type, std::remove_const_t<decltype(lambda_390)>>);
[[maybe_unused]] const auto lambda_391 = [](volatile std::string &&, const volatile std::string &&, std::string * &&, ...) mutable noexcept -> const std::string * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_391)>::result_type, const std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_391)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_391)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_391)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_391)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_391)>::arg0_type, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_391)>::arg_type<0>, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_391)>::arg1_type, const volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_391)>::arg_type<1>, const volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_391)>::arg2_type, std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_391)>::arg_type<2>, std::string * &&>);
static_assert(callable_traits<decltype(lambda_391)>::arity == 3);
static_assert(callable_traits<decltype(lambda_391)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_391)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_391)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_391)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_391)>::is_const == false);
static_assert(callable_traits<decltype(lambda_391)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_391)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_391)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_391)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_391)>::class_type, std::remove_const_t<decltype(lambda_391)>>);
[[maybe_unused]] const auto lambda_392 = [](const std::string * &&, volatile std::string * &&, const volatile std::string * &&) -> volatile std::string * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_392)>::result_type, volatile std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_392)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_392)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_392)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_392)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_392)>::arg0_type, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_392)>::arg_type<0>, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_392)>::arg1_type, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_392)>::arg_type<1>, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_392)>::arg2_type, const volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_392)>::arg_type<2>, const volatile std::string * &&>);
static_assert(callable_traits<decltype(lambda_392)>::arity == 3);
static_assert(callable_traits<decltype(lambda_392)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_392)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_392)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_392)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_392)>::is_const == true);
static_assert(callable_traits<decltype(lambda_392)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_392)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_392)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_392)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_392)>::class_type, std::remove_const_t<decltype(lambda_392)>>);
[[maybe_unused]] const auto lambda_393 = [](std::string * const &&, const std::string * const &&, volatile std::string * const &&, ...) mutable -> const volatile std::string * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_393)>::result_type, const volatile std::string *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_393)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_393)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_393)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_393)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_393)>::arg0_type, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_393)>::arg_type<0>, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_393)>::arg1_type, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_393)>::arg_type<1>, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_393)>::arg2_type, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_393)>::arg_type<2>, volatile std::string * const &&>);
static_assert(callable_traits<decltype(lambda_393)>::arity == 3);
static_assert(callable_traits<decltype(lambda_393)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_393)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_393)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_393)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_393)>::is_const == false);
static_assert(callable_traits<decltype(lambda_393)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_393)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_393)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_393)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_393)>::class_type, std::remove_const_t<decltype(lambda_393)>>);
[[maybe_unused]] const auto lambda_394 = [](const volatile std::string * const &&, std::string * volatile &&, const std::string * volatile &&) noexcept -> std::string & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_394)>::result_type, std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_394)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_394)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_394)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_394)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_394)>::arg0_type, const volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_394)>::arg_type<0>, const volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_394)>::arg1_type, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_394)>::arg_type<1>, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_394)>::arg2_type, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_394)>::arg_type<2>, const std::string * volatile &&>);
static_assert(callable_traits<decltype(lambda_394)>::arity == 3);
static_assert(callable_traits<decltype(lambda_394)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_394)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_394)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_394)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_394)>::is_const == true);
static_assert(callable_traits<decltype(lambda_394)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_394)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_394)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_394)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_394)>::class_type, std::remove_const_t<decltype(lambda_394)>>);
[[maybe_unused]] const auto lambda_395 = [](volatile std::string * volatile &&, const volatile std::string * volatile &&, std::string * const volatile &&, ...) mutable noexcept -> const std::string & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_395)>::result_type, const std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_395)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_395)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_395)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_395)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_395)>::arg0_type, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_395)>::arg_type<0>, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_395)>::arg1_type, const volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_395)>::arg_type<1>, const volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_395)>::arg2_type, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_395)>::arg_type<2>, std::string * const volatile &&>);
static_assert(callable_traits<decltype(lambda_395)>::arity == 3);
static_assert(callable_traits<decltype(lambda_395)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_395)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_395)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_395)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_395)>::is_const == false);
static_assert(callable_traits<decltype(lambda_395)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_395)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_395)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_395)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_395)>::class_type, std::remove_const_t<decltype(lambda_395)>>);
[[maybe_unused]] const auto lambda_396 = [](const std::string * const volatile &&, volatile std::string * const volatile &&, const volatile std::string * const volatile &&) -> volatile std::string & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_396)>::result_type, volatile std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_396)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_396)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_396)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_396)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_396)>::arg0_type, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_396)>::arg_type<0>, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_396)>::arg1_type, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_396)>::arg_type<1>, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_396)>::arg2_type, const volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_396)>::arg_type<2>, const volatile std::string * const volatile &&>);
static_assert(callable_traits<decltype(lambda_396)>::arity == 3);
static_assert(callable_traits<decltype(lambda_396)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_396)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_396)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_396)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_396)>::is_const == true);
static_assert(callable_traits<decltype(lambda_396)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_396)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_396)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_396)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_396)>::class_type, std::remove_const_t<decltype(lambda_396)>>);
[[maybe_unused]] const auto lambda_397 = [](void *, const void *, volatile void *, const volatile void *, ...) mutable -> const volatile std::string & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_397)>::result_type, const volatile std::string &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_397)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_397)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_397)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_397)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_397)>::arg0_type, void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_397)>::arg_type<0>, void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_397)>::arg1_type, const void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_397)>::arg_type<1>, const void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_397)>::arg2_type, volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_397)>::arg_type<2>, volatile void *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_397)>::arg_type<3>, const volatile void *>);
static_assert(callable_traits<decltype(lambda_397)>::arity == 4);
static_assert(callable_traits<decltype(lambda_397)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_397)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_397)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_397)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_397)>::is_const == false);
static_assert(callable_traits<decltype(lambda_397)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_397)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_397)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_397)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_397)>::class_type, std::remove_const_t<decltype(lambda_397)>>);
[[maybe_unused]] const auto lambda_398 = [](void * &, const void * &, volatile void * &, const volatile void * &) noexcept -> std::string * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_398)>::result_type, std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_398)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_398)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_398)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_398)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_398)>::arg0_type, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_398)>::arg_type<0>, void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_398)>::arg1_type, const void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_398)>::arg_type<1>, const void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_398)>::arg2_type, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_398)>::arg_type<2>, volatile void * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_398)>::arg_type<3>, const volatile void * &>);
static_assert(callable_traits<decltype(lambda_398)>::arity == 4);
static_assert(callable_traits<decltype(lambda_398)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_398)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_398)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_398)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_398)>::is_const == true);
static_assert(callable_traits<decltype(lambda_398)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_398)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_398)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_398)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_398)>::class_type, std::remove_const_t<decltype(lambda_398)>>);
[[maybe_unused]] const auto lambda_399 = [](void * const &, const void * const &, volatile void * const &, const volatile void * const &, ...) mutable noexcept -> const std::string * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_399)>::result_type, const std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_399)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_399)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_399)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_399)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_399)>::arg0_type, void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_399)>::arg_type<0>, void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_399)>::arg1_type, const void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_399)>::arg_type<1>, const void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_399)>::arg2_type, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_399)>::arg_type<2>, volatile void * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_399)>::arg_type<3>, const volatile void * const &>);
static_assert(callable_traits<decltype(lambda_399)>::arity == 4);
static_assert(callable_traits<decltype(lambda_399)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_399)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_399)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_399)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_399)>::is_const == false);
static_assert(callable_traits<decltype(lambda_399)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_399)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_399)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_399)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_399)>::class_type, std::remove_const_t<decltype(lambda_399)>>);
[[maybe_unused]] const auto lambda_400 = [](void * volatile &, const void * volatile &, volatile void * volatile &, const volatile void * volatile &) -> volatile std::string * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_400)>::result_type, volatile std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_400)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_400)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_400)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_400)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_400)>::arg0_type, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_400)>::arg_type<0>, void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_400)>::arg1_type, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_400)>::arg_type<1>, const void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_400)>::arg2_type, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_400)>::arg_type<2>, volatile void * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_400)>::arg_type<3>, const volatile void * volatile &>);
static_assert(callable_traits<decltype(lambda_400)>::arity == 4);
static_assert(callable_traits<decltype(lambda_400)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_400)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_400)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_400)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_400)>::is_const == true);
static_assert(callable_traits<decltype(lambda_400)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_400)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_400)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_400)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_400)>::class_type, std::remove_const_t<decltype(lambda_400)>>);
[[maybe_unused]] const auto lambda_401 = [](void * const volatile &, const void * const volatile &, volatile void * const volatile &, const volatile void * const volatile &, ...) mutable -> const volatile std::string * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_401)>::result_type, const volatile std::string * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_401)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_401)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_401)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_401)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_401)>::arg0_type, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_401)>::arg_type<0>, void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_401)>::arg1_type, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_401)>::arg_type<1>, const void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_401)>::arg2_type, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_401)>::arg_type<2>, volatile void * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_401)>::arg_type<3>, const volatile void * const volatile &>);
static_assert(callable_traits<decltype(lambda_401)>::arity == 4);
static_assert(callable_traits<decltype(lambda_401)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_401)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_401)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_401)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_401)>::is_const == false);
static_assert(callable_traits<decltype(lambda_401)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_401)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_401)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_401)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_401)>::class_type, std::remove_const_t<decltype(lambda_401)>>);
[[maybe_unused]] const auto lambda_402 = [](void * &&, const void * &&, volatile void * &&, const volatile void * &&) noexcept -> std::string * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_402)>::result_type, std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_402)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_402)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_402)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_402)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_402)>::arg0_type, void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_402)>::arg_type<0>, void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_402)>::arg1_type, const void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_402)>::arg_type<1>, const void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_402)>::arg2_type, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_402)>::arg_type<2>, volatile void * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_402)>::arg_type<3>, const volatile void * &&>);
static_assert(callable_traits<decltype(lambda_402)>::arity == 4);
static_assert(callable_traits<decltype(lambda_402)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_402)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_402)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_402)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_402)>::is_const == true);
static_assert(callable_traits<decltype(lambda_402)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_402)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_402)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_402)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_402)>::class_type, std::remove_const_t<decltype(lambda_402)>>);
[[maybe_unused]] const auto lambda_403 = [](void * const &&, const void * const &&, volatile void * const &&, const volatile void * const &&, ...) mutable noexcept -> const std::string * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_403)>::result_type, const std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_403)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_403)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_403)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_403)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_403)>::arg0_type, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_403)>::arg_type<0>, void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_403)>::arg1_type, const void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_403)>::arg_type<1>, const void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_403)>::arg2_type, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_403)>::arg_type<2>, volatile void * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_403)>::arg_type<3>, const volatile void * const &&>);
static_assert(callable_traits<decltype(lambda_403)>::arity == 4);
static_assert(callable_traits<decltype(lambda_403)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_403)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_403)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_403)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_403)>::is_const == false);
static_assert(callable_traits<decltype(lambda_403)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_403)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_403)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_403)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_403)>::class_type, std::remove_const_t<decltype(lambda_403)>>);
[[maybe_unused]] const auto lambda_404 = [](void * volatile &&, const void * volatile &&, volatile void * volatile &&, const volatile void * volatile &&) -> volatile std::string * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_404)>::result_type, volatile std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_404)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_404)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_404)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_404)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_404)>::arg0_type, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_404)>::arg_type<0>, void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_404)>::arg1_type, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_404)>::arg_type<1>, const void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_404)>::arg2_type, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_404)>::arg_type<2>, volatile void * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_404)>::arg_type<3>, const volatile void * volatile &&>);
static_assert(callable_traits<decltype(lambda_404)>::arity == 4);
static_assert(callable_traits<decltype(lambda_404)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_404)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_404)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_404)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_404)>::is_const == true);
static_assert(callable_traits<decltype(lambda_404)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_404)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_404)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_404)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_404)>::class_type, std::remove_const_t<decltype(lambda_404)>>);
[[maybe_unused]] const auto lambda_405 = [](void * const volatile &&, const void * const volatile &&, volatile void * const volatile &&, const volatile void * const volatile &&, ...) mutable -> const volatile std::string * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_405)>::result_type, const volatile std::string * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_405)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_405)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_405)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_405)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_405)>::arg0_type, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_405)>::arg_type<0>, void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_405)>::arg1_type, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_405)>::arg_type<1>, const void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_405)>::arg2_type, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_405)>::arg_type<2>, volatile void * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_405)>::arg_type<3>, const volatile void * const volatile &&>);
static_assert(callable_traits<decltype(lambda_405)>::arity == 4);
static_assert(callable_traits<decltype(lambda_405)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_405)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_405)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_405)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_405)>::is_const == false);
static_assert(callable_traits<decltype(lambda_405)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_405)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_405)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_405)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_405)>::class_type, std::remove_const_t<decltype(lambda_405)>>);
[[maybe_unused]] const auto lambda_406 = [](bool, bool *, const bool *, volatile bool *) noexcept -> std::string * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_406)>::result_type, std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_406)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_406)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_406)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_406)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_406)>::arg0_type, bool>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_406)>::arg_type<0>, bool>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_406)>::arg1_type, bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_406)>::arg_type<1>, bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_406)>::arg2_type, const bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_406)>::arg_type<2>, const bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_406)>::arg_type<3>, volatile bool *>);
static_assert(callable_traits<decltype(lambda_406)>::arity == 4);
static_assert(callable_traits<decltype(lambda_406)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_406)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_406)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_406)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_406)>::is_const == true);
static_assert(callable_traits<decltype(lambda_406)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_406)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_406)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_406)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_406)>::class_type, std::remove_const_t<decltype(lambda_406)>>);
[[maybe_unused]] const auto lambda_407 = [](const volatile bool *, bool &, const bool &, volatile bool &, ...) mutable noexcept -> const std::string * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_407)>::result_type, const std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_407)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_407)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_407)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_407)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_407)>::arg0_type, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_407)>::arg_type<0>, const volatile bool *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_407)>::arg1_type, bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_407)>::arg_type<1>, bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_407)>::arg2_type, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_407)>::arg_type<2>, const bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_407)>::arg_type<3>, volatile bool &>);
static_assert(callable_traits<decltype(lambda_407)>::arity == 4);
static_assert(callable_traits<decltype(lambda_407)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_407)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_407)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_407)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_407)>::is_const == false);
static_assert(callable_traits<decltype(lambda_407)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_407)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_407)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_407)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_407)>::class_type, std::remove_const_t<decltype(lambda_407)>>);
[[maybe_unused]] const auto lambda_408 = [](const volatile bool &, bool * &, const bool * &, volatile bool * &) -> volatile std::string * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_408)>::result_type, volatile std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_408)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_408)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_408)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_408)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_408)>::arg0_type, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_408)>::arg_type<0>, const volatile bool &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_408)>::arg1_type, bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_408)>::arg_type<1>, bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_408)>::arg2_type, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_408)>::arg_type<2>, const bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_408)>::arg_type<3>, volatile bool * &>);
static_assert(callable_traits<decltype(lambda_408)>::arity == 4);
static_assert(callable_traits<decltype(lambda_408)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_408)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_408)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_408)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_408)>::is_const == true);
static_assert(callable_traits<decltype(lambda_408)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_408)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_408)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_408)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_408)>::class_type, std::remove_const_t<decltype(lambda_408)>>);
[[maybe_unused]] const auto lambda_409 = [](const volatile bool * &, bool * const &, const bool * const &, volatile bool * const &, ...) mutable -> const volatile std::string * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_409)>::result_type, const volatile std::string * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_409)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_409)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_409)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_409)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_409)>::arg0_type, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_409)>::arg_type<0>, const volatile bool * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_409)>::arg1_type, bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_409)>::arg_type<1>, bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_409)>::arg2_type, const bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_409)>::arg_type<2>, const bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_409)>::arg_type<3>, volatile bool * const &>);
static_assert(callable_traits<decltype(lambda_409)>::arity == 4);
static_assert(callable_traits<decltype(lambda_409)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_409)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_409)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_409)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_409)>::is_const == false);
static_assert(callable_traits<decltype(lambda_409)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_409)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_409)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_409)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_409)>::class_type, std::remove_const_t<decltype(lambda_409)>>);
[[maybe_unused]] const auto lambda_410 = [](const volatile bool * const &, bool * volatile &, const bool * volatile &, volatile bool * volatile &) noexcept -> std::string * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_410)>::result_type, std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_410)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_410)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_410)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_410)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_410)>::arg0_type, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_410)>::arg_type<0>, const volatile bool * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_410)>::arg1_type, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_410)>::arg_type<1>, bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_410)>::arg2_type, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_410)>::arg_type<2>, const bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_410)>::arg_type<3>, volatile bool * volatile &>);
static_assert(callable_traits<decltype(lambda_410)>::arity == 4);
static_assert(callable_traits<decltype(lambda_410)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_410)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_410)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_410)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_410)>::is_const == true);
static_assert(callable_traits<decltype(lambda_410)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_410)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_410)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_410)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_410)>::class_type, std::remove_const_t<decltype(lambda_410)>>);
[[maybe_unused]] const auto lambda_411 = [](const volatile bool * volatile &, bool * const volatile &, const bool * const volatile &, volatile bool * const volatile &, ...) mutable noexcept -> const std::string * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_411)>::result_type, const std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_411)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_411)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_411)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_411)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_411)>::arg0_type, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_411)>::arg_type<0>, const volatile bool * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_411)>::arg1_type, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_411)>::arg_type<1>, bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_411)>::arg2_type, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_411)>::arg_type<2>, const bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_411)>::arg_type<3>, volatile bool * const volatile &>);
static_assert(callable_traits<decltype(lambda_411)>::arity == 4);
static_assert(callable_traits<decltype(lambda_411)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_411)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_411)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_411)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_411)>::is_const == false);
static_assert(callable_traits<decltype(lambda_411)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_411)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_411)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_411)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_411)>::class_type, std::remove_const_t<decltype(lambda_411)>>);
[[maybe_unused]] const auto lambda_412 = [](const volatile bool * const volatile &, bool &&, const bool &&, volatile bool &&) -> volatile std::string * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_412)>::result_type, volatile std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_412)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_412)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_412)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_412)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_412)>::arg0_type, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_412)>::arg_type<0>, const volatile bool * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_412)>::arg1_type, bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_412)>::arg_type<1>, bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_412)>::arg2_type, const bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_412)>::arg_type<2>, const bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_412)>::arg_type<3>, volatile bool &&>);
static_assert(callable_traits<decltype(lambda_412)>::arity == 4);
static_assert(callable_traits<decltype(lambda_412)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_412)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_412)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_412)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_412)>::is_const == true);
static_assert(callable_traits<decltype(lambda_412)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_412)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_412)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_412)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_412)>::class_type, std::remove_const_t<decltype(lambda_412)>>);
[[maybe_unused]] const auto lambda_413 = [](const volatile bool &&, bool * &&, const bool * &&, volatile bool * &&, ...) mutable -> const volatile std::string * const volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_413)>::result_type, const volatile std::string * const volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_413)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_413)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_413)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_413)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_413)>::arg0_type, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_413)>::arg_type<0>, const volatile bool &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_413)>::arg1_type, bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_413)>::arg_type<1>, bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_413)>::arg2_type, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_413)>::arg_type<2>, const bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_413)>::arg_type<3>, volatile bool * &&>);
static_assert(callable_traits<decltype(lambda_413)>::arity == 4);
static_assert(callable_traits<decltype(lambda_413)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_413)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_413)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_413)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_413)>::is_const == false);
static_assert(callable_traits<decltype(lambda_413)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_413)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_413)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_413)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_413)>::class_type, std::remove_const_t<decltype(lambda_413)>>);
[[maybe_unused]] const auto lambda_414 = [](const volatile bool * &&, bool * const &&, const bool * const &&, volatile bool * const &&) noexcept -> std::string && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_414)>::result_type, std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_414)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_414)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_414)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_414)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_414)>::arg0_type, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_414)>::arg_type<0>, const volatile bool * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_414)>::arg1_type, bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_414)>::arg_type<1>, bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_414)>::arg2_type, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_414)>::arg_type<2>, const bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_414)>::arg_type<3>, volatile bool * const &&>);
static_assert(callable_traits<decltype(lambda_414)>::arity == 4);
static_assert(callable_traits<decltype(lambda_414)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_414)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_414)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_414)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_414)>::is_const == true);
static_assert(callable_traits<decltype(lambda_414)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_414)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_414)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_414)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_414)>::class_type, std::remove_const_t<decltype(lambda_414)>>);
[[maybe_unused]] const auto lambda_415 = [](const volatile bool * const &&, bool * volatile &&, const bool * volatile &&, volatile bool * volatile &&, ...) mutable noexcept -> const std::string && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_415)>::result_type, const std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_415)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_415)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_415)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_415)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_415)>::arg0_type, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_415)>::arg_type<0>, const volatile bool * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_415)>::arg1_type, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_415)>::arg_type<1>, bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_415)>::arg2_type, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_415)>::arg_type<2>, const bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_415)>::arg_type<3>, volatile bool * volatile &&>);
static_assert(callable_traits<decltype(lambda_415)>::arity == 4);
static_assert(callable_traits<decltype(lambda_415)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_415)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_415)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_415)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_415)>::is_const == false);
static_assert(callable_traits<decltype(lambda_415)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_415)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_415)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_415)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_415)>::class_type, std::remove_const_t<decltype(lambda_415)>>);
[[maybe_unused]] const auto lambda_416 = [](const volatile bool * volatile &&, bool * const volatile &&, const bool * const volatile &&, volatile bool * const volatile &&) -> volatile std::string && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_416)>::result_type, volatile std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_416)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_416)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_416)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_416)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_416)>::arg0_type, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_416)>::arg_type<0>, const volatile bool * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_416)>::arg1_type, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_416)>::arg_type<1>, bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_416)>::arg2_type, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_416)>::arg_type<2>, const bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_416)>::arg_type<3>, volatile bool * const volatile &&>);
static_assert(callable_traits<decltype(lambda_416)>::arity == 4);
static_assert(callable_traits<decltype(lambda_416)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_416)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_416)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_416)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_416)>::is_const == true);
static_assert(callable_traits<decltype(lambda_416)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_416)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_416)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_416)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_416)>::class_type, std::remove_const_t<decltype(lambda_416)>>);
[[maybe_unused]] const auto lambda_417 = [](const volatile bool * const volatile &&, int, int *, const int *, ...) mutable -> const volatile std::string && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_417)>::result_type, const volatile std::string &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_417)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_417)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_417)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_417)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_417)>::arg0_type, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_417)>::arg_type<0>, const volatile bool * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_417)>::arg1_type, int>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_417)>::arg_type<1>, int>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_417)>::arg2_type, int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_417)>::arg_type<2>, int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_417)>::arg_type<3>, const int *>);
static_assert(callable_traits<decltype(lambda_417)>::arity == 4);
static_assert(callable_traits<decltype(lambda_417)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_417)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_417)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_417)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_417)>::is_const == false);
static_assert(callable_traits<decltype(lambda_417)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_417)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_417)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_417)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_417)>::class_type, std::remove_const_t<decltype(lambda_417)>>);
[[maybe_unused]] const auto lambda_418 = [](volatile int *, const volatile int *, int &, const int &) noexcept -> std::string * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_418)>::result_type, std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_418)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_418)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_418)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_418)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_418)>::arg0_type, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_418)>::arg_type<0>, volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_418)>::arg1_type, const volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_418)>::arg_type<1>, const volatile int *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_418)>::arg2_type, int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_418)>::arg_type<2>, int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_418)>::arg_type<3>, const int &>);
static_assert(callable_traits<decltype(lambda_418)>::arity == 4);
static_assert(callable_traits<decltype(lambda_418)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_418)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_418)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_418)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_418)>::is_const == true);
static_assert(callable_traits<decltype(lambda_418)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_418)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_418)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_418)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_418)>::class_type, std::remove_const_t<decltype(lambda_418)>>);
[[maybe_unused]] const auto lambda_419 = [](volatile int &, const volatile int &, int * &, const int * &, ...) mutable noexcept -> const std::string * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_419)>::result_type, const std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_419)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_419)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_419)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_419)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_419)>::arg0_type, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_419)>::arg_type<0>, volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_419)>::arg1_type, const volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_419)>::arg_type<1>, const volatile int &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_419)>::arg2_type, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_419)>::arg_type<2>, int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_419)>::arg_type<3>, const int * &>);
static_assert(callable_traits<decltype(lambda_419)>::arity == 4);
static_assert(callable_traits<decltype(lambda_419)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_419)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_419)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_419)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_419)>::is_const == false);
static_assert(callable_traits<decltype(lambda_419)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_419)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_419)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_419)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_419)>::class_type, std::remove_const_t<decltype(lambda_419)>>);
[[maybe_unused]] const auto lambda_420 = [](volatile int * &, const volatile int * &, int * const &, const int * const &) -> volatile std::string * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_420)>::result_type, volatile std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_420)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_420)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_420)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_420)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_420)>::arg0_type, volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_420)>::arg_type<0>, volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_420)>::arg1_type, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_420)>::arg_type<1>, const volatile int * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_420)>::arg2_type, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_420)>::arg_type<2>, int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_420)>::arg_type<3>, const int * const &>);
static_assert(callable_traits<decltype(lambda_420)>::arity == 4);
static_assert(callable_traits<decltype(lambda_420)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_420)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_420)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_420)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_420)>::is_const == true);
static_assert(callable_traits<decltype(lambda_420)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_420)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_420)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_420)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_420)>::class_type, std::remove_const_t<decltype(lambda_420)>>);
[[maybe_unused]] const auto lambda_421 = [](volatile int * const &, const volatile int * const &, int * volatile &, const int * volatile &, ...) mutable -> const volatile std::string * && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_421)>::result_type, const volatile std::string * &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_421)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_421)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_421)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_421)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_421)>::arg0_type, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_421)>::arg_type<0>, volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_421)>::arg1_type, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_421)>::arg_type<1>, const volatile int * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_421)>::arg2_type, int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_421)>::arg_type<2>, int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_421)>::arg_type<3>, const int * volatile &>);
static_assert(callable_traits<decltype(lambda_421)>::arity == 4);
static_assert(callable_traits<decltype(lambda_421)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_421)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_421)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_421)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_421)>::is_const == false);
static_assert(callable_traits<decltype(lambda_421)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_421)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_421)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_421)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_421)>::class_type, std::remove_const_t<decltype(lambda_421)>>);
[[maybe_unused]] const auto lambda_422 = [](volatile int * volatile &, const volatile int * volatile &, int * const volatile &, const int * const volatile &) noexcept -> std::string * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_422)>::result_type, std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_422)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_422)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_422)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_422)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_422)>::arg0_type, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_422)>::arg_type<0>, volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_422)>::arg1_type, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_422)>::arg_type<1>, const volatile int * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_422)>::arg2_type, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_422)>::arg_type<2>, int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_422)>::arg_type<3>, const int * const volatile &>);
static_assert(callable_traits<decltype(lambda_422)>::arity == 4);
static_assert(callable_traits<decltype(lambda_422)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_422)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_422)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_422)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_422)>::is_const == true);
static_assert(callable_traits<decltype(lambda_422)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_422)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_422)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_422)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_422)>::class_type, std::remove_const_t<decltype(lambda_422)>>);
[[maybe_unused]] const auto lambda_423 = [](volatile int * const volatile &, const volatile int * const volatile &, int &&, const int &&, ...) mutable noexcept -> const std::string * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_423)>::result_type, const std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_423)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_423)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_423)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_423)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_423)>::arg0_type, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_423)>::arg_type<0>, volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_423)>::arg1_type, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_423)>::arg_type<1>, const volatile int * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_423)>::arg2_type, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_423)>::arg_type<2>, int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_423)>::arg_type<3>, const int &&>);
static_assert(callable_traits<decltype(lambda_423)>::arity == 4);
static_assert(callable_traits<decltype(lambda_423)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_423)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_423)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_423)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_423)>::is_const == false);
static_assert(callable_traits<decltype(lambda_423)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_423)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_423)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_423)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_423)>::class_type, std::remove_const_t<decltype(lambda_423)>>);
[[maybe_unused]] const auto lambda_424 = [](volatile int &&, const volatile int &&, int * &&, const int * &&) -> volatile std::string * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_424)>::result_type, volatile std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_424)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_424)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_424)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_424)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_424)>::arg0_type, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_424)>::arg_type<0>, volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_424)>::arg1_type, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_424)>::arg_type<1>, const volatile int &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_424)>::arg2_type, int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_424)>::arg_type<2>, int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_424)>::arg_type<3>, const int * &&>);
static_assert(callable_traits<decltype(lambda_424)>::arity == 4);
static_assert(callable_traits<decltype(lambda_424)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_424)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_424)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_424)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_424)>::is_const == true);
static_assert(callable_traits<decltype(lambda_424)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_424)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_424)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_424)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_424)>::class_type, std::remove_const_t<decltype(lambda_424)>>);
[[maybe_unused]] const auto lambda_425 = [](volatile int * &&, const volatile int * &&, int * const &&, const int * const &&, ...) mutable -> const volatile std::string * const && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_425)>::result_type, const volatile std::string * const &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_425)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_425)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_425)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_425)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_425)>::arg0_type, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_425)>::arg_type<0>, volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_425)>::arg1_type, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_425)>::arg_type<1>, const volatile int * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_425)>::arg2_type, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_425)>::arg_type<2>, int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_425)>::arg_type<3>, const int * const &&>);
static_assert(callable_traits<decltype(lambda_425)>::arity == 4);
static_assert(callable_traits<decltype(lambda_425)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_425)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_425)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_425)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_425)>::is_const == false);
static_assert(callable_traits<decltype(lambda_425)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_425)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_425)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_425)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_425)>::class_type, std::remove_const_t<decltype(lambda_425)>>);
[[maybe_unused]] const auto lambda_426 = [](volatile int * const &&, const volatile int * const &&, int * volatile &&, const int * volatile &&) noexcept -> std::string * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_426)>::result_type, std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_426)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_426)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_426)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_426)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_426)>::arg0_type, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_426)>::arg_type<0>, volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_426)>::arg1_type, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_426)>::arg_type<1>, const volatile int * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_426)>::arg2_type, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_426)>::arg_type<2>, int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_426)>::arg_type<3>, const int * volatile &&>);
static_assert(callable_traits<decltype(lambda_426)>::arity == 4);
static_assert(callable_traits<decltype(lambda_426)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_426)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_426)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_426)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_426)>::is_const == true);
static_assert(callable_traits<decltype(lambda_426)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_426)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_426)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_426)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_426)>::class_type, std::remove_const_t<decltype(lambda_426)>>);
[[maybe_unused]] const auto lambda_427 = [](volatile int * volatile &&, const volatile int * volatile &&, int * const volatile &&, const int * const volatile &&, ...) mutable noexcept -> const std::string * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_427)>::result_type, const std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_427)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_427)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_427)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_427)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_427)>::arg0_type, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_427)>::arg_type<0>, volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_427)>::arg1_type, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_427)>::arg_type<1>, const volatile int * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_427)>::arg2_type, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_427)>::arg_type<2>, int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_427)>::arg_type<3>, const int * const volatile &&>);
static_assert(callable_traits<decltype(lambda_427)>::arity == 4);
static_assert(callable_traits<decltype(lambda_427)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_427)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_427)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_427)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_427)>::is_const == false);
static_assert(callable_traits<decltype(lambda_427)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_427)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_427)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_427)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_427)>::class_type, std::remove_const_t<decltype(lambda_427)>>);
[[maybe_unused]] const auto lambda_428 = [](volatile int * const volatile &&, const volatile int * const volatile &&, float, float *) -> volatile std::string * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_428)>::result_type, volatile std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_428)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_428)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_428)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_428)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_428)>::arg0_type, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_428)>::arg_type<0>, volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_428)>::arg1_type, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_428)>::arg_type<1>, const volatile int * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_428)>::arg2_type, float>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_428)>::arg_type<2>, float>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_428)>::arg_type<3>, float *>);
static_assert(callable_traits<decltype(lambda_428)>::arity == 4);
static_assert(callable_traits<decltype(lambda_428)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_428)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_428)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_428)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_428)>::is_const == true);
static_assert(callable_traits<decltype(lambda_428)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_428)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_428)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_428)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_428)>::class_type, std::remove_const_t<decltype(lambda_428)>>);
[[maybe_unused]] const auto lambda_429 = [](const float *, volatile float *, const volatile float *, float &, ...) mutable -> const volatile std::string * volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_429)>::result_type, const volatile std::string * volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_429)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_429)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_429)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_429)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_429)>::arg0_type, const float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_429)>::arg_type<0>, const float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_429)>::arg1_type, volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_429)>::arg_type<1>, volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_429)>::arg2_type, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_429)>::arg_type<2>, const volatile float *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_429)>::arg_type<3>, float &>);
static_assert(callable_traits<decltype(lambda_429)>::arity == 4);
static_assert(callable_traits<decltype(lambda_429)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_429)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_429)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_429)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_429)>::is_const == false);
static_assert(callable_traits<decltype(lambda_429)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_429)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_429)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_429)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_429)>::class_type, std::remove_const_t<decltype(lambda_429)>>);
[[maybe_unused]] const auto lambda_430 = [](const float &, volatile float &, const volatile float &, float * &) noexcept -> std::string * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_430)>::result_type, std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_430)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_430)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_430)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_430)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_430)>::arg0_type, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_430)>::arg_type<0>, const float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_430)>::arg1_type, volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_430)>::arg_type<1>, volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_430)>::arg2_type, const volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_430)>::arg_type<2>, const volatile float &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_430)>::arg_type<3>, float * &>);
static_assert(callable_traits<decltype(lambda_430)>::arity == 4);
static_assert(callable_traits<decltype(lambda_430)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_430)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_430)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_430)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_430)>::is_const == true);
static_assert(callable_traits<decltype(lambda_430)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_430)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_430)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_430)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_430)>::class_type, std::remove_const_t<decltype(lambda_430)>>);
[[maybe_unused]] const auto lambda_431 = [](const float * &, volatile float * &, const volatile float * &, float * const &, ...) mutable noexcept -> const std::string * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_431)>::result_type, const std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_431)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_431)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_431)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_431)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_431)>::arg0_type, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_431)>::arg_type<0>, const float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_431)>::arg1_type, volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_431)>::arg_type<1>, volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_431)>::arg2_type, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_431)>::arg_type<2>, const volatile float * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_431)>::arg_type<3>, float * const &>);
static_assert(callable_traits<decltype(lambda_431)>::arity == 4);
static_assert(callable_traits<decltype(lambda_431)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_431)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_431)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_431)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_431)>::is_const == false);
static_assert(callable_traits<decltype(lambda_431)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_431)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_431)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_431)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_431)>::class_type, std::remove_const_t<decltype(lambda_431)>>);
[[maybe_unused]] const auto lambda_432 = [](const float * const &, volatile float * const &, const volatile float * const &, float * volatile &) -> volatile std::string * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_432)>::result_type, volatile std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_432)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_432)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_432)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_432)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_432)>::arg0_type, const float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_432)>::arg_type<0>, const float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_432)>::arg1_type, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_432)>::arg_type<1>, volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_432)>::arg2_type, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_432)>::arg_type<2>, const volatile float * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_432)>::arg_type<3>, float * volatile &>);
static_assert(callable_traits<decltype(lambda_432)>::arity == 4);
static_assert(callable_traits<decltype(lambda_432)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_432)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_432)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_432)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_432)>::is_const == true);
static_assert(callable_traits<decltype(lambda_432)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_432)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_432)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_432)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_432)>::class_type, std::remove_const_t<decltype(lambda_432)>>);
[[maybe_unused]] const auto lambda_433 = [](const float * volatile &, volatile float * volatile &, const volatile float * volatile &, float * const volatile &, ...) mutable -> const volatile std::string * const volatile && {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_433)>::result_type, const volatile std::string * const volatile &&>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_433)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_433)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_433)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_433)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_433)>::arg0_type, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_433)>::arg_type<0>, const float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_433)>::arg1_type, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_433)>::arg_type<1>, volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_433)>::arg2_type, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_433)>::arg_type<2>, const volatile float * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_433)>::arg_type<3>, float * const volatile &>);
static_assert(callable_traits<decltype(lambda_433)>::arity == 4);
static_assert(callable_traits<decltype(lambda_433)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_433)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_433)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_433)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_433)>::is_const == false);
static_assert(callable_traits<decltype(lambda_433)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_433)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_433)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_433)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_433)>::class_type, std::remove_const_t<decltype(lambda_433)>>);
[[maybe_unused]] const auto lambda_434 = [](const float * const volatile &, volatile float * const volatile &, const volatile float * const volatile &, float &&) noexcept -> void {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_434)>::result_type, void>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_434)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_434)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_434)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_434)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_434)>::arg0_type, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_434)>::arg_type<0>, const float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_434)>::arg1_type, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_434)>::arg_type<1>, volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_434)>::arg2_type, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_434)>::arg_type<2>, const volatile float * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_434)>::arg_type<3>, float &&>);
static_assert(callable_traits<decltype(lambda_434)>::arity == 4);
static_assert(callable_traits<decltype(lambda_434)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_434)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_434)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_434)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_434)>::is_const == true);
static_assert(callable_traits<decltype(lambda_434)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_434)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_434)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_434)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_434)>::class_type, std::remove_const_t<decltype(lambda_434)>>);
[[maybe_unused]] const auto lambda_435 = [](const float &&, volatile float &&, const volatile float &&, float * &&, ...) mutable noexcept -> void * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_435)>::result_type, void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_435)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_435)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_435)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_435)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_435)>::arg0_type, const float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_435)>::arg_type<0>, const float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_435)>::arg1_type, volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_435)>::arg_type<1>, volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_435)>::arg2_type, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_435)>::arg_type<2>, const volatile float &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_435)>::arg_type<3>, float * &&>);
static_assert(callable_traits<decltype(lambda_435)>::arity == 4);
static_assert(callable_traits<decltype(lambda_435)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_435)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_435)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_435)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_435)>::is_const == false);
static_assert(callable_traits<decltype(lambda_435)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_435)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_435)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_435)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_435)>::class_type, std::remove_const_t<decltype(lambda_435)>>);
[[maybe_unused]] const auto lambda_436 = [](const float * &&, volatile float * &&, const volatile float * &&, float * const &&) -> const void * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_436)>::result_type, const void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_436)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_436)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_436)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_436)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_436)>::arg0_type, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_436)>::arg_type<0>, const float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_436)>::arg1_type, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_436)>::arg_type<1>, volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_436)>::arg2_type, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_436)>::arg_type<2>, const volatile float * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_436)>::arg_type<3>, float * const &&>);
static_assert(callable_traits<decltype(lambda_436)>::arity == 4);
static_assert(callable_traits<decltype(lambda_436)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_436)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_436)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_436)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_436)>::is_const == true);
static_assert(callable_traits<decltype(lambda_436)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_436)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_436)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_436)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_436)>::class_type, std::remove_const_t<decltype(lambda_436)>>);
[[maybe_unused]] const auto lambda_437 = [](const float * const &&, volatile float * const &&, const volatile float * const &&, float * volatile &&, ...) mutable -> volatile void * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_437)>::result_type, volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_437)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_437)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_437)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_437)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_437)>::arg0_type, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_437)>::arg_type<0>, const float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_437)>::arg1_type, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_437)>::arg_type<1>, volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_437)>::arg2_type, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_437)>::arg_type<2>, const volatile float * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_437)>::arg_type<3>, float * volatile &&>);
static_assert(callable_traits<decltype(lambda_437)>::arity == 4);
static_assert(callable_traits<decltype(lambda_437)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_437)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_437)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_437)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_437)>::is_const == false);
static_assert(callable_traits<decltype(lambda_437)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_437)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_437)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_437)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_437)>::class_type, std::remove_const_t<decltype(lambda_437)>>);
[[maybe_unused]] const auto lambda_438 = [](const float * volatile &&, volatile float * volatile &&, const volatile float * volatile &&, float * const volatile &&) noexcept -> const volatile void * {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_438)>::result_type, const volatile void *>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_438)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_438)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_438)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_438)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_438)>::arg0_type, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_438)>::arg_type<0>, const float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_438)>::arg1_type, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_438)>::arg_type<1>, volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_438)>::arg2_type, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_438)>::arg_type<2>, const volatile float * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_438)>::arg_type<3>, float * const volatile &&>);
static_assert(callable_traits<decltype(lambda_438)>::arity == 4);
static_assert(callable_traits<decltype(lambda_438)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_438)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_438)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_438)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_438)>::is_const == true);
static_assert(callable_traits<decltype(lambda_438)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_438)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_438)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_438)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_438)>::class_type, std::remove_const_t<decltype(lambda_438)>>);
[[maybe_unused]] const auto lambda_439 = [](const float * const volatile &&, volatile float * const volatile &&, const volatile float * const volatile &&, std::string, ...) mutable noexcept -> void * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_439)>::result_type, void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_439)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_439)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_439)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_439)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_439)>::arg0_type, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_439)>::arg_type<0>, const float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_439)>::arg1_type, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_439)>::arg_type<1>, volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_439)>::arg2_type, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_439)>::arg_type<2>, const volatile float * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_439)>::arg_type<3>, std::string>);
static_assert(callable_traits<decltype(lambda_439)>::arity == 4);
static_assert(callable_traits<decltype(lambda_439)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_439)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_439)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_439)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_439)>::is_const == false);
static_assert(callable_traits<decltype(lambda_439)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_439)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_439)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_439)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_439)>::class_type, std::remove_const_t<decltype(lambda_439)>>);
[[maybe_unused]] const auto lambda_440 = [](std::string *, const std::string *, volatile std::string *, const volatile std::string *) -> const void * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_440)>::result_type, const void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_440)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_440)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_440)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_440)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_440)>::arg0_type, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_440)>::arg_type<0>, std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_440)>::arg1_type, const std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_440)>::arg_type<1>, const std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_440)>::arg2_type, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_440)>::arg_type<2>, volatile std::string *>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_440)>::arg_type<3>, const volatile std::string *>);
static_assert(callable_traits<decltype(lambda_440)>::arity == 4);
static_assert(callable_traits<decltype(lambda_440)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_440)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_440)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_440)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_440)>::is_const == true);
static_assert(callable_traits<decltype(lambda_440)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_440)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_440)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_440)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_440)>::class_type, std::remove_const_t<decltype(lambda_440)>>);
[[maybe_unused]] const auto lambda_441 = [](std::string &, const std::string &, volatile std::string &, const volatile std::string &, ...) mutable -> volatile void * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_441)>::result_type, volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_441)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_441)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_441)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_441)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_441)>::arg0_type, std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_441)>::arg_type<0>, std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_441)>::arg1_type, const std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_441)>::arg_type<1>, const std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_441)>::arg2_type, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_441)>::arg_type<2>, volatile std::string &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_441)>::arg_type<3>, const volatile std::string &>);
static_assert(callable_traits<decltype(lambda_441)>::arity == 4);
static_assert(callable_traits<decltype(lambda_441)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_441)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_441)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_441)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_441)>::is_const == false);
static_assert(callable_traits<decltype(lambda_441)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_441)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_441)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_441)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_441)>::class_type, std::remove_const_t<decltype(lambda_441)>>);
[[maybe_unused]] const auto lambda_442 = [](std::string * &, const std::string * &, volatile std::string * &, const volatile std::string * &) noexcept -> const volatile void * & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_442)>::result_type, const volatile void * &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_442)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_442)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_442)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_442)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_442)>::arg0_type, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_442)>::arg_type<0>, std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_442)>::arg1_type, const std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_442)>::arg_type<1>, const std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_442)>::arg2_type, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_442)>::arg_type<2>, volatile std::string * &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_442)>::arg_type<3>, const volatile std::string * &>);
static_assert(callable_traits<decltype(lambda_442)>::arity == 4);
static_assert(callable_traits<decltype(lambda_442)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_442)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_442)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_442)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_442)>::is_const == true);
static_assert(callable_traits<decltype(lambda_442)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_442)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_442)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_442)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_442)>::class_type, std::remove_const_t<decltype(lambda_442)>>);
[[maybe_unused]] const auto lambda_443 = [](std::string * const &, const std::string * const &, volatile std::string * const &, const volatile std::string * const &, ...) mutable noexcept -> void * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_443)>::result_type, void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_443)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_443)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_443)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_443)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_443)>::arg0_type, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_443)>::arg_type<0>, std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_443)>::arg1_type, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_443)>::arg_type<1>, const std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_443)>::arg2_type, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_443)>::arg_type<2>, volatile std::string * const &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_443)>::arg_type<3>, const volatile std::string * const &>);
static_assert(callable_traits<decltype(lambda_443)>::arity == 4);
static_assert(callable_traits<decltype(lambda_443)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_443)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_443)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_443)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_443)>::is_const == false);
static_assert(callable_traits<decltype(lambda_443)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_443)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_443)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_443)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_443)>::class_type, std::remove_const_t<decltype(lambda_443)>>);
[[maybe_unused]] const auto lambda_444 = [](std::string * volatile &, const std::string * volatile &, volatile std::string * volatile &, const volatile std::string * volatile &) -> const void * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_444)>::result_type, const void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_444)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_444)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_444)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_444)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_444)>::arg0_type, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_444)>::arg_type<0>, std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_444)>::arg1_type, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_444)>::arg_type<1>, const std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_444)>::arg2_type, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_444)>::arg_type<2>, volatile std::string * volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_444)>::arg_type<3>, const volatile std::string * volatile &>);
static_assert(callable_traits<decltype(lambda_444)>::arity == 4);
static_assert(callable_traits<decltype(lambda_444)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_444)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_444)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_444)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_444)>::is_const == true);
static_assert(callable_traits<decltype(lambda_444)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_444)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_444)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_444)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_444)>::class_type, std::remove_const_t<decltype(lambda_444)>>);
[[maybe_unused]] const auto lambda_445 = [](std::string * const volatile &, const std::string * const volatile &, volatile std::string * const volatile &, const volatile std::string * const volatile &, ...) mutable -> volatile void * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_445)>::result_type, volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_445)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_445)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_445)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_445)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_445)>::arg0_type, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_445)>::arg_type<0>, std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_445)>::arg1_type, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_445)>::arg_type<1>, const std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_445)>::arg2_type, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_445)>::arg_type<2>, volatile std::string * const volatile &>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_445)>::arg_type<3>, const volatile std::string * const volatile &>);
static_assert(callable_traits<decltype(lambda_445)>::arity == 4);
static_assert(callable_traits<decltype(lambda_445)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_445)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_445)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_445)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_445)>::is_const == false);
static_assert(callable_traits<decltype(lambda_445)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_445)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_445)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_445)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_445)>::class_type, std::remove_const_t<decltype(lambda_445)>>);
[[maybe_unused]] const auto lambda_446 = [](std::string &&, const std::string &&, volatile std::string &&, const volatile std::string &&) noexcept -> const volatile void * const & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_446)>::result_type, const volatile void * const &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_446)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_446)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_446)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_446)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_446)>::arg0_type, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_446)>::arg_type<0>, std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_446)>::arg1_type, const std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_446)>::arg_type<1>, const std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_446)>::arg2_type, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_446)>::arg_type<2>, volatile std::string &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_446)>::arg_type<3>, const volatile std::string &&>);
static_assert(callable_traits<decltype(lambda_446)>::arity == 4);
static_assert(callable_traits<decltype(lambda_446)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_446)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_446)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_446)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_446)>::is_const == true);
static_assert(callable_traits<decltype(lambda_446)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_446)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_446)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_446)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_446)>::class_type, std::remove_const_t<decltype(lambda_446)>>);
[[maybe_unused]] const auto lambda_447 = [](std::string * &&, const std::string * &&, volatile std::string * &&, const volatile std::string * &&, ...) mutable noexcept -> void * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_447)>::result_type, void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_447)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_447)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_447)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_447)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_447)>::arg0_type, std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_447)>::arg_type<0>, std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_447)>::arg1_type, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_447)>::arg_type<1>, const std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_447)>::arg2_type, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_447)>::arg_type<2>, volatile std::string * &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_447)>::arg_type<3>, const volatile std::string * &&>);
static_assert(callable_traits<decltype(lambda_447)>::arity == 4);
static_assert(callable_traits<decltype(lambda_447)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_447)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_447)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_447)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_447)>::is_const == false);
static_assert(callable_traits<decltype(lambda_447)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_447)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_447)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_447)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_447)>::class_type, std::remove_const_t<decltype(lambda_447)>>);
[[maybe_unused]] const auto lambda_448 = [](std::string * const &&, const std::string * const &&, volatile std::string * const &&, const volatile std::string * const &&) -> const void * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_448)>::result_type, const void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_448)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_448)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_448)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_448)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_448)>::arg0_type, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_448)>::arg_type<0>, std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_448)>::arg1_type, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_448)>::arg_type<1>, const std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_448)>::arg2_type, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_448)>::arg_type<2>, volatile std::string * const &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_448)>::arg_type<3>, const volatile std::string * const &&>);
static_assert(callable_traits<decltype(lambda_448)>::arity == 4);
static_assert(callable_traits<decltype(lambda_448)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_448)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_448)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_448)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_448)>::is_const == true);
static_assert(callable_traits<decltype(lambda_448)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_448)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_448)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_448)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_448)>::class_type, std::remove_const_t<decltype(lambda_448)>>);
[[maybe_unused]] const auto lambda_449 = [](std::string * volatile &&, const std::string * volatile &&, volatile std::string * volatile &&, const volatile std::string * volatile &&, ...) mutable -> volatile void * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_449)>::result_type, volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_449)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_449)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_449)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_449)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_449)>::arg0_type, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_449)>::arg_type<0>, std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_449)>::arg1_type, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_449)>::arg_type<1>, const std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_449)>::arg2_type, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_449)>::arg_type<2>, volatile std::string * volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_449)>::arg_type<3>, const volatile std::string * volatile &&>);
static_assert(callable_traits<decltype(lambda_449)>::arity == 4);
static_assert(callable_traits<decltype(lambda_449)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_449)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_449)>::is_variadic == true);
static_assert(callable_traits<decltype(lambda_449)>::is_noexcept == false);
static_assert(callable_traits<decltype(lambda_449)>::is_const == false);
static_assert(callable_traits<decltype(lambda_449)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_449)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_449)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_449)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_449)>::class_type, std::remove_const_t<decltype(lambda_449)>>);
[[maybe_unused]] const auto lambda_450 = [](std::string * const volatile &&, const std::string * const volatile &&, volatile std::string * const volatile &&, const volatile std::string * const volatile &&) noexcept -> const volatile void * volatile & {};
static_assert(std::is_same_v<callable_traits<decltype(lambda_450)>::result_type, const volatile void * volatile &>);
static_assert(helper::has_arg0_type_v<callable_traits<decltype(lambda_450)>> == true);
static_assert(helper::has_arg1_type_v<callable_traits<decltype(lambda_450)>> == true);
static_assert(helper::has_arg2_type_v<callable_traits<decltype(lambda_450)>> == true);
static_assert(helper::has_arg3_type_v<callable_traits<decltype(lambda_450)>> == false);
static_assert(std::is_same_v<callable_traits<decltype(lambda_450)>::arg0_type, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_450)>::arg_type<0>, std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_450)>::arg1_type, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_450)>::arg_type<1>, const std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_450)>::arg2_type, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_450)>::arg_type<2>, volatile std::string * const volatile &&>);
static_assert(std::is_same_v<callable_traits<decltype(lambda_450)>::arg_type<3>, const volatile std::string * const volatile &&>);
static_assert(callable_traits<decltype(lambda_450)>::arity == 4);
static_assert(callable_traits<decltype(lambda_450)>::is_functor == true);
static_assert(callable_traits<decltype(lambda_450)>::is_member_function == false);
static_assert(callable_traits<decltype(lambda_450)>::is_variadic == false);
static_assert(callable_traits<decltype(lambda_450)>::is_noexcept == true);
static_assert(callable_traits<decltype(lambda_450)>::is_const == true);
static_assert(callable_traits<decltype(lambda_450)>::is_volatile == false);
static_assert(callable_traits<decltype(lambda_450)>::is_lvalue_reference == false);
static_assert(callable_traits<decltype(lambda_450)>::is_rvalue_reference == false);
static_assert(helper::has_class_type_v<callable_traits<decltype(lambda_450)>> == true);
static_assert(std::is_same_v<callable_traits<decltype(lambda_450)>::class_type, std::remove_const_t<decltype(lambda_450)>>);
int main() { return 0; }
